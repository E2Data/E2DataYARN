// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: csi.proto

package csi.v0;

public final class Csi {
  private Csi() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface GetPluginInfoRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.GetPluginInfoRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v0.GetPluginInfoRequest}
   */
  public  static final class GetPluginInfoRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.GetPluginInfoRequest)
      GetPluginInfoRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GetPluginInfoRequest.newBuilder() to construct.
    private GetPluginInfoRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GetPluginInfoRequest() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private GetPluginInfoRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_GetPluginInfoRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_GetPluginInfoRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.GetPluginInfoRequest.class, csi.v0.Csi.GetPluginInfoRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.GetPluginInfoRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.GetPluginInfoRequest other = (csi.v0.Csi.GetPluginInfoRequest) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.GetPluginInfoRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetPluginInfoRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginInfoRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetPluginInfoRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginInfoRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetPluginInfoRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginInfoRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetPluginInfoRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginInfoRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetPluginInfoRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetPluginInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.GetPluginInfoRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v0.GetPluginInfoRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.GetPluginInfoRequest)
        csi.v0.Csi.GetPluginInfoRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_GetPluginInfoRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_GetPluginInfoRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.GetPluginInfoRequest.class, csi.v0.Csi.GetPluginInfoRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.GetPluginInfoRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_GetPluginInfoRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.GetPluginInfoRequest getDefaultInstanceForType() {
        return csi.v0.Csi.GetPluginInfoRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.GetPluginInfoRequest build() {
        csi.v0.Csi.GetPluginInfoRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.GetPluginInfoRequest buildPartial() {
        csi.v0.Csi.GetPluginInfoRequest result = new csi.v0.Csi.GetPluginInfoRequest(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.GetPluginInfoRequest) {
          return mergeFrom((csi.v0.Csi.GetPluginInfoRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.GetPluginInfoRequest other) {
        if (other == csi.v0.Csi.GetPluginInfoRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.GetPluginInfoRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.GetPluginInfoRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.GetPluginInfoRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.GetPluginInfoRequest)
    private static final csi.v0.Csi.GetPluginInfoRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.GetPluginInfoRequest();
    }

    public static csi.v0.Csi.GetPluginInfoRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GetPluginInfoRequest>
        PARSER = new com.google.protobuf.AbstractParser<GetPluginInfoRequest>() {
      @java.lang.Override
      public GetPluginInfoRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new GetPluginInfoRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<GetPluginInfoRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GetPluginInfoRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.GetPluginInfoRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GetPluginInfoResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.GetPluginInfoResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The name MUST follow reverse domain name notation format
     * (https://en.wikipedia.org/wiki/Reverse_domain_name_notation).
     * It SHOULD include the plugin's host company name and the plugin
     * name, to minimize the possibility of collisions. It MUST be 63
     * characters or less, beginning and ending with an alphanumeric
     * character ([a-z0-9A-Z]) with dashes (-), underscores (_),
     * dots (.), and alphanumerics between. This field is REQUIRED.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * The name MUST follow reverse domain name notation format
     * (https://en.wikipedia.org/wiki/Reverse_domain_name_notation).
     * It SHOULD include the plugin's host company name and the plugin
     * name, to minimize the possibility of collisions. It MUST be 63
     * characters or less, beginning and ending with an alphanumeric
     * character ([a-z0-9A-Z]) with dashes (-), underscores (_),
     * dots (.), and alphanumerics between. This field is REQUIRED.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * This field is REQUIRED. Value of this field is opaque to the CO.
     * </pre>
     *
     * <code>string vendor_version = 2;</code>
     */
    java.lang.String getVendorVersion();
    /**
     * <pre>
     * This field is REQUIRED. Value of this field is opaque to the CO.
     * </pre>
     *
     * <code>string vendor_version = 2;</code>
     */
    com.google.protobuf.ByteString
        getVendorVersionBytes();

    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */
    int getManifestCount();
    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */
    boolean containsManifest(
        java.lang.String key);
    /**
     * Use {@link #getManifestMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getManifest();
    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getManifestMap();
    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */

    java.lang.String getManifestOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */

    java.lang.String getManifestOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v0.GetPluginInfoResponse}
   */
  public  static final class GetPluginInfoResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.GetPluginInfoResponse)
      GetPluginInfoResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GetPluginInfoResponse.newBuilder() to construct.
    private GetPluginInfoResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GetPluginInfoResponse() {
      name_ = "";
      vendorVersion_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private GetPluginInfoResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              vendorVersion_ = s;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                manifest_ = com.google.protobuf.MapField.newMapField(
                    ManifestDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000004;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              manifest__ = input.readMessage(
                  ManifestDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              manifest_.getMutableMap().put(
                  manifest__.getKey(), manifest__.getValue());
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_GetPluginInfoResponse_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 3:
          return internalGetManifest();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_GetPluginInfoResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.GetPluginInfoResponse.class, csi.v0.Csi.GetPluginInfoResponse.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * The name MUST follow reverse domain name notation format
     * (https://en.wikipedia.org/wiki/Reverse_domain_name_notation).
     * It SHOULD include the plugin's host company name and the plugin
     * name, to minimize the possibility of collisions. It MUST be 63
     * characters or less, beginning and ending with an alphanumeric
     * character ([a-z0-9A-Z]) with dashes (-), underscores (_),
     * dots (.), and alphanumerics between. This field is REQUIRED.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The name MUST follow reverse domain name notation format
     * (https://en.wikipedia.org/wiki/Reverse_domain_name_notation).
     * It SHOULD include the plugin's host company name and the plugin
     * name, to minimize the possibility of collisions. It MUST be 63
     * characters or less, beginning and ending with an alphanumeric
     * character ([a-z0-9A-Z]) with dashes (-), underscores (_),
     * dots (.), and alphanumerics between. This field is REQUIRED.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VENDOR_VERSION_FIELD_NUMBER = 2;
    private volatile java.lang.Object vendorVersion_;
    /**
     * <pre>
     * This field is REQUIRED. Value of this field is opaque to the CO.
     * </pre>
     *
     * <code>string vendor_version = 2;</code>
     */
    public java.lang.String getVendorVersion() {
      java.lang.Object ref = vendorVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        vendorVersion_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * This field is REQUIRED. Value of this field is opaque to the CO.
     * </pre>
     *
     * <code>string vendor_version = 2;</code>
     */
    public com.google.protobuf.ByteString
        getVendorVersionBytes() {
      java.lang.Object ref = vendorVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        vendorVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MANIFEST_FIELD_NUMBER = 3;
    private static final class ManifestDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_GetPluginInfoResponse_ManifestEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> manifest_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetManifest() {
      if (manifest_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ManifestDefaultEntryHolder.defaultEntry);
      }
      return manifest_;
    }

    public int getManifestCount() {
      return internalGetManifest().getMap().size();
    }
    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */

    public boolean containsManifest(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetManifest().getMap().containsKey(key);
    }
    /**
     * Use {@link #getManifestMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getManifest() {
      return getManifestMap();
    }
    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getManifestMap() {
      return internalGetManifest().getMap();
    }
    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */

    public java.lang.String getManifestOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetManifest().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * This field is OPTIONAL. Values are opaque to the CO.
     * </pre>
     *
     * <code>map&lt;string, string&gt; manifest = 3;</code>
     */

    public java.lang.String getManifestOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetManifest().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (!getVendorVersionBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, vendorVersion_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetManifest(),
          ManifestDefaultEntryHolder.defaultEntry,
          3);
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (!getVendorVersionBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, vendorVersion_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetManifest().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        manifest__ = ManifestDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(3, manifest__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.GetPluginInfoResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.GetPluginInfoResponse other = (csi.v0.Csi.GetPluginInfoResponse) obj;

      boolean result = true;
      result = result && getName()
          .equals(other.getName());
      result = result && getVendorVersion()
          .equals(other.getVendorVersion());
      result = result && internalGetManifest().equals(
          other.internalGetManifest());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      hash = (37 * hash) + VENDOR_VERSION_FIELD_NUMBER;
      hash = (53 * hash) + getVendorVersion().hashCode();
      if (!internalGetManifest().getMap().isEmpty()) {
        hash = (37 * hash) + MANIFEST_FIELD_NUMBER;
        hash = (53 * hash) + internalGetManifest().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.GetPluginInfoResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetPluginInfoResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginInfoResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetPluginInfoResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginInfoResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetPluginInfoResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginInfoResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetPluginInfoResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginInfoResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetPluginInfoResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginInfoResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetPluginInfoResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.GetPluginInfoResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.GetPluginInfoResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.GetPluginInfoResponse)
        csi.v0.Csi.GetPluginInfoResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_GetPluginInfoResponse_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetManifest();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetMutableManifest();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_GetPluginInfoResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.GetPluginInfoResponse.class, csi.v0.Csi.GetPluginInfoResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.GetPluginInfoResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";

        vendorVersion_ = "";

        internalGetMutableManifest().clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_GetPluginInfoResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.GetPluginInfoResponse getDefaultInstanceForType() {
        return csi.v0.Csi.GetPluginInfoResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.GetPluginInfoResponse build() {
        csi.v0.Csi.GetPluginInfoResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.GetPluginInfoResponse buildPartial() {
        csi.v0.Csi.GetPluginInfoResponse result = new csi.v0.Csi.GetPluginInfoResponse(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.name_ = name_;
        result.vendorVersion_ = vendorVersion_;
        result.manifest_ = internalGetManifest();
        result.manifest_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.GetPluginInfoResponse) {
          return mergeFrom((csi.v0.Csi.GetPluginInfoResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.GetPluginInfoResponse other) {
        if (other == csi.v0.Csi.GetPluginInfoResponse.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (!other.getVendorVersion().isEmpty()) {
          vendorVersion_ = other.vendorVersion_;
          onChanged();
        }
        internalGetMutableManifest().mergeFrom(
            other.internalGetManifest());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.GetPluginInfoResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.GetPluginInfoResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The name MUST follow reverse domain name notation format
       * (https://en.wikipedia.org/wiki/Reverse_domain_name_notation).
       * It SHOULD include the plugin's host company name and the plugin
       * name, to minimize the possibility of collisions. It MUST be 63
       * characters or less, beginning and ending with an alphanumeric
       * character ([a-z0-9A-Z]) with dashes (-), underscores (_),
       * dots (.), and alphanumerics between. This field is REQUIRED.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The name MUST follow reverse domain name notation format
       * (https://en.wikipedia.org/wiki/Reverse_domain_name_notation).
       * It SHOULD include the plugin's host company name and the plugin
       * name, to minimize the possibility of collisions. It MUST be 63
       * characters or less, beginning and ending with an alphanumeric
       * character ([a-z0-9A-Z]) with dashes (-), underscores (_),
       * dots (.), and alphanumerics between. This field is REQUIRED.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name MUST follow reverse domain name notation format
       * (https://en.wikipedia.org/wiki/Reverse_domain_name_notation).
       * It SHOULD include the plugin's host company name and the plugin
       * name, to minimize the possibility of collisions. It MUST be 63
       * characters or less, beginning and ending with an alphanumeric
       * character ([a-z0-9A-Z]) with dashes (-), underscores (_),
       * dots (.), and alphanumerics between. This field is REQUIRED.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name MUST follow reverse domain name notation format
       * (https://en.wikipedia.org/wiki/Reverse_domain_name_notation).
       * It SHOULD include the plugin's host company name and the plugin
       * name, to minimize the possibility of collisions. It MUST be 63
       * characters or less, beginning and ending with an alphanumeric
       * character ([a-z0-9A-Z]) with dashes (-), underscores (_),
       * dots (.), and alphanumerics between. This field is REQUIRED.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name MUST follow reverse domain name notation format
       * (https://en.wikipedia.org/wiki/Reverse_domain_name_notation).
       * It SHOULD include the plugin's host company name and the plugin
       * name, to minimize the possibility of collisions. It MUST be 63
       * characters or less, beginning and ending with an alphanumeric
       * character ([a-z0-9A-Z]) with dashes (-), underscores (_),
       * dots (.), and alphanumerics between. This field is REQUIRED.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object vendorVersion_ = "";
      /**
       * <pre>
       * This field is REQUIRED. Value of this field is opaque to the CO.
       * </pre>
       *
       * <code>string vendor_version = 2;</code>
       */
      public java.lang.String getVendorVersion() {
        java.lang.Object ref = vendorVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          vendorVersion_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This field is REQUIRED. Value of this field is opaque to the CO.
       * </pre>
       *
       * <code>string vendor_version = 2;</code>
       */
      public com.google.protobuf.ByteString
          getVendorVersionBytes() {
        java.lang.Object ref = vendorVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          vendorVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This field is REQUIRED. Value of this field is opaque to the CO.
       * </pre>
       *
       * <code>string vendor_version = 2;</code>
       */
      public Builder setVendorVersion(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        vendorVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field is REQUIRED. Value of this field is opaque to the CO.
       * </pre>
       *
       * <code>string vendor_version = 2;</code>
       */
      public Builder clearVendorVersion() {
        
        vendorVersion_ = getDefaultInstance().getVendorVersion();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field is REQUIRED. Value of this field is opaque to the CO.
       * </pre>
       *
       * <code>string vendor_version = 2;</code>
       */
      public Builder setVendorVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        vendorVersion_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> manifest_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetManifest() {
        if (manifest_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ManifestDefaultEntryHolder.defaultEntry);
        }
        return manifest_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableManifest() {
        onChanged();;
        if (manifest_ == null) {
          manifest_ = com.google.protobuf.MapField.newMapField(
              ManifestDefaultEntryHolder.defaultEntry);
        }
        if (!manifest_.isMutable()) {
          manifest_ = manifest_.copy();
        }
        return manifest_;
      }

      public int getManifestCount() {
        return internalGetManifest().getMap().size();
      }
      /**
       * <pre>
       * This field is OPTIONAL. Values are opaque to the CO.
       * </pre>
       *
       * <code>map&lt;string, string&gt; manifest = 3;</code>
       */

      public boolean containsManifest(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetManifest().getMap().containsKey(key);
      }
      /**
       * Use {@link #getManifestMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getManifest() {
        return getManifestMap();
      }
      /**
       * <pre>
       * This field is OPTIONAL. Values are opaque to the CO.
       * </pre>
       *
       * <code>map&lt;string, string&gt; manifest = 3;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getManifestMap() {
        return internalGetManifest().getMap();
      }
      /**
       * <pre>
       * This field is OPTIONAL. Values are opaque to the CO.
       * </pre>
       *
       * <code>map&lt;string, string&gt; manifest = 3;</code>
       */

      public java.lang.String getManifestOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetManifest().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * This field is OPTIONAL. Values are opaque to the CO.
       * </pre>
       *
       * <code>map&lt;string, string&gt; manifest = 3;</code>
       */

      public java.lang.String getManifestOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetManifest().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearManifest() {
        internalGetMutableManifest().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL. Values are opaque to the CO.
       * </pre>
       *
       * <code>map&lt;string, string&gt; manifest = 3;</code>
       */

      public Builder removeManifest(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableManifest().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableManifest() {
        return internalGetMutableManifest().getMutableMap();
      }
      /**
       * <pre>
       * This field is OPTIONAL. Values are opaque to the CO.
       * </pre>
       *
       * <code>map&lt;string, string&gt; manifest = 3;</code>
       */
      public Builder putManifest(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableManifest().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * This field is OPTIONAL. Values are opaque to the CO.
       * </pre>
       *
       * <code>map&lt;string, string&gt; manifest = 3;</code>
       */

      public Builder putAllManifest(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableManifest().getMutableMap()
            .putAll(values);
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.GetPluginInfoResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.GetPluginInfoResponse)
    private static final csi.v0.Csi.GetPluginInfoResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.GetPluginInfoResponse();
    }

    public static csi.v0.Csi.GetPluginInfoResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GetPluginInfoResponse>
        PARSER = new com.google.protobuf.AbstractParser<GetPluginInfoResponse>() {
      @java.lang.Override
      public GetPluginInfoResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new GetPluginInfoResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<GetPluginInfoResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GetPluginInfoResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.GetPluginInfoResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GetPluginCapabilitiesRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.GetPluginCapabilitiesRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v0.GetPluginCapabilitiesRequest}
   */
  public  static final class GetPluginCapabilitiesRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.GetPluginCapabilitiesRequest)
      GetPluginCapabilitiesRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GetPluginCapabilitiesRequest.newBuilder() to construct.
    private GetPluginCapabilitiesRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GetPluginCapabilitiesRequest() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private GetPluginCapabilitiesRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_GetPluginCapabilitiesRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_GetPluginCapabilitiesRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.GetPluginCapabilitiesRequest.class, csi.v0.Csi.GetPluginCapabilitiesRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.GetPluginCapabilitiesRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.GetPluginCapabilitiesRequest other = (csi.v0.Csi.GetPluginCapabilitiesRequest) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.GetPluginCapabilitiesRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.GetPluginCapabilitiesRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v0.GetPluginCapabilitiesRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.GetPluginCapabilitiesRequest)
        csi.v0.Csi.GetPluginCapabilitiesRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_GetPluginCapabilitiesRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_GetPluginCapabilitiesRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.GetPluginCapabilitiesRequest.class, csi.v0.Csi.GetPluginCapabilitiesRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.GetPluginCapabilitiesRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_GetPluginCapabilitiesRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.GetPluginCapabilitiesRequest getDefaultInstanceForType() {
        return csi.v0.Csi.GetPluginCapabilitiesRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.GetPluginCapabilitiesRequest build() {
        csi.v0.Csi.GetPluginCapabilitiesRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.GetPluginCapabilitiesRequest buildPartial() {
        csi.v0.Csi.GetPluginCapabilitiesRequest result = new csi.v0.Csi.GetPluginCapabilitiesRequest(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.GetPluginCapabilitiesRequest) {
          return mergeFrom((csi.v0.Csi.GetPluginCapabilitiesRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.GetPluginCapabilitiesRequest other) {
        if (other == csi.v0.Csi.GetPluginCapabilitiesRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.GetPluginCapabilitiesRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.GetPluginCapabilitiesRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.GetPluginCapabilitiesRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.GetPluginCapabilitiesRequest)
    private static final csi.v0.Csi.GetPluginCapabilitiesRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.GetPluginCapabilitiesRequest();
    }

    public static csi.v0.Csi.GetPluginCapabilitiesRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GetPluginCapabilitiesRequest>
        PARSER = new com.google.protobuf.AbstractParser<GetPluginCapabilitiesRequest>() {
      @java.lang.Override
      public GetPluginCapabilitiesRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new GetPluginCapabilitiesRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<GetPluginCapabilitiesRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GetPluginCapabilitiesRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.GetPluginCapabilitiesRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GetPluginCapabilitiesResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.GetPluginCapabilitiesResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
     */
    java.util.List<csi.v0.Csi.PluginCapability> 
        getCapabilitiesList();
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
     */
    csi.v0.Csi.PluginCapability getCapabilities(int index);
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
     */
    int getCapabilitiesCount();
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
     */
    java.util.List<? extends csi.v0.Csi.PluginCapabilityOrBuilder> 
        getCapabilitiesOrBuilderList();
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
     */
    csi.v0.Csi.PluginCapabilityOrBuilder getCapabilitiesOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code csi.v0.GetPluginCapabilitiesResponse}
   */
  public  static final class GetPluginCapabilitiesResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.GetPluginCapabilitiesResponse)
      GetPluginCapabilitiesResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GetPluginCapabilitiesResponse.newBuilder() to construct.
    private GetPluginCapabilitiesResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GetPluginCapabilitiesResponse() {
      capabilities_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private GetPluginCapabilitiesResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 18: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                capabilities_ = new java.util.ArrayList<csi.v0.Csi.PluginCapability>();
                mutable_bitField0_ |= 0x00000001;
              }
              capabilities_.add(
                  input.readMessage(csi.v0.Csi.PluginCapability.parser(), extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          capabilities_ = java.util.Collections.unmodifiableList(capabilities_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_GetPluginCapabilitiesResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_GetPluginCapabilitiesResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.GetPluginCapabilitiesResponse.class, csi.v0.Csi.GetPluginCapabilitiesResponse.Builder.class);
    }

    public static final int CAPABILITIES_FIELD_NUMBER = 2;
    private java.util.List<csi.v0.Csi.PluginCapability> capabilities_;
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
     */
    public java.util.List<csi.v0.Csi.PluginCapability> getCapabilitiesList() {
      return capabilities_;
    }
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
     */
    public java.util.List<? extends csi.v0.Csi.PluginCapabilityOrBuilder> 
        getCapabilitiesOrBuilderList() {
      return capabilities_;
    }
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
     */
    public int getCapabilitiesCount() {
      return capabilities_.size();
    }
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
     */
    public csi.v0.Csi.PluginCapability getCapabilities(int index) {
      return capabilities_.get(index);
    }
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
     */
    public csi.v0.Csi.PluginCapabilityOrBuilder getCapabilitiesOrBuilder(
        int index) {
      return capabilities_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < capabilities_.size(); i++) {
        output.writeMessage(2, capabilities_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < capabilities_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, capabilities_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.GetPluginCapabilitiesResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.GetPluginCapabilitiesResponse other = (csi.v0.Csi.GetPluginCapabilitiesResponse) obj;

      boolean result = true;
      result = result && getCapabilitiesList()
          .equals(other.getCapabilitiesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getCapabilitiesCount() > 0) {
        hash = (37 * hash) + CAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getCapabilitiesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.GetPluginCapabilitiesResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetPluginCapabilitiesResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.GetPluginCapabilitiesResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.GetPluginCapabilitiesResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.GetPluginCapabilitiesResponse)
        csi.v0.Csi.GetPluginCapabilitiesResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_GetPluginCapabilitiesResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_GetPluginCapabilitiesResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.GetPluginCapabilitiesResponse.class, csi.v0.Csi.GetPluginCapabilitiesResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.GetPluginCapabilitiesResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getCapabilitiesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (capabilitiesBuilder_ == null) {
          capabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          capabilitiesBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_GetPluginCapabilitiesResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.GetPluginCapabilitiesResponse getDefaultInstanceForType() {
        return csi.v0.Csi.GetPluginCapabilitiesResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.GetPluginCapabilitiesResponse build() {
        csi.v0.Csi.GetPluginCapabilitiesResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.GetPluginCapabilitiesResponse buildPartial() {
        csi.v0.Csi.GetPluginCapabilitiesResponse result = new csi.v0.Csi.GetPluginCapabilitiesResponse(this);
        int from_bitField0_ = bitField0_;
        if (capabilitiesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            capabilities_ = java.util.Collections.unmodifiableList(capabilities_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.capabilities_ = capabilities_;
        } else {
          result.capabilities_ = capabilitiesBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.GetPluginCapabilitiesResponse) {
          return mergeFrom((csi.v0.Csi.GetPluginCapabilitiesResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.GetPluginCapabilitiesResponse other) {
        if (other == csi.v0.Csi.GetPluginCapabilitiesResponse.getDefaultInstance()) return this;
        if (capabilitiesBuilder_ == null) {
          if (!other.capabilities_.isEmpty()) {
            if (capabilities_.isEmpty()) {
              capabilities_ = other.capabilities_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureCapabilitiesIsMutable();
              capabilities_.addAll(other.capabilities_);
            }
            onChanged();
          }
        } else {
          if (!other.capabilities_.isEmpty()) {
            if (capabilitiesBuilder_.isEmpty()) {
              capabilitiesBuilder_.dispose();
              capabilitiesBuilder_ = null;
              capabilities_ = other.capabilities_;
              bitField0_ = (bitField0_ & ~0x00000001);
              capabilitiesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getCapabilitiesFieldBuilder() : null;
            } else {
              capabilitiesBuilder_.addAllMessages(other.capabilities_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.GetPluginCapabilitiesResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.GetPluginCapabilitiesResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<csi.v0.Csi.PluginCapability> capabilities_ =
        java.util.Collections.emptyList();
      private void ensureCapabilitiesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          capabilities_ = new java.util.ArrayList<csi.v0.Csi.PluginCapability>(capabilities_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.PluginCapability, csi.v0.Csi.PluginCapability.Builder, csi.v0.Csi.PluginCapabilityOrBuilder> capabilitiesBuilder_;

      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public java.util.List<csi.v0.Csi.PluginCapability> getCapabilitiesList() {
        if (capabilitiesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(capabilities_);
        } else {
          return capabilitiesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public int getCapabilitiesCount() {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.size();
        } else {
          return capabilitiesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public csi.v0.Csi.PluginCapability getCapabilities(int index) {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.get(index);
        } else {
          return capabilitiesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public Builder setCapabilities(
          int index, csi.v0.Csi.PluginCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.set(index, value);
          onChanged();
        } else {
          capabilitiesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public Builder setCapabilities(
          int index, csi.v0.Csi.PluginCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.set(index, builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public Builder addCapabilities(csi.v0.Csi.PluginCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.add(value);
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public Builder addCapabilities(
          int index, csi.v0.Csi.PluginCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.add(index, value);
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public Builder addCapabilities(
          csi.v0.Csi.PluginCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.add(builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public Builder addCapabilities(
          int index, csi.v0.Csi.PluginCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.add(index, builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public Builder addAllCapabilities(
          java.lang.Iterable<? extends csi.v0.Csi.PluginCapability> values) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, capabilities_);
          onChanged();
        } else {
          capabilitiesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public Builder clearCapabilities() {
        if (capabilitiesBuilder_ == null) {
          capabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          capabilitiesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public Builder removeCapabilities(int index) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.remove(index);
          onChanged();
        } else {
          capabilitiesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public csi.v0.Csi.PluginCapability.Builder getCapabilitiesBuilder(
          int index) {
        return getCapabilitiesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public csi.v0.Csi.PluginCapabilityOrBuilder getCapabilitiesOrBuilder(
          int index) {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.get(index);  } else {
          return capabilitiesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public java.util.List<? extends csi.v0.Csi.PluginCapabilityOrBuilder> 
           getCapabilitiesOrBuilderList() {
        if (capabilitiesBuilder_ != null) {
          return capabilitiesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(capabilities_);
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public csi.v0.Csi.PluginCapability.Builder addCapabilitiesBuilder() {
        return getCapabilitiesFieldBuilder().addBuilder(
            csi.v0.Csi.PluginCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public csi.v0.Csi.PluginCapability.Builder addCapabilitiesBuilder(
          int index) {
        return getCapabilitiesFieldBuilder().addBuilder(
            index, csi.v0.Csi.PluginCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.PluginCapability capabilities = 2;</code>
       */
      public java.util.List<csi.v0.Csi.PluginCapability.Builder> 
           getCapabilitiesBuilderList() {
        return getCapabilitiesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.PluginCapability, csi.v0.Csi.PluginCapability.Builder, csi.v0.Csi.PluginCapabilityOrBuilder> 
          getCapabilitiesFieldBuilder() {
        if (capabilitiesBuilder_ == null) {
          capabilitiesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v0.Csi.PluginCapability, csi.v0.Csi.PluginCapability.Builder, csi.v0.Csi.PluginCapabilityOrBuilder>(
                  capabilities_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          capabilities_ = null;
        }
        return capabilitiesBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.GetPluginCapabilitiesResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.GetPluginCapabilitiesResponse)
    private static final csi.v0.Csi.GetPluginCapabilitiesResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.GetPluginCapabilitiesResponse();
    }

    public static csi.v0.Csi.GetPluginCapabilitiesResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GetPluginCapabilitiesResponse>
        PARSER = new com.google.protobuf.AbstractParser<GetPluginCapabilitiesResponse>() {
      @java.lang.Override
      public GetPluginCapabilitiesResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new GetPluginCapabilitiesResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<GetPluginCapabilitiesResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GetPluginCapabilitiesResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.GetPluginCapabilitiesResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PluginCapabilityOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.PluginCapability)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Service that the plugin supports.
     * </pre>
     *
     * <code>.csi.v0.PluginCapability.Service service = 1;</code>
     */
    boolean hasService();
    /**
     * <pre>
     * Service that the plugin supports.
     * </pre>
     *
     * <code>.csi.v0.PluginCapability.Service service = 1;</code>
     */
    csi.v0.Csi.PluginCapability.Service getService();
    /**
     * <pre>
     * Service that the plugin supports.
     * </pre>
     *
     * <code>.csi.v0.PluginCapability.Service service = 1;</code>
     */
    csi.v0.Csi.PluginCapability.ServiceOrBuilder getServiceOrBuilder();

    public csi.v0.Csi.PluginCapability.TypeCase getTypeCase();
  }
  /**
   * <pre>
   * Specifies a capability of the plugin.
   * </pre>
   *
   * Protobuf type {@code csi.v0.PluginCapability}
   */
  public  static final class PluginCapability extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.PluginCapability)
      PluginCapabilityOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PluginCapability.newBuilder() to construct.
    private PluginCapability(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PluginCapability() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PluginCapability(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              csi.v0.Csi.PluginCapability.Service.Builder subBuilder = null;
              if (typeCase_ == 1) {
                subBuilder = ((csi.v0.Csi.PluginCapability.Service) type_).toBuilder();
              }
              type_ =
                  input.readMessage(csi.v0.Csi.PluginCapability.Service.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((csi.v0.Csi.PluginCapability.Service) type_);
                type_ = subBuilder.buildPartial();
              }
              typeCase_ = 1;
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_PluginCapability_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_PluginCapability_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.PluginCapability.class, csi.v0.Csi.PluginCapability.Builder.class);
    }

    public interface ServiceOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v0.PluginCapability.Service)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>.csi.v0.PluginCapability.Service.Type type = 1;</code>
       */
      int getTypeValue();
      /**
       * <code>.csi.v0.PluginCapability.Service.Type type = 1;</code>
       */
      csi.v0.Csi.PluginCapability.Service.Type getType();
    }
    /**
     * Protobuf type {@code csi.v0.PluginCapability.Service}
     */
    public  static final class Service extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v0.PluginCapability.Service)
        ServiceOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Service.newBuilder() to construct.
      private Service(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Service() {
        type_ = 0;
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private Service(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int rawValue = input.readEnum();

                type_ = rawValue;
                break;
              }
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_PluginCapability_Service_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_PluginCapability_Service_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.PluginCapability.Service.class, csi.v0.Csi.PluginCapability.Service.Builder.class);
      }

      /**
       * Protobuf enum {@code csi.v0.PluginCapability.Service.Type}
       */
      public enum Type
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <code>UNKNOWN = 0;</code>
         */
        UNKNOWN(0),
        /**
         * <pre>
         * CONTROLLER_SERVICE indicates that the Plugin provides RPCs for
         * the ControllerService. Plugins SHOULD provide this capability.
         * In rare cases certain plugins may wish to omit the
         * ControllerService entirely from their implementation, but such
         * SHOULD NOT be the common case.
         * The presence of this capability determines whether the CO will
         * attempt to invoke the REQUIRED ControllerService RPCs, as well
         * as specific RPCs as indicated by ControllerGetCapabilities.
         * </pre>
         *
         * <code>CONTROLLER_SERVICE = 1;</code>
         */
        CONTROLLER_SERVICE(1),
        /**
         * <pre>
         * ACCESSIBILITY_CONSTRAINTS indicates that the volumes for this
         * plugin may not be equally accessible by all nodes in the
         * cluster. The CO MUST use the topology information returned by
         * CreateVolumeRequest along with the topology information
         * returned by NodeGetInfo to ensure that a given volume is
         * accessible from a given node when scheduling workloads.
         * </pre>
         *
         * <code>ACCESSIBILITY_CONSTRAINTS = 2;</code>
         */
        ACCESSIBILITY_CONSTRAINTS(2),
        UNRECOGNIZED(-1),
        ;

        /**
         * <code>UNKNOWN = 0;</code>
         */
        public static final int UNKNOWN_VALUE = 0;
        /**
         * <pre>
         * CONTROLLER_SERVICE indicates that the Plugin provides RPCs for
         * the ControllerService. Plugins SHOULD provide this capability.
         * In rare cases certain plugins may wish to omit the
         * ControllerService entirely from their implementation, but such
         * SHOULD NOT be the common case.
         * The presence of this capability determines whether the CO will
         * attempt to invoke the REQUIRED ControllerService RPCs, as well
         * as specific RPCs as indicated by ControllerGetCapabilities.
         * </pre>
         *
         * <code>CONTROLLER_SERVICE = 1;</code>
         */
        public static final int CONTROLLER_SERVICE_VALUE = 1;
        /**
         * <pre>
         * ACCESSIBILITY_CONSTRAINTS indicates that the volumes for this
         * plugin may not be equally accessible by all nodes in the
         * cluster. The CO MUST use the topology information returned by
         * CreateVolumeRequest along with the topology information
         * returned by NodeGetInfo to ensure that a given volume is
         * accessible from a given node when scheduling workloads.
         * </pre>
         *
         * <code>ACCESSIBILITY_CONSTRAINTS = 2;</code>
         */
        public static final int ACCESSIBILITY_CONSTRAINTS_VALUE = 2;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static Type valueOf(int value) {
          return forNumber(value);
        }

        public static Type forNumber(int value) {
          switch (value) {
            case 0: return UNKNOWN;
            case 1: return CONTROLLER_SERVICE;
            case 2: return ACCESSIBILITY_CONSTRAINTS;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<Type>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            Type> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Type>() {
                public Type findValueByNumber(int number) {
                  return Type.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return csi.v0.Csi.PluginCapability.Service.getDescriptor().getEnumTypes().get(0);
        }

        private static final Type[] VALUES = values();

        public static Type valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private Type(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:csi.v0.PluginCapability.Service.Type)
      }

      public static final int TYPE_FIELD_NUMBER = 1;
      private int type_;
      /**
       * <code>.csi.v0.PluginCapability.Service.Type type = 1;</code>
       */
      public int getTypeValue() {
        return type_;
      }
      /**
       * <code>.csi.v0.PluginCapability.Service.Type type = 1;</code>
       */
      public csi.v0.Csi.PluginCapability.Service.Type getType() {
        @SuppressWarnings("deprecation")
        csi.v0.Csi.PluginCapability.Service.Type result = csi.v0.Csi.PluginCapability.Service.Type.valueOf(type_);
        return result == null ? csi.v0.Csi.PluginCapability.Service.Type.UNRECOGNIZED : result;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (type_ != csi.v0.Csi.PluginCapability.Service.Type.UNKNOWN.getNumber()) {
          output.writeEnum(1, type_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (type_ != csi.v0.Csi.PluginCapability.Service.Type.UNKNOWN.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(1, type_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v0.Csi.PluginCapability.Service)) {
          return super.equals(obj);
        }
        csi.v0.Csi.PluginCapability.Service other = (csi.v0.Csi.PluginCapability.Service) obj;

        boolean result = true;
        result = result && type_ == other.type_;
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v0.Csi.PluginCapability.Service parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.PluginCapability.Service parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.PluginCapability.Service parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.PluginCapability.Service parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.PluginCapability.Service parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.PluginCapability.Service parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.PluginCapability.Service parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.PluginCapability.Service parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.PluginCapability.Service parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.PluginCapability.Service parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.PluginCapability.Service parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.PluginCapability.Service parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v0.Csi.PluginCapability.Service prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code csi.v0.PluginCapability.Service}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v0.PluginCapability.Service)
          csi.v0.Csi.PluginCapability.ServiceOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v0.Csi.internal_static_csi_v0_PluginCapability_Service_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v0.Csi.internal_static_csi_v0_PluginCapability_Service_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v0.Csi.PluginCapability.Service.class, csi.v0.Csi.PluginCapability.Service.Builder.class);
        }

        // Construct using csi.v0.Csi.PluginCapability.Service.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          type_ = 0;

          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v0.Csi.internal_static_csi_v0_PluginCapability_Service_descriptor;
        }

        @java.lang.Override
        public csi.v0.Csi.PluginCapability.Service getDefaultInstanceForType() {
          return csi.v0.Csi.PluginCapability.Service.getDefaultInstance();
        }

        @java.lang.Override
        public csi.v0.Csi.PluginCapability.Service build() {
          csi.v0.Csi.PluginCapability.Service result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public csi.v0.Csi.PluginCapability.Service buildPartial() {
          csi.v0.Csi.PluginCapability.Service result = new csi.v0.Csi.PluginCapability.Service(this);
          result.type_ = type_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return (Builder) super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v0.Csi.PluginCapability.Service) {
            return mergeFrom((csi.v0.Csi.PluginCapability.Service)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v0.Csi.PluginCapability.Service other) {
          if (other == csi.v0.Csi.PluginCapability.Service.getDefaultInstance()) return this;
          if (other.type_ != 0) {
            setTypeValue(other.getTypeValue());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v0.Csi.PluginCapability.Service parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v0.Csi.PluginCapability.Service) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private int type_ = 0;
        /**
         * <code>.csi.v0.PluginCapability.Service.Type type = 1;</code>
         */
        public int getTypeValue() {
          return type_;
        }
        /**
         * <code>.csi.v0.PluginCapability.Service.Type type = 1;</code>
         */
        public Builder setTypeValue(int value) {
          type_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>.csi.v0.PluginCapability.Service.Type type = 1;</code>
         */
        public csi.v0.Csi.PluginCapability.Service.Type getType() {
          @SuppressWarnings("deprecation")
          csi.v0.Csi.PluginCapability.Service.Type result = csi.v0.Csi.PluginCapability.Service.Type.valueOf(type_);
          return result == null ? csi.v0.Csi.PluginCapability.Service.Type.UNRECOGNIZED : result;
        }
        /**
         * <code>.csi.v0.PluginCapability.Service.Type type = 1;</code>
         */
        public Builder setType(csi.v0.Csi.PluginCapability.Service.Type value) {
          if (value == null) {
            throw new NullPointerException();
          }
          
          type_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <code>.csi.v0.PluginCapability.Service.Type type = 1;</code>
         */
        public Builder clearType() {
          
          type_ = 0;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v0.PluginCapability.Service)
      }

      // @@protoc_insertion_point(class_scope:csi.v0.PluginCapability.Service)
      private static final csi.v0.Csi.PluginCapability.Service DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v0.Csi.PluginCapability.Service();
      }

      public static csi.v0.Csi.PluginCapability.Service getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Service>
          PARSER = new com.google.protobuf.AbstractParser<Service>() {
        @java.lang.Override
        public Service parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new Service(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<Service> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Service> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public csi.v0.Csi.PluginCapability.Service getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int typeCase_ = 0;
    private java.lang.Object type_;
    public enum TypeCase
        implements com.google.protobuf.Internal.EnumLite {
      SERVICE(1),
      TYPE_NOT_SET(0);
      private final int value;
      private TypeCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TypeCase valueOf(int value) {
        return forNumber(value);
      }

      public static TypeCase forNumber(int value) {
        switch (value) {
          case 1: return SERVICE;
          case 0: return TYPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public TypeCase
    getTypeCase() {
      return TypeCase.forNumber(
          typeCase_);
    }

    public static final int SERVICE_FIELD_NUMBER = 1;
    /**
     * <pre>
     * Service that the plugin supports.
     * </pre>
     *
     * <code>.csi.v0.PluginCapability.Service service = 1;</code>
     */
    public boolean hasService() {
      return typeCase_ == 1;
    }
    /**
     * <pre>
     * Service that the plugin supports.
     * </pre>
     *
     * <code>.csi.v0.PluginCapability.Service service = 1;</code>
     */
    public csi.v0.Csi.PluginCapability.Service getService() {
      if (typeCase_ == 1) {
         return (csi.v0.Csi.PluginCapability.Service) type_;
      }
      return csi.v0.Csi.PluginCapability.Service.getDefaultInstance();
    }
    /**
     * <pre>
     * Service that the plugin supports.
     * </pre>
     *
     * <code>.csi.v0.PluginCapability.Service service = 1;</code>
     */
    public csi.v0.Csi.PluginCapability.ServiceOrBuilder getServiceOrBuilder() {
      if (typeCase_ == 1) {
         return (csi.v0.Csi.PluginCapability.Service) type_;
      }
      return csi.v0.Csi.PluginCapability.Service.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (typeCase_ == 1) {
        output.writeMessage(1, (csi.v0.Csi.PluginCapability.Service) type_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (typeCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, (csi.v0.Csi.PluginCapability.Service) type_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.PluginCapability)) {
        return super.equals(obj);
      }
      csi.v0.Csi.PluginCapability other = (csi.v0.Csi.PluginCapability) obj;

      boolean result = true;
      result = result && getTypeCase().equals(
          other.getTypeCase());
      if (!result) return false;
      switch (typeCase_) {
        case 1:
          result = result && getService()
              .equals(other.getService());
          break;
        case 0:
        default:
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      switch (typeCase_) {
        case 1:
          hash = (37 * hash) + SERVICE_FIELD_NUMBER;
          hash = (53 * hash) + getService().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.PluginCapability parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.PluginCapability parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.PluginCapability parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.PluginCapability parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.PluginCapability parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.PluginCapability parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.PluginCapability parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.PluginCapability parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.PluginCapability parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.PluginCapability parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.PluginCapability parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.PluginCapability parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.PluginCapability prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specifies a capability of the plugin.
     * </pre>
     *
     * Protobuf type {@code csi.v0.PluginCapability}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.PluginCapability)
        csi.v0.Csi.PluginCapabilityOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_PluginCapability_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_PluginCapability_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.PluginCapability.class, csi.v0.Csi.PluginCapability.Builder.class);
      }

      // Construct using csi.v0.Csi.PluginCapability.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        typeCase_ = 0;
        type_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_PluginCapability_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.PluginCapability getDefaultInstanceForType() {
        return csi.v0.Csi.PluginCapability.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.PluginCapability build() {
        csi.v0.Csi.PluginCapability result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.PluginCapability buildPartial() {
        csi.v0.Csi.PluginCapability result = new csi.v0.Csi.PluginCapability(this);
        if (typeCase_ == 1) {
          if (serviceBuilder_ == null) {
            result.type_ = type_;
          } else {
            result.type_ = serviceBuilder_.build();
          }
        }
        result.typeCase_ = typeCase_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.PluginCapability) {
          return mergeFrom((csi.v0.Csi.PluginCapability)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.PluginCapability other) {
        if (other == csi.v0.Csi.PluginCapability.getDefaultInstance()) return this;
        switch (other.getTypeCase()) {
          case SERVICE: {
            mergeService(other.getService());
            break;
          }
          case TYPE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.PluginCapability parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.PluginCapability) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int typeCase_ = 0;
      private java.lang.Object type_;
      public TypeCase
          getTypeCase() {
        return TypeCase.forNumber(
            typeCase_);
      }

      public Builder clearType() {
        typeCase_ = 0;
        type_ = null;
        onChanged();
        return this;
      }


      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.PluginCapability.Service, csi.v0.Csi.PluginCapability.Service.Builder, csi.v0.Csi.PluginCapability.ServiceOrBuilder> serviceBuilder_;
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v0.PluginCapability.Service service = 1;</code>
       */
      public boolean hasService() {
        return typeCase_ == 1;
      }
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v0.PluginCapability.Service service = 1;</code>
       */
      public csi.v0.Csi.PluginCapability.Service getService() {
        if (serviceBuilder_ == null) {
          if (typeCase_ == 1) {
            return (csi.v0.Csi.PluginCapability.Service) type_;
          }
          return csi.v0.Csi.PluginCapability.Service.getDefaultInstance();
        } else {
          if (typeCase_ == 1) {
            return serviceBuilder_.getMessage();
          }
          return csi.v0.Csi.PluginCapability.Service.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v0.PluginCapability.Service service = 1;</code>
       */
      public Builder setService(csi.v0.Csi.PluginCapability.Service value) {
        if (serviceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          type_ = value;
          onChanged();
        } else {
          serviceBuilder_.setMessage(value);
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v0.PluginCapability.Service service = 1;</code>
       */
      public Builder setService(
          csi.v0.Csi.PluginCapability.Service.Builder builderForValue) {
        if (serviceBuilder_ == null) {
          type_ = builderForValue.build();
          onChanged();
        } else {
          serviceBuilder_.setMessage(builderForValue.build());
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v0.PluginCapability.Service service = 1;</code>
       */
      public Builder mergeService(csi.v0.Csi.PluginCapability.Service value) {
        if (serviceBuilder_ == null) {
          if (typeCase_ == 1 &&
              type_ != csi.v0.Csi.PluginCapability.Service.getDefaultInstance()) {
            type_ = csi.v0.Csi.PluginCapability.Service.newBuilder((csi.v0.Csi.PluginCapability.Service) type_)
                .mergeFrom(value).buildPartial();
          } else {
            type_ = value;
          }
          onChanged();
        } else {
          if (typeCase_ == 1) {
            serviceBuilder_.mergeFrom(value);
          }
          serviceBuilder_.setMessage(value);
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v0.PluginCapability.Service service = 1;</code>
       */
      public Builder clearService() {
        if (serviceBuilder_ == null) {
          if (typeCase_ == 1) {
            typeCase_ = 0;
            type_ = null;
            onChanged();
          }
        } else {
          if (typeCase_ == 1) {
            typeCase_ = 0;
            type_ = null;
          }
          serviceBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v0.PluginCapability.Service service = 1;</code>
       */
      public csi.v0.Csi.PluginCapability.Service.Builder getServiceBuilder() {
        return getServiceFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v0.PluginCapability.Service service = 1;</code>
       */
      public csi.v0.Csi.PluginCapability.ServiceOrBuilder getServiceOrBuilder() {
        if ((typeCase_ == 1) && (serviceBuilder_ != null)) {
          return serviceBuilder_.getMessageOrBuilder();
        } else {
          if (typeCase_ == 1) {
            return (csi.v0.Csi.PluginCapability.Service) type_;
          }
          return csi.v0.Csi.PluginCapability.Service.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * Service that the plugin supports.
       * </pre>
       *
       * <code>.csi.v0.PluginCapability.Service service = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.PluginCapability.Service, csi.v0.Csi.PluginCapability.Service.Builder, csi.v0.Csi.PluginCapability.ServiceOrBuilder> 
          getServiceFieldBuilder() {
        if (serviceBuilder_ == null) {
          if (!(typeCase_ == 1)) {
            type_ = csi.v0.Csi.PluginCapability.Service.getDefaultInstance();
          }
          serviceBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.PluginCapability.Service, csi.v0.Csi.PluginCapability.Service.Builder, csi.v0.Csi.PluginCapability.ServiceOrBuilder>(
                  (csi.v0.Csi.PluginCapability.Service) type_,
                  getParentForChildren(),
                  isClean());
          type_ = null;
        }
        typeCase_ = 1;
        onChanged();;
        return serviceBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.PluginCapability)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.PluginCapability)
    private static final csi.v0.Csi.PluginCapability DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.PluginCapability();
    }

    public static csi.v0.Csi.PluginCapability getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PluginCapability>
        PARSER = new com.google.protobuf.AbstractParser<PluginCapability>() {
      @java.lang.Override
      public PluginCapability parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PluginCapability(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PluginCapability> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PluginCapability> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.PluginCapability getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ProbeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.ProbeRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v0.ProbeRequest}
   */
  public  static final class ProbeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.ProbeRequest)
      ProbeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ProbeRequest.newBuilder() to construct.
    private ProbeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ProbeRequest() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ProbeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_ProbeRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_ProbeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.ProbeRequest.class, csi.v0.Csi.ProbeRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.ProbeRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.ProbeRequest other = (csi.v0.Csi.ProbeRequest) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.ProbeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ProbeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ProbeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ProbeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ProbeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ProbeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ProbeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ProbeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ProbeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ProbeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ProbeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ProbeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.ProbeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v0.ProbeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.ProbeRequest)
        csi.v0.Csi.ProbeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ProbeRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ProbeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ProbeRequest.class, csi.v0.Csi.ProbeRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.ProbeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_ProbeRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.ProbeRequest getDefaultInstanceForType() {
        return csi.v0.Csi.ProbeRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.ProbeRequest build() {
        csi.v0.Csi.ProbeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.ProbeRequest buildPartial() {
        csi.v0.Csi.ProbeRequest result = new csi.v0.Csi.ProbeRequest(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.ProbeRequest) {
          return mergeFrom((csi.v0.Csi.ProbeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.ProbeRequest other) {
        if (other == csi.v0.Csi.ProbeRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.ProbeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.ProbeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.ProbeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.ProbeRequest)
    private static final csi.v0.Csi.ProbeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.ProbeRequest();
    }

    public static csi.v0.Csi.ProbeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ProbeRequest>
        PARSER = new com.google.protobuf.AbstractParser<ProbeRequest>() {
      @java.lang.Override
      public ProbeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ProbeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ProbeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ProbeRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.ProbeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ProbeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.ProbeResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Readiness allows a plugin to report its initialization status back
     * to the CO. Initialization for some plugins MAY be time consuming
     * and it is important for a CO to distinguish between the following
     * cases:
     * 1) The plugin is in an unhealthy state and MAY need restarting. In
     *    this case a gRPC error code SHALL be returned.
     * 2) The plugin is still initializing, but is otherwise perfectly
     *    healthy. In this case a successful response SHALL be returned
     *    with a readiness value of `false`. Calls to the plugin's
     *    Controller and/or Node services MAY fail due to an incomplete
     *    initialization state.
     * 3) The plugin has finished initializing and is ready to service
     *    calls to its Controller and/or Node services. A successful
     *    response is returned with a readiness value of `true`.
     * This field is OPTIONAL. If not present, the caller SHALL assume
     * that the plugin is in a ready state and is accepting calls to its
     * Controller and/or Node services (according to the plugin's reported
     * capabilities).
     * </pre>
     *
     * <code>.google.protobuf.BoolValue ready = 1;</code>
     */
    boolean hasReady();
    /**
     * <pre>
     * Readiness allows a plugin to report its initialization status back
     * to the CO. Initialization for some plugins MAY be time consuming
     * and it is important for a CO to distinguish between the following
     * cases:
     * 1) The plugin is in an unhealthy state and MAY need restarting. In
     *    this case a gRPC error code SHALL be returned.
     * 2) The plugin is still initializing, but is otherwise perfectly
     *    healthy. In this case a successful response SHALL be returned
     *    with a readiness value of `false`. Calls to the plugin's
     *    Controller and/or Node services MAY fail due to an incomplete
     *    initialization state.
     * 3) The plugin has finished initializing and is ready to service
     *    calls to its Controller and/or Node services. A successful
     *    response is returned with a readiness value of `true`.
     * This field is OPTIONAL. If not present, the caller SHALL assume
     * that the plugin is in a ready state and is accepting calls to its
     * Controller and/or Node services (according to the plugin's reported
     * capabilities).
     * </pre>
     *
     * <code>.google.protobuf.BoolValue ready = 1;</code>
     */
    com.google.protobuf.BoolValue getReady();
    /**
     * <pre>
     * Readiness allows a plugin to report its initialization status back
     * to the CO. Initialization for some plugins MAY be time consuming
     * and it is important for a CO to distinguish between the following
     * cases:
     * 1) The plugin is in an unhealthy state and MAY need restarting. In
     *    this case a gRPC error code SHALL be returned.
     * 2) The plugin is still initializing, but is otherwise perfectly
     *    healthy. In this case a successful response SHALL be returned
     *    with a readiness value of `false`. Calls to the plugin's
     *    Controller and/or Node services MAY fail due to an incomplete
     *    initialization state.
     * 3) The plugin has finished initializing and is ready to service
     *    calls to its Controller and/or Node services. A successful
     *    response is returned with a readiness value of `true`.
     * This field is OPTIONAL. If not present, the caller SHALL assume
     * that the plugin is in a ready state and is accepting calls to its
     * Controller and/or Node services (according to the plugin's reported
     * capabilities).
     * </pre>
     *
     * <code>.google.protobuf.BoolValue ready = 1;</code>
     */
    com.google.protobuf.BoolValueOrBuilder getReadyOrBuilder();
  }
  /**
   * Protobuf type {@code csi.v0.ProbeResponse}
   */
  public  static final class ProbeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.ProbeResponse)
      ProbeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ProbeResponse.newBuilder() to construct.
    private ProbeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ProbeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ProbeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              com.google.protobuf.BoolValue.Builder subBuilder = null;
              if (ready_ != null) {
                subBuilder = ready_.toBuilder();
              }
              ready_ = input.readMessage(com.google.protobuf.BoolValue.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(ready_);
                ready_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_ProbeResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_ProbeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.ProbeResponse.class, csi.v0.Csi.ProbeResponse.Builder.class);
    }

    public static final int READY_FIELD_NUMBER = 1;
    private com.google.protobuf.BoolValue ready_;
    /**
     * <pre>
     * Readiness allows a plugin to report its initialization status back
     * to the CO. Initialization for some plugins MAY be time consuming
     * and it is important for a CO to distinguish between the following
     * cases:
     * 1) The plugin is in an unhealthy state and MAY need restarting. In
     *    this case a gRPC error code SHALL be returned.
     * 2) The plugin is still initializing, but is otherwise perfectly
     *    healthy. In this case a successful response SHALL be returned
     *    with a readiness value of `false`. Calls to the plugin's
     *    Controller and/or Node services MAY fail due to an incomplete
     *    initialization state.
     * 3) The plugin has finished initializing and is ready to service
     *    calls to its Controller and/or Node services. A successful
     *    response is returned with a readiness value of `true`.
     * This field is OPTIONAL. If not present, the caller SHALL assume
     * that the plugin is in a ready state and is accepting calls to its
     * Controller and/or Node services (according to the plugin's reported
     * capabilities).
     * </pre>
     *
     * <code>.google.protobuf.BoolValue ready = 1;</code>
     */
    public boolean hasReady() {
      return ready_ != null;
    }
    /**
     * <pre>
     * Readiness allows a plugin to report its initialization status back
     * to the CO. Initialization for some plugins MAY be time consuming
     * and it is important for a CO to distinguish between the following
     * cases:
     * 1) The plugin is in an unhealthy state and MAY need restarting. In
     *    this case a gRPC error code SHALL be returned.
     * 2) The plugin is still initializing, but is otherwise perfectly
     *    healthy. In this case a successful response SHALL be returned
     *    with a readiness value of `false`. Calls to the plugin's
     *    Controller and/or Node services MAY fail due to an incomplete
     *    initialization state.
     * 3) The plugin has finished initializing and is ready to service
     *    calls to its Controller and/or Node services. A successful
     *    response is returned with a readiness value of `true`.
     * This field is OPTIONAL. If not present, the caller SHALL assume
     * that the plugin is in a ready state and is accepting calls to its
     * Controller and/or Node services (according to the plugin's reported
     * capabilities).
     * </pre>
     *
     * <code>.google.protobuf.BoolValue ready = 1;</code>
     */
    public com.google.protobuf.BoolValue getReady() {
      return ready_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : ready_;
    }
    /**
     * <pre>
     * Readiness allows a plugin to report its initialization status back
     * to the CO. Initialization for some plugins MAY be time consuming
     * and it is important for a CO to distinguish between the following
     * cases:
     * 1) The plugin is in an unhealthy state and MAY need restarting. In
     *    this case a gRPC error code SHALL be returned.
     * 2) The plugin is still initializing, but is otherwise perfectly
     *    healthy. In this case a successful response SHALL be returned
     *    with a readiness value of `false`. Calls to the plugin's
     *    Controller and/or Node services MAY fail due to an incomplete
     *    initialization state.
     * 3) The plugin has finished initializing and is ready to service
     *    calls to its Controller and/or Node services. A successful
     *    response is returned with a readiness value of `true`.
     * This field is OPTIONAL. If not present, the caller SHALL assume
     * that the plugin is in a ready state and is accepting calls to its
     * Controller and/or Node services (according to the plugin's reported
     * capabilities).
     * </pre>
     *
     * <code>.google.protobuf.BoolValue ready = 1;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getReadyOrBuilder() {
      return getReady();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (ready_ != null) {
        output.writeMessage(1, getReady());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (ready_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getReady());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.ProbeResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.ProbeResponse other = (csi.v0.Csi.ProbeResponse) obj;

      boolean result = true;
      result = result && (hasReady() == other.hasReady());
      if (hasReady()) {
        result = result && getReady()
            .equals(other.getReady());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasReady()) {
        hash = (37 * hash) + READY_FIELD_NUMBER;
        hash = (53 * hash) + getReady().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.ProbeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ProbeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ProbeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ProbeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ProbeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ProbeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ProbeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ProbeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ProbeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ProbeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ProbeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ProbeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.ProbeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.ProbeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.ProbeResponse)
        csi.v0.Csi.ProbeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ProbeResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ProbeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ProbeResponse.class, csi.v0.Csi.ProbeResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.ProbeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (readyBuilder_ == null) {
          ready_ = null;
        } else {
          ready_ = null;
          readyBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_ProbeResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.ProbeResponse getDefaultInstanceForType() {
        return csi.v0.Csi.ProbeResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.ProbeResponse build() {
        csi.v0.Csi.ProbeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.ProbeResponse buildPartial() {
        csi.v0.Csi.ProbeResponse result = new csi.v0.Csi.ProbeResponse(this);
        if (readyBuilder_ == null) {
          result.ready_ = ready_;
        } else {
          result.ready_ = readyBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.ProbeResponse) {
          return mergeFrom((csi.v0.Csi.ProbeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.ProbeResponse other) {
        if (other == csi.v0.Csi.ProbeResponse.getDefaultInstance()) return this;
        if (other.hasReady()) {
          mergeReady(other.getReady());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.ProbeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.ProbeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.google.protobuf.BoolValue ready_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> readyBuilder_;
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      public boolean hasReady() {
        return readyBuilder_ != null || ready_ != null;
      }
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      public com.google.protobuf.BoolValue getReady() {
        if (readyBuilder_ == null) {
          return ready_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : ready_;
        } else {
          return readyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      public Builder setReady(com.google.protobuf.BoolValue value) {
        if (readyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ready_ = value;
          onChanged();
        } else {
          readyBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      public Builder setReady(
          com.google.protobuf.BoolValue.Builder builderForValue) {
        if (readyBuilder_ == null) {
          ready_ = builderForValue.build();
          onChanged();
        } else {
          readyBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      public Builder mergeReady(com.google.protobuf.BoolValue value) {
        if (readyBuilder_ == null) {
          if (ready_ != null) {
            ready_ =
              com.google.protobuf.BoolValue.newBuilder(ready_).mergeFrom(value).buildPartial();
          } else {
            ready_ = value;
          }
          onChanged();
        } else {
          readyBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      public Builder clearReady() {
        if (readyBuilder_ == null) {
          ready_ = null;
          onChanged();
        } else {
          ready_ = null;
          readyBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      public com.google.protobuf.BoolValue.Builder getReadyBuilder() {
        
        onChanged();
        return getReadyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      public com.google.protobuf.BoolValueOrBuilder getReadyOrBuilder() {
        if (readyBuilder_ != null) {
          return readyBuilder_.getMessageOrBuilder();
        } else {
          return ready_ == null ?
              com.google.protobuf.BoolValue.getDefaultInstance() : ready_;
        }
      }
      /**
       * <pre>
       * Readiness allows a plugin to report its initialization status back
       * to the CO. Initialization for some plugins MAY be time consuming
       * and it is important for a CO to distinguish between the following
       * cases:
       * 1) The plugin is in an unhealthy state and MAY need restarting. In
       *    this case a gRPC error code SHALL be returned.
       * 2) The plugin is still initializing, but is otherwise perfectly
       *    healthy. In this case a successful response SHALL be returned
       *    with a readiness value of `false`. Calls to the plugin's
       *    Controller and/or Node services MAY fail due to an incomplete
       *    initialization state.
       * 3) The plugin has finished initializing and is ready to service
       *    calls to its Controller and/or Node services. A successful
       *    response is returned with a readiness value of `true`.
       * This field is OPTIONAL. If not present, the caller SHALL assume
       * that the plugin is in a ready state and is accepting calls to its
       * Controller and/or Node services (according to the plugin's reported
       * capabilities).
       * </pre>
       *
       * <code>.google.protobuf.BoolValue ready = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
          getReadyFieldBuilder() {
        if (readyBuilder_ == null) {
          readyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                  getReady(),
                  getParentForChildren(),
                  isClean());
          ready_ = null;
        }
        return readyBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.ProbeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.ProbeResponse)
    private static final csi.v0.Csi.ProbeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.ProbeResponse();
    }

    public static csi.v0.Csi.ProbeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ProbeResponse>
        PARSER = new com.google.protobuf.AbstractParser<ProbeResponse>() {
      @java.lang.Override
      public ProbeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ProbeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ProbeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ProbeResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.ProbeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CreateVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.CreateVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The suggested name for the storage space. This field is REQUIRED.
     * It serves two purposes:
     * 1) Idempotency - This name is generated by the CO to achieve
     *    idempotency. If `CreateVolume` fails, the volume may or may not
     *    be provisioned. In this case, the CO may call `CreateVolume`
     *    again, with the same name, to ensure the volume exists. The
     *    Plugin should ensure that multiple `CreateVolume` calls for the
     *    same name do not result in more than one piece of storage
     *    provisioned corresponding to that name. If a Plugin is unable to
     *    enforce idempotency, the CO's error recovery logic could result
     *    in multiple (unused) volumes being provisioned.
     * 2) Suggested name - Some storage systems allow callers to specify
     *    an identifier by which to refer to the newly provisioned
     *    storage. If a storage system supports this, it can optionally
     *    use this name as the identifier for the new volume.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * The suggested name for the storage space. This field is REQUIRED.
     * It serves two purposes:
     * 1) Idempotency - This name is generated by the CO to achieve
     *    idempotency. If `CreateVolume` fails, the volume may or may not
     *    be provisioned. In this case, the CO may call `CreateVolume`
     *    again, with the same name, to ensure the volume exists. The
     *    Plugin should ensure that multiple `CreateVolume` calls for the
     *    same name do not result in more than one piece of storage
     *    provisioned corresponding to that name. If a Plugin is unable to
     *    enforce idempotency, the CO's error recovery logic could result
     *    in multiple (unused) volumes being provisioned.
     * 2) Suggested name - Some storage systems allow callers to specify
     *    an identifier by which to refer to the newly provisioned
     *    storage. If a storage system supports this, it can optionally
     *    use this name as the identifier for the new volume.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <code>.csi.v0.CapacityRange capacity_range = 2;</code>
     */
    boolean hasCapacityRange();
    /**
     * <code>.csi.v0.CapacityRange capacity_range = 2;</code>
     */
    csi.v0.Csi.CapacityRange getCapacityRange();
    /**
     * <code>.csi.v0.CapacityRange capacity_range = 2;</code>
     */
    csi.v0.Csi.CapacityRangeOrBuilder getCapacityRangeOrBuilder();

    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have: the Plugin
     * MUST provision a volume that could satisfy ALL of the
     * capabilities specified in this list. The Plugin MUST assume that
     * the CO MAY use the  provisioned volume later with ANY of the
     * capabilities specified in this list. This also enables the CO to do
     * early validation: if ANY of the specified volume capabilities are
     * not supported by the Plugin, the call SHALL fail. This field is
     * REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
     */
    java.util.List<csi.v0.Csi.VolumeCapability> 
        getVolumeCapabilitiesList();
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have: the Plugin
     * MUST provision a volume that could satisfy ALL of the
     * capabilities specified in this list. The Plugin MUST assume that
     * the CO MAY use the  provisioned volume later with ANY of the
     * capabilities specified in this list. This also enables the CO to do
     * early validation: if ANY of the specified volume capabilities are
     * not supported by the Plugin, the call SHALL fail. This field is
     * REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
     */
    csi.v0.Csi.VolumeCapability getVolumeCapabilities(int index);
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have: the Plugin
     * MUST provision a volume that could satisfy ALL of the
     * capabilities specified in this list. The Plugin MUST assume that
     * the CO MAY use the  provisioned volume later with ANY of the
     * capabilities specified in this list. This also enables the CO to do
     * early validation: if ANY of the specified volume capabilities are
     * not supported by the Plugin, the call SHALL fail. This field is
     * REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
     */
    int getVolumeCapabilitiesCount();
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have: the Plugin
     * MUST provision a volume that could satisfy ALL of the
     * capabilities specified in this list. The Plugin MUST assume that
     * the CO MAY use the  provisioned volume later with ANY of the
     * capabilities specified in this list. This also enables the CO to do
     * early validation: if ANY of the specified volume capabilities are
     * not supported by the Plugin, the call SHALL fail. This field is
     * REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
     */
    java.util.List<? extends csi.v0.Csi.VolumeCapabilityOrBuilder> 
        getVolumeCapabilitiesOrBuilderList();
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have: the Plugin
     * MUST provision a volume that could satisfy ALL of the
     * capabilities specified in this list. The Plugin MUST assume that
     * the CO MAY use the  provisioned volume later with ANY of the
     * capabilities specified in this list. This also enables the CO to do
     * early validation: if ANY of the specified volume capabilities are
     * not supported by the Plugin, the call SHALL fail. This field is
     * REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
     */
    csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
        int index);

    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */
    int getParametersCount();
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */
    boolean containsParameters(
        java.lang.String key);
    /**
     * Use {@link #getParametersMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getParameters();
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getParametersMap();
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    java.lang.String getParametersOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    java.lang.String getParametersOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_create_secrets = 5;</code>
     */
    int getControllerCreateSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_create_secrets = 5;</code>
     */
    boolean containsControllerCreateSecrets(
        java.lang.String key);
    /**
     * Use {@link #getControllerCreateSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getControllerCreateSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_create_secrets = 5;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getControllerCreateSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_create_secrets = 5;</code>
     */

    java.lang.String getControllerCreateSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_create_secrets = 5;</code>
     */

    java.lang.String getControllerCreateSecretsOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * If specified, the new volume will be pre-populated with data from
     * this source. This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v0.VolumeContentSource volume_content_source = 6;</code>
     */
    boolean hasVolumeContentSource();
    /**
     * <pre>
     * If specified, the new volume will be pre-populated with data from
     * this source. This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v0.VolumeContentSource volume_content_source = 6;</code>
     */
    csi.v0.Csi.VolumeContentSource getVolumeContentSource();
    /**
     * <pre>
     * If specified, the new volume will be pre-populated with data from
     * this source. This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v0.VolumeContentSource volume_content_source = 6;</code>
     */
    csi.v0.Csi.VolumeContentSourceOrBuilder getVolumeContentSourceOrBuilder();

    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume MUST be accessible from.
     * An SP SHALL advertise the requirements for topological
     * accessibility information in documentation. COs SHALL only specify
     * topological accessibility information supported by the SP.
     * This field is OPTIONAL.
     * This field SHALL NOT be specified unless the SP has the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * If this field is not specified and the SP has the
     * ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY choose
     * where the provisioned volume is accessible from.
     * </pre>
     *
     * <code>.csi.v0.TopologyRequirement accessibility_requirements = 7;</code>
     */
    boolean hasAccessibilityRequirements();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume MUST be accessible from.
     * An SP SHALL advertise the requirements for topological
     * accessibility information in documentation. COs SHALL only specify
     * topological accessibility information supported by the SP.
     * This field is OPTIONAL.
     * This field SHALL NOT be specified unless the SP has the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * If this field is not specified and the SP has the
     * ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY choose
     * where the provisioned volume is accessible from.
     * </pre>
     *
     * <code>.csi.v0.TopologyRequirement accessibility_requirements = 7;</code>
     */
    csi.v0.Csi.TopologyRequirement getAccessibilityRequirements();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume MUST be accessible from.
     * An SP SHALL advertise the requirements for topological
     * accessibility information in documentation. COs SHALL only specify
     * topological accessibility information supported by the SP.
     * This field is OPTIONAL.
     * This field SHALL NOT be specified unless the SP has the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * If this field is not specified and the SP has the
     * ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY choose
     * where the provisioned volume is accessible from.
     * </pre>
     *
     * <code>.csi.v0.TopologyRequirement accessibility_requirements = 7;</code>
     */
    csi.v0.Csi.TopologyRequirementOrBuilder getAccessibilityRequirementsOrBuilder();
  }
  /**
   * Protobuf type {@code csi.v0.CreateVolumeRequest}
   */
  public  static final class CreateVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.CreateVolumeRequest)
      CreateVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CreateVolumeRequest.newBuilder() to construct.
    private CreateVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CreateVolumeRequest() {
      name_ = "";
      volumeCapabilities_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CreateVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 18: {
              csi.v0.Csi.CapacityRange.Builder subBuilder = null;
              if (capacityRange_ != null) {
                subBuilder = capacityRange_.toBuilder();
              }
              capacityRange_ = input.readMessage(csi.v0.Csi.CapacityRange.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(capacityRange_);
                capacityRange_ = subBuilder.buildPartial();
              }

              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                volumeCapabilities_ = new java.util.ArrayList<csi.v0.Csi.VolumeCapability>();
                mutable_bitField0_ |= 0x00000004;
              }
              volumeCapabilities_.add(
                  input.readMessage(csi.v0.Csi.VolumeCapability.parser(), extensionRegistry));
              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                parameters_ = com.google.protobuf.MapField.newMapField(
                    ParametersDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000008;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              parameters__ = input.readMessage(
                  ParametersDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              parameters_.getMutableMap().put(
                  parameters__.getKey(), parameters__.getValue());
              break;
            }
            case 42: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                controllerCreateSecrets_ = com.google.protobuf.MapField.newMapField(
                    ControllerCreateSecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000010;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              controllerCreateSecrets__ = input.readMessage(
                  ControllerCreateSecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              controllerCreateSecrets_.getMutableMap().put(
                  controllerCreateSecrets__.getKey(), controllerCreateSecrets__.getValue());
              break;
            }
            case 50: {
              csi.v0.Csi.VolumeContentSource.Builder subBuilder = null;
              if (volumeContentSource_ != null) {
                subBuilder = volumeContentSource_.toBuilder();
              }
              volumeContentSource_ = input.readMessage(csi.v0.Csi.VolumeContentSource.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(volumeContentSource_);
                volumeContentSource_ = subBuilder.buildPartial();
              }

              break;
            }
            case 58: {
              csi.v0.Csi.TopologyRequirement.Builder subBuilder = null;
              if (accessibilityRequirements_ != null) {
                subBuilder = accessibilityRequirements_.toBuilder();
              }
              accessibilityRequirements_ = input.readMessage(csi.v0.Csi.TopologyRequirement.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(accessibilityRequirements_);
                accessibilityRequirements_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          volumeCapabilities_ = java.util.Collections.unmodifiableList(volumeCapabilities_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_CreateVolumeRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 4:
          return internalGetParameters();
        case 5:
          return internalGetControllerCreateSecrets();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_CreateVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.CreateVolumeRequest.class, csi.v0.Csi.CreateVolumeRequest.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * The suggested name for the storage space. This field is REQUIRED.
     * It serves two purposes:
     * 1) Idempotency - This name is generated by the CO to achieve
     *    idempotency. If `CreateVolume` fails, the volume may or may not
     *    be provisioned. In this case, the CO may call `CreateVolume`
     *    again, with the same name, to ensure the volume exists. The
     *    Plugin should ensure that multiple `CreateVolume` calls for the
     *    same name do not result in more than one piece of storage
     *    provisioned corresponding to that name. If a Plugin is unable to
     *    enforce idempotency, the CO's error recovery logic could result
     *    in multiple (unused) volumes being provisioned.
     * 2) Suggested name - Some storage systems allow callers to specify
     *    an identifier by which to refer to the newly provisioned
     *    storage. If a storage system supports this, it can optionally
     *    use this name as the identifier for the new volume.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The suggested name for the storage space. This field is REQUIRED.
     * It serves two purposes:
     * 1) Idempotency - This name is generated by the CO to achieve
     *    idempotency. If `CreateVolume` fails, the volume may or may not
     *    be provisioned. In this case, the CO may call `CreateVolume`
     *    again, with the same name, to ensure the volume exists. The
     *    Plugin should ensure that multiple `CreateVolume` calls for the
     *    same name do not result in more than one piece of storage
     *    provisioned corresponding to that name. If a Plugin is unable to
     *    enforce idempotency, the CO's error recovery logic could result
     *    in multiple (unused) volumes being provisioned.
     * 2) Suggested name - Some storage systems allow callers to specify
     *    an identifier by which to refer to the newly provisioned
     *    storage. If a storage system supports this, it can optionally
     *    use this name as the identifier for the new volume.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CAPACITY_RANGE_FIELD_NUMBER = 2;
    private csi.v0.Csi.CapacityRange capacityRange_;
    /**
     * <code>.csi.v0.CapacityRange capacity_range = 2;</code>
     */
    public boolean hasCapacityRange() {
      return capacityRange_ != null;
    }
    /**
     * <code>.csi.v0.CapacityRange capacity_range = 2;</code>
     */
    public csi.v0.Csi.CapacityRange getCapacityRange() {
      return capacityRange_ == null ? csi.v0.Csi.CapacityRange.getDefaultInstance() : capacityRange_;
    }
    /**
     * <code>.csi.v0.CapacityRange capacity_range = 2;</code>
     */
    public csi.v0.Csi.CapacityRangeOrBuilder getCapacityRangeOrBuilder() {
      return getCapacityRange();
    }

    public static final int VOLUME_CAPABILITIES_FIELD_NUMBER = 3;
    private java.util.List<csi.v0.Csi.VolumeCapability> volumeCapabilities_;
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have: the Plugin
     * MUST provision a volume that could satisfy ALL of the
     * capabilities specified in this list. The Plugin MUST assume that
     * the CO MAY use the  provisioned volume later with ANY of the
     * capabilities specified in this list. This also enables the CO to do
     * early validation: if ANY of the specified volume capabilities are
     * not supported by the Plugin, the call SHALL fail. This field is
     * REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
     */
    public java.util.List<csi.v0.Csi.VolumeCapability> getVolumeCapabilitiesList() {
      return volumeCapabilities_;
    }
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have: the Plugin
     * MUST provision a volume that could satisfy ALL of the
     * capabilities specified in this list. The Plugin MUST assume that
     * the CO MAY use the  provisioned volume later with ANY of the
     * capabilities specified in this list. This also enables the CO to do
     * early validation: if ANY of the specified volume capabilities are
     * not supported by the Plugin, the call SHALL fail. This field is
     * REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
     */
    public java.util.List<? extends csi.v0.Csi.VolumeCapabilityOrBuilder> 
        getVolumeCapabilitiesOrBuilderList() {
      return volumeCapabilities_;
    }
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have: the Plugin
     * MUST provision a volume that could satisfy ALL of the
     * capabilities specified in this list. The Plugin MUST assume that
     * the CO MAY use the  provisioned volume later with ANY of the
     * capabilities specified in this list. This also enables the CO to do
     * early validation: if ANY of the specified volume capabilities are
     * not supported by the Plugin, the call SHALL fail. This field is
     * REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
     */
    public int getVolumeCapabilitiesCount() {
      return volumeCapabilities_.size();
    }
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have: the Plugin
     * MUST provision a volume that could satisfy ALL of the
     * capabilities specified in this list. The Plugin MUST assume that
     * the CO MAY use the  provisioned volume later with ANY of the
     * capabilities specified in this list. This also enables the CO to do
     * early validation: if ANY of the specified volume capabilities are
     * not supported by the Plugin, the call SHALL fail. This field is
     * REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
     */
    public csi.v0.Csi.VolumeCapability getVolumeCapabilities(int index) {
      return volumeCapabilities_.get(index);
    }
    /**
     * <pre>
     * The capabilities that the provisioned volume MUST have: the Plugin
     * MUST provision a volume that could satisfy ALL of the
     * capabilities specified in this list. The Plugin MUST assume that
     * the CO MAY use the  provisioned volume later with ANY of the
     * capabilities specified in this list. This also enables the CO to do
     * early validation: if ANY of the specified volume capabilities are
     * not supported by the Plugin, the call SHALL fail. This field is
     * REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
     */
    public csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
        int index) {
      return volumeCapabilities_.get(index);
    }

    public static final int PARAMETERS_FIELD_NUMBER = 4;
    private static final class ParametersDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_CreateVolumeRequest_ParametersEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> parameters_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetParameters() {
      if (parameters_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ParametersDefaultEntryHolder.defaultEntry);
      }
      return parameters_;
    }

    public int getParametersCount() {
      return internalGetParameters().getMap().size();
    }
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public boolean containsParameters(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetParameters().getMap().containsKey(key);
    }
    /**
     * Use {@link #getParametersMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getParameters() {
      return getParametersMap();
    }
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
      return internalGetParameters().getMap();
    }
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public java.lang.String getParametersOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetParameters().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public java.lang.String getParametersOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetParameters().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int CONTROLLER_CREATE_SECRETS_FIELD_NUMBER = 5;
    private static final class ControllerCreateSecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_CreateVolumeRequest_ControllerCreateSecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> controllerCreateSecrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetControllerCreateSecrets() {
      if (controllerCreateSecrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ControllerCreateSecretsDefaultEntryHolder.defaultEntry);
      }
      return controllerCreateSecrets_;
    }

    public int getControllerCreateSecretsCount() {
      return internalGetControllerCreateSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_create_secrets = 5;</code>
     */

    public boolean containsControllerCreateSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetControllerCreateSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getControllerCreateSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getControllerCreateSecrets() {
      return getControllerCreateSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_create_secrets = 5;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getControllerCreateSecretsMap() {
      return internalGetControllerCreateSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_create_secrets = 5;</code>
     */

    public java.lang.String getControllerCreateSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetControllerCreateSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_create_secrets = 5;</code>
     */

    public java.lang.String getControllerCreateSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetControllerCreateSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int VOLUME_CONTENT_SOURCE_FIELD_NUMBER = 6;
    private csi.v0.Csi.VolumeContentSource volumeContentSource_;
    /**
     * <pre>
     * If specified, the new volume will be pre-populated with data from
     * this source. This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v0.VolumeContentSource volume_content_source = 6;</code>
     */
    public boolean hasVolumeContentSource() {
      return volumeContentSource_ != null;
    }
    /**
     * <pre>
     * If specified, the new volume will be pre-populated with data from
     * this source. This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v0.VolumeContentSource volume_content_source = 6;</code>
     */
    public csi.v0.Csi.VolumeContentSource getVolumeContentSource() {
      return volumeContentSource_ == null ? csi.v0.Csi.VolumeContentSource.getDefaultInstance() : volumeContentSource_;
    }
    /**
     * <pre>
     * If specified, the new volume will be pre-populated with data from
     * this source. This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v0.VolumeContentSource volume_content_source = 6;</code>
     */
    public csi.v0.Csi.VolumeContentSourceOrBuilder getVolumeContentSourceOrBuilder() {
      return getVolumeContentSource();
    }

    public static final int ACCESSIBILITY_REQUIREMENTS_FIELD_NUMBER = 7;
    private csi.v0.Csi.TopologyRequirement accessibilityRequirements_;
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume MUST be accessible from.
     * An SP SHALL advertise the requirements for topological
     * accessibility information in documentation. COs SHALL only specify
     * topological accessibility information supported by the SP.
     * This field is OPTIONAL.
     * This field SHALL NOT be specified unless the SP has the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * If this field is not specified and the SP has the
     * ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY choose
     * where the provisioned volume is accessible from.
     * </pre>
     *
     * <code>.csi.v0.TopologyRequirement accessibility_requirements = 7;</code>
     */
    public boolean hasAccessibilityRequirements() {
      return accessibilityRequirements_ != null;
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume MUST be accessible from.
     * An SP SHALL advertise the requirements for topological
     * accessibility information in documentation. COs SHALL only specify
     * topological accessibility information supported by the SP.
     * This field is OPTIONAL.
     * This field SHALL NOT be specified unless the SP has the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * If this field is not specified and the SP has the
     * ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY choose
     * where the provisioned volume is accessible from.
     * </pre>
     *
     * <code>.csi.v0.TopologyRequirement accessibility_requirements = 7;</code>
     */
    public csi.v0.Csi.TopologyRequirement getAccessibilityRequirements() {
      return accessibilityRequirements_ == null ? csi.v0.Csi.TopologyRequirement.getDefaultInstance() : accessibilityRequirements_;
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume MUST be accessible from.
     * An SP SHALL advertise the requirements for topological
     * accessibility information in documentation. COs SHALL only specify
     * topological accessibility information supported by the SP.
     * This field is OPTIONAL.
     * This field SHALL NOT be specified unless the SP has the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * If this field is not specified and the SP has the
     * ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY choose
     * where the provisioned volume is accessible from.
     * </pre>
     *
     * <code>.csi.v0.TopologyRequirement accessibility_requirements = 7;</code>
     */
    public csi.v0.Csi.TopologyRequirementOrBuilder getAccessibilityRequirementsOrBuilder() {
      return getAccessibilityRequirements();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (capacityRange_ != null) {
        output.writeMessage(2, getCapacityRange());
      }
      for (int i = 0; i < volumeCapabilities_.size(); i++) {
        output.writeMessage(3, volumeCapabilities_.get(i));
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetParameters(),
          ParametersDefaultEntryHolder.defaultEntry,
          4);
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetControllerCreateSecrets(),
          ControllerCreateSecretsDefaultEntryHolder.defaultEntry,
          5);
      if (volumeContentSource_ != null) {
        output.writeMessage(6, getVolumeContentSource());
      }
      if (accessibilityRequirements_ != null) {
        output.writeMessage(7, getAccessibilityRequirements());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (capacityRange_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getCapacityRange());
      }
      for (int i = 0; i < volumeCapabilities_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, volumeCapabilities_.get(i));
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetParameters().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        parameters__ = ParametersDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(4, parameters__);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetControllerCreateSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        controllerCreateSecrets__ = ControllerCreateSecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(5, controllerCreateSecrets__);
      }
      if (volumeContentSource_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getVolumeContentSource());
      }
      if (accessibilityRequirements_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getAccessibilityRequirements());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.CreateVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.CreateVolumeRequest other = (csi.v0.Csi.CreateVolumeRequest) obj;

      boolean result = true;
      result = result && getName()
          .equals(other.getName());
      result = result && (hasCapacityRange() == other.hasCapacityRange());
      if (hasCapacityRange()) {
        result = result && getCapacityRange()
            .equals(other.getCapacityRange());
      }
      result = result && getVolumeCapabilitiesList()
          .equals(other.getVolumeCapabilitiesList());
      result = result && internalGetParameters().equals(
          other.internalGetParameters());
      result = result && internalGetControllerCreateSecrets().equals(
          other.internalGetControllerCreateSecrets());
      result = result && (hasVolumeContentSource() == other.hasVolumeContentSource());
      if (hasVolumeContentSource()) {
        result = result && getVolumeContentSource()
            .equals(other.getVolumeContentSource());
      }
      result = result && (hasAccessibilityRequirements() == other.hasAccessibilityRequirements());
      if (hasAccessibilityRequirements()) {
        result = result && getAccessibilityRequirements()
            .equals(other.getAccessibilityRequirements());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      if (hasCapacityRange()) {
        hash = (37 * hash) + CAPACITY_RANGE_FIELD_NUMBER;
        hash = (53 * hash) + getCapacityRange().hashCode();
      }
      if (getVolumeCapabilitiesCount() > 0) {
        hash = (37 * hash) + VOLUME_CAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeCapabilitiesList().hashCode();
      }
      if (!internalGetParameters().getMap().isEmpty()) {
        hash = (37 * hash) + PARAMETERS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetParameters().hashCode();
      }
      if (!internalGetControllerCreateSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + CONTROLLER_CREATE_SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetControllerCreateSecrets().hashCode();
      }
      if (hasVolumeContentSource()) {
        hash = (37 * hash) + VOLUME_CONTENT_SOURCE_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeContentSource().hashCode();
      }
      if (hasAccessibilityRequirements()) {
        hash = (37 * hash) + ACCESSIBILITY_REQUIREMENTS_FIELD_NUMBER;
        hash = (53 * hash) + getAccessibilityRequirements().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.CreateVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.CreateVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.CreateVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.CreateVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.CreateVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.CreateVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.CreateVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.CreateVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.CreateVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.CreateVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.CreateVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.CreateVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.CreateVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.CreateVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.CreateVolumeRequest)
        csi.v0.Csi.CreateVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_CreateVolumeRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 4:
            return internalGetParameters();
          case 5:
            return internalGetControllerCreateSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 4:
            return internalGetMutableParameters();
          case 5:
            return internalGetMutableControllerCreateSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_CreateVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.CreateVolumeRequest.class, csi.v0.Csi.CreateVolumeRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.CreateVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getVolumeCapabilitiesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";

        if (capacityRangeBuilder_ == null) {
          capacityRange_ = null;
        } else {
          capacityRange_ = null;
          capacityRangeBuilder_ = null;
        }
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          volumeCapabilitiesBuilder_.clear();
        }
        internalGetMutableParameters().clear();
        internalGetMutableControllerCreateSecrets().clear();
        if (volumeContentSourceBuilder_ == null) {
          volumeContentSource_ = null;
        } else {
          volumeContentSource_ = null;
          volumeContentSourceBuilder_ = null;
        }
        if (accessibilityRequirementsBuilder_ == null) {
          accessibilityRequirements_ = null;
        } else {
          accessibilityRequirements_ = null;
          accessibilityRequirementsBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_CreateVolumeRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.CreateVolumeRequest getDefaultInstanceForType() {
        return csi.v0.Csi.CreateVolumeRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.CreateVolumeRequest build() {
        csi.v0.Csi.CreateVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.CreateVolumeRequest buildPartial() {
        csi.v0.Csi.CreateVolumeRequest result = new csi.v0.Csi.CreateVolumeRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.name_ = name_;
        if (capacityRangeBuilder_ == null) {
          result.capacityRange_ = capacityRange_;
        } else {
          result.capacityRange_ = capacityRangeBuilder_.build();
        }
        if (volumeCapabilitiesBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            volumeCapabilities_ = java.util.Collections.unmodifiableList(volumeCapabilities_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.volumeCapabilities_ = volumeCapabilities_;
        } else {
          result.volumeCapabilities_ = volumeCapabilitiesBuilder_.build();
        }
        result.parameters_ = internalGetParameters();
        result.parameters_.makeImmutable();
        result.controllerCreateSecrets_ = internalGetControllerCreateSecrets();
        result.controllerCreateSecrets_.makeImmutable();
        if (volumeContentSourceBuilder_ == null) {
          result.volumeContentSource_ = volumeContentSource_;
        } else {
          result.volumeContentSource_ = volumeContentSourceBuilder_.build();
        }
        if (accessibilityRequirementsBuilder_ == null) {
          result.accessibilityRequirements_ = accessibilityRequirements_;
        } else {
          result.accessibilityRequirements_ = accessibilityRequirementsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.CreateVolumeRequest) {
          return mergeFrom((csi.v0.Csi.CreateVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.CreateVolumeRequest other) {
        if (other == csi.v0.Csi.CreateVolumeRequest.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (other.hasCapacityRange()) {
          mergeCapacityRange(other.getCapacityRange());
        }
        if (volumeCapabilitiesBuilder_ == null) {
          if (!other.volumeCapabilities_.isEmpty()) {
            if (volumeCapabilities_.isEmpty()) {
              volumeCapabilities_ = other.volumeCapabilities_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureVolumeCapabilitiesIsMutable();
              volumeCapabilities_.addAll(other.volumeCapabilities_);
            }
            onChanged();
          }
        } else {
          if (!other.volumeCapabilities_.isEmpty()) {
            if (volumeCapabilitiesBuilder_.isEmpty()) {
              volumeCapabilitiesBuilder_.dispose();
              volumeCapabilitiesBuilder_ = null;
              volumeCapabilities_ = other.volumeCapabilities_;
              bitField0_ = (bitField0_ & ~0x00000004);
              volumeCapabilitiesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getVolumeCapabilitiesFieldBuilder() : null;
            } else {
              volumeCapabilitiesBuilder_.addAllMessages(other.volumeCapabilities_);
            }
          }
        }
        internalGetMutableParameters().mergeFrom(
            other.internalGetParameters());
        internalGetMutableControllerCreateSecrets().mergeFrom(
            other.internalGetControllerCreateSecrets());
        if (other.hasVolumeContentSource()) {
          mergeVolumeContentSource(other.getVolumeContentSource());
        }
        if (other.hasAccessibilityRequirements()) {
          mergeAccessibilityRequirements(other.getAccessibilityRequirements());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.CreateVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.CreateVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The suggested name for the storage space. This field is REQUIRED.
       * It serves two purposes:
       * 1) Idempotency - This name is generated by the CO to achieve
       *    idempotency. If `CreateVolume` fails, the volume may or may not
       *    be provisioned. In this case, the CO may call `CreateVolume`
       *    again, with the same name, to ensure the volume exists. The
       *    Plugin should ensure that multiple `CreateVolume` calls for the
       *    same name do not result in more than one piece of storage
       *    provisioned corresponding to that name. If a Plugin is unable to
       *    enforce idempotency, the CO's error recovery logic could result
       *    in multiple (unused) volumes being provisioned.
       * 2) Suggested name - Some storage systems allow callers to specify
       *    an identifier by which to refer to the newly provisioned
       *    storage. If a storage system supports this, it can optionally
       *    use this name as the identifier for the new volume.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The suggested name for the storage space. This field is REQUIRED.
       * It serves two purposes:
       * 1) Idempotency - This name is generated by the CO to achieve
       *    idempotency. If `CreateVolume` fails, the volume may or may not
       *    be provisioned. In this case, the CO may call `CreateVolume`
       *    again, with the same name, to ensure the volume exists. The
       *    Plugin should ensure that multiple `CreateVolume` calls for the
       *    same name do not result in more than one piece of storage
       *    provisioned corresponding to that name. If a Plugin is unable to
       *    enforce idempotency, the CO's error recovery logic could result
       *    in multiple (unused) volumes being provisioned.
       * 2) Suggested name - Some storage systems allow callers to specify
       *    an identifier by which to refer to the newly provisioned
       *    storage. If a storage system supports this, it can optionally
       *    use this name as the identifier for the new volume.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The suggested name for the storage space. This field is REQUIRED.
       * It serves two purposes:
       * 1) Idempotency - This name is generated by the CO to achieve
       *    idempotency. If `CreateVolume` fails, the volume may or may not
       *    be provisioned. In this case, the CO may call `CreateVolume`
       *    again, with the same name, to ensure the volume exists. The
       *    Plugin should ensure that multiple `CreateVolume` calls for the
       *    same name do not result in more than one piece of storage
       *    provisioned corresponding to that name. If a Plugin is unable to
       *    enforce idempotency, the CO's error recovery logic could result
       *    in multiple (unused) volumes being provisioned.
       * 2) Suggested name - Some storage systems allow callers to specify
       *    an identifier by which to refer to the newly provisioned
       *    storage. If a storage system supports this, it can optionally
       *    use this name as the identifier for the new volume.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The suggested name for the storage space. This field is REQUIRED.
       * It serves two purposes:
       * 1) Idempotency - This name is generated by the CO to achieve
       *    idempotency. If `CreateVolume` fails, the volume may or may not
       *    be provisioned. In this case, the CO may call `CreateVolume`
       *    again, with the same name, to ensure the volume exists. The
       *    Plugin should ensure that multiple `CreateVolume` calls for the
       *    same name do not result in more than one piece of storage
       *    provisioned corresponding to that name. If a Plugin is unable to
       *    enforce idempotency, the CO's error recovery logic could result
       *    in multiple (unused) volumes being provisioned.
       * 2) Suggested name - Some storage systems allow callers to specify
       *    an identifier by which to refer to the newly provisioned
       *    storage. If a storage system supports this, it can optionally
       *    use this name as the identifier for the new volume.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The suggested name for the storage space. This field is REQUIRED.
       * It serves two purposes:
       * 1) Idempotency - This name is generated by the CO to achieve
       *    idempotency. If `CreateVolume` fails, the volume may or may not
       *    be provisioned. In this case, the CO may call `CreateVolume`
       *    again, with the same name, to ensure the volume exists. The
       *    Plugin should ensure that multiple `CreateVolume` calls for the
       *    same name do not result in more than one piece of storage
       *    provisioned corresponding to that name. If a Plugin is unable to
       *    enforce idempotency, the CO's error recovery logic could result
       *    in multiple (unused) volumes being provisioned.
       * 2) Suggested name - Some storage systems allow callers to specify
       *    an identifier by which to refer to the newly provisioned
       *    storage. If a storage system supports this, it can optionally
       *    use this name as the identifier for the new volume.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private csi.v0.Csi.CapacityRange capacityRange_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.CapacityRange, csi.v0.Csi.CapacityRange.Builder, csi.v0.Csi.CapacityRangeOrBuilder> capacityRangeBuilder_;
      /**
       * <code>.csi.v0.CapacityRange capacity_range = 2;</code>
       */
      public boolean hasCapacityRange() {
        return capacityRangeBuilder_ != null || capacityRange_ != null;
      }
      /**
       * <code>.csi.v0.CapacityRange capacity_range = 2;</code>
       */
      public csi.v0.Csi.CapacityRange getCapacityRange() {
        if (capacityRangeBuilder_ == null) {
          return capacityRange_ == null ? csi.v0.Csi.CapacityRange.getDefaultInstance() : capacityRange_;
        } else {
          return capacityRangeBuilder_.getMessage();
        }
      }
      /**
       * <code>.csi.v0.CapacityRange capacity_range = 2;</code>
       */
      public Builder setCapacityRange(csi.v0.Csi.CapacityRange value) {
        if (capacityRangeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          capacityRange_ = value;
          onChanged();
        } else {
          capacityRangeBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <code>.csi.v0.CapacityRange capacity_range = 2;</code>
       */
      public Builder setCapacityRange(
          csi.v0.Csi.CapacityRange.Builder builderForValue) {
        if (capacityRangeBuilder_ == null) {
          capacityRange_ = builderForValue.build();
          onChanged();
        } else {
          capacityRangeBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <code>.csi.v0.CapacityRange capacity_range = 2;</code>
       */
      public Builder mergeCapacityRange(csi.v0.Csi.CapacityRange value) {
        if (capacityRangeBuilder_ == null) {
          if (capacityRange_ != null) {
            capacityRange_ =
              csi.v0.Csi.CapacityRange.newBuilder(capacityRange_).mergeFrom(value).buildPartial();
          } else {
            capacityRange_ = value;
          }
          onChanged();
        } else {
          capacityRangeBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <code>.csi.v0.CapacityRange capacity_range = 2;</code>
       */
      public Builder clearCapacityRange() {
        if (capacityRangeBuilder_ == null) {
          capacityRange_ = null;
          onChanged();
        } else {
          capacityRange_ = null;
          capacityRangeBuilder_ = null;
        }

        return this;
      }
      /**
       * <code>.csi.v0.CapacityRange capacity_range = 2;</code>
       */
      public csi.v0.Csi.CapacityRange.Builder getCapacityRangeBuilder() {
        
        onChanged();
        return getCapacityRangeFieldBuilder().getBuilder();
      }
      /**
       * <code>.csi.v0.CapacityRange capacity_range = 2;</code>
       */
      public csi.v0.Csi.CapacityRangeOrBuilder getCapacityRangeOrBuilder() {
        if (capacityRangeBuilder_ != null) {
          return capacityRangeBuilder_.getMessageOrBuilder();
        } else {
          return capacityRange_ == null ?
              csi.v0.Csi.CapacityRange.getDefaultInstance() : capacityRange_;
        }
      }
      /**
       * <code>.csi.v0.CapacityRange capacity_range = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.CapacityRange, csi.v0.Csi.CapacityRange.Builder, csi.v0.Csi.CapacityRangeOrBuilder> 
          getCapacityRangeFieldBuilder() {
        if (capacityRangeBuilder_ == null) {
          capacityRangeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.CapacityRange, csi.v0.Csi.CapacityRange.Builder, csi.v0.Csi.CapacityRangeOrBuilder>(
                  getCapacityRange(),
                  getParentForChildren(),
                  isClean());
          capacityRange_ = null;
        }
        return capacityRangeBuilder_;
      }

      private java.util.List<csi.v0.Csi.VolumeCapability> volumeCapabilities_ =
        java.util.Collections.emptyList();
      private void ensureVolumeCapabilitiesIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          volumeCapabilities_ = new java.util.ArrayList<csi.v0.Csi.VolumeCapability>(volumeCapabilities_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder> volumeCapabilitiesBuilder_;

      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public java.util.List<csi.v0.Csi.VolumeCapability> getVolumeCapabilitiesList() {
        if (volumeCapabilitiesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(volumeCapabilities_);
        } else {
          return volumeCapabilitiesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public int getVolumeCapabilitiesCount() {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.size();
        } else {
          return volumeCapabilitiesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public csi.v0.Csi.VolumeCapability getVolumeCapabilities(int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.get(index);
        } else {
          return volumeCapabilitiesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder setVolumeCapabilities(
          int index, csi.v0.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.set(index, value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder setVolumeCapabilities(
          int index, csi.v0.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.set(index, builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder addVolumeCapabilities(csi.v0.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder addVolumeCapabilities(
          int index, csi.v0.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(index, value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder addVolumeCapabilities(
          csi.v0.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder addVolumeCapabilities(
          int index, csi.v0.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(index, builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder addAllVolumeCapabilities(
          java.lang.Iterable<? extends csi.v0.Csi.VolumeCapability> values) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, volumeCapabilities_);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder clearVolumeCapabilities() {
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public Builder removeVolumeCapabilities(int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.remove(index);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public csi.v0.Csi.VolumeCapability.Builder getVolumeCapabilitiesBuilder(
          int index) {
        return getVolumeCapabilitiesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
          int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.get(index);  } else {
          return volumeCapabilitiesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public java.util.List<? extends csi.v0.Csi.VolumeCapabilityOrBuilder> 
           getVolumeCapabilitiesOrBuilderList() {
        if (volumeCapabilitiesBuilder_ != null) {
          return volumeCapabilitiesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(volumeCapabilities_);
        }
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public csi.v0.Csi.VolumeCapability.Builder addVolumeCapabilitiesBuilder() {
        return getVolumeCapabilitiesFieldBuilder().addBuilder(
            csi.v0.Csi.VolumeCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public csi.v0.Csi.VolumeCapability.Builder addVolumeCapabilitiesBuilder(
          int index) {
        return getVolumeCapabilitiesFieldBuilder().addBuilder(
            index, csi.v0.Csi.VolumeCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * The capabilities that the provisioned volume MUST have: the Plugin
       * MUST provision a volume that could satisfy ALL of the
       * capabilities specified in this list. The Plugin MUST assume that
       * the CO MAY use the  provisioned volume later with ANY of the
       * capabilities specified in this list. This also enables the CO to do
       * early validation: if ANY of the specified volume capabilities are
       * not supported by the Plugin, the call SHALL fail. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 3;</code>
       */
      public java.util.List<csi.v0.Csi.VolumeCapability.Builder> 
           getVolumeCapabilitiesBuilderList() {
        return getVolumeCapabilitiesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder> 
          getVolumeCapabilitiesFieldBuilder() {
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilitiesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder>(
                  volumeCapabilities_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          volumeCapabilities_ = null;
        }
        return volumeCapabilitiesBuilder_;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> parameters_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetParameters() {
        if (parameters_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        return parameters_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableParameters() {
        onChanged();;
        if (parameters_ == null) {
          parameters_ = com.google.protobuf.MapField.newMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        if (!parameters_.isMutable()) {
          parameters_ = parameters_.copy();
        }
        return parameters_;
      }

      public int getParametersCount() {
        return internalGetParameters().getMap().size();
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public boolean containsParameters(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetParameters().getMap().containsKey(key);
      }
      /**
       * Use {@link #getParametersMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getParameters() {
        return getParametersMap();
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
        return internalGetParameters().getMap();
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public java.lang.String getParametersOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public java.lang.String getParametersOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearParameters() {
        internalGetMutableParameters().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public Builder removeParameters(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableParameters().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableParameters() {
        return internalGetMutableParameters().getMutableMap();
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */
      public Builder putParameters(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableParameters().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public Builder putAllParameters(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableParameters().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> controllerCreateSecrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetControllerCreateSecrets() {
        if (controllerCreateSecrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ControllerCreateSecretsDefaultEntryHolder.defaultEntry);
        }
        return controllerCreateSecrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableControllerCreateSecrets() {
        onChanged();;
        if (controllerCreateSecrets_ == null) {
          controllerCreateSecrets_ = com.google.protobuf.MapField.newMapField(
              ControllerCreateSecretsDefaultEntryHolder.defaultEntry);
        }
        if (!controllerCreateSecrets_.isMutable()) {
          controllerCreateSecrets_ = controllerCreateSecrets_.copy();
        }
        return controllerCreateSecrets_;
      }

      public int getControllerCreateSecretsCount() {
        return internalGetControllerCreateSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_create_secrets = 5;</code>
       */

      public boolean containsControllerCreateSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetControllerCreateSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getControllerCreateSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getControllerCreateSecrets() {
        return getControllerCreateSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_create_secrets = 5;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getControllerCreateSecretsMap() {
        return internalGetControllerCreateSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_create_secrets = 5;</code>
       */

      public java.lang.String getControllerCreateSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetControllerCreateSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_create_secrets = 5;</code>
       */

      public java.lang.String getControllerCreateSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetControllerCreateSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearControllerCreateSecrets() {
        internalGetMutableControllerCreateSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_create_secrets = 5;</code>
       */

      public Builder removeControllerCreateSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableControllerCreateSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableControllerCreateSecrets() {
        return internalGetMutableControllerCreateSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_create_secrets = 5;</code>
       */
      public Builder putControllerCreateSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableControllerCreateSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_create_secrets = 5;</code>
       */

      public Builder putAllControllerCreateSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableControllerCreateSecrets().getMutableMap()
            .putAll(values);
        return this;
      }

      private csi.v0.Csi.VolumeContentSource volumeContentSource_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeContentSource, csi.v0.Csi.VolumeContentSource.Builder, csi.v0.Csi.VolumeContentSourceOrBuilder> volumeContentSourceBuilder_;
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource volume_content_source = 6;</code>
       */
      public boolean hasVolumeContentSource() {
        return volumeContentSourceBuilder_ != null || volumeContentSource_ != null;
      }
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource volume_content_source = 6;</code>
       */
      public csi.v0.Csi.VolumeContentSource getVolumeContentSource() {
        if (volumeContentSourceBuilder_ == null) {
          return volumeContentSource_ == null ? csi.v0.Csi.VolumeContentSource.getDefaultInstance() : volumeContentSource_;
        } else {
          return volumeContentSourceBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource volume_content_source = 6;</code>
       */
      public Builder setVolumeContentSource(csi.v0.Csi.VolumeContentSource value) {
        if (volumeContentSourceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          volumeContentSource_ = value;
          onChanged();
        } else {
          volumeContentSourceBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource volume_content_source = 6;</code>
       */
      public Builder setVolumeContentSource(
          csi.v0.Csi.VolumeContentSource.Builder builderForValue) {
        if (volumeContentSourceBuilder_ == null) {
          volumeContentSource_ = builderForValue.build();
          onChanged();
        } else {
          volumeContentSourceBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource volume_content_source = 6;</code>
       */
      public Builder mergeVolumeContentSource(csi.v0.Csi.VolumeContentSource value) {
        if (volumeContentSourceBuilder_ == null) {
          if (volumeContentSource_ != null) {
            volumeContentSource_ =
              csi.v0.Csi.VolumeContentSource.newBuilder(volumeContentSource_).mergeFrom(value).buildPartial();
          } else {
            volumeContentSource_ = value;
          }
          onChanged();
        } else {
          volumeContentSourceBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource volume_content_source = 6;</code>
       */
      public Builder clearVolumeContentSource() {
        if (volumeContentSourceBuilder_ == null) {
          volumeContentSource_ = null;
          onChanged();
        } else {
          volumeContentSource_ = null;
          volumeContentSourceBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource volume_content_source = 6;</code>
       */
      public csi.v0.Csi.VolumeContentSource.Builder getVolumeContentSourceBuilder() {
        
        onChanged();
        return getVolumeContentSourceFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource volume_content_source = 6;</code>
       */
      public csi.v0.Csi.VolumeContentSourceOrBuilder getVolumeContentSourceOrBuilder() {
        if (volumeContentSourceBuilder_ != null) {
          return volumeContentSourceBuilder_.getMessageOrBuilder();
        } else {
          return volumeContentSource_ == null ?
              csi.v0.Csi.VolumeContentSource.getDefaultInstance() : volumeContentSource_;
        }
      }
      /**
       * <pre>
       * If specified, the new volume will be pre-populated with data from
       * this source. This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource volume_content_source = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeContentSource, csi.v0.Csi.VolumeContentSource.Builder, csi.v0.Csi.VolumeContentSourceOrBuilder> 
          getVolumeContentSourceFieldBuilder() {
        if (volumeContentSourceBuilder_ == null) {
          volumeContentSourceBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.VolumeContentSource, csi.v0.Csi.VolumeContentSource.Builder, csi.v0.Csi.VolumeContentSourceOrBuilder>(
                  getVolumeContentSource(),
                  getParentForChildren(),
                  isClean());
          volumeContentSource_ = null;
        }
        return volumeContentSourceBuilder_;
      }

      private csi.v0.Csi.TopologyRequirement accessibilityRequirements_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.TopologyRequirement, csi.v0.Csi.TopologyRequirement.Builder, csi.v0.Csi.TopologyRequirementOrBuilder> accessibilityRequirementsBuilder_;
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY choose
       * where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v0.TopologyRequirement accessibility_requirements = 7;</code>
       */
      public boolean hasAccessibilityRequirements() {
        return accessibilityRequirementsBuilder_ != null || accessibilityRequirements_ != null;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY choose
       * where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v0.TopologyRequirement accessibility_requirements = 7;</code>
       */
      public csi.v0.Csi.TopologyRequirement getAccessibilityRequirements() {
        if (accessibilityRequirementsBuilder_ == null) {
          return accessibilityRequirements_ == null ? csi.v0.Csi.TopologyRequirement.getDefaultInstance() : accessibilityRequirements_;
        } else {
          return accessibilityRequirementsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY choose
       * where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v0.TopologyRequirement accessibility_requirements = 7;</code>
       */
      public Builder setAccessibilityRequirements(csi.v0.Csi.TopologyRequirement value) {
        if (accessibilityRequirementsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          accessibilityRequirements_ = value;
          onChanged();
        } else {
          accessibilityRequirementsBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY choose
       * where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v0.TopologyRequirement accessibility_requirements = 7;</code>
       */
      public Builder setAccessibilityRequirements(
          csi.v0.Csi.TopologyRequirement.Builder builderForValue) {
        if (accessibilityRequirementsBuilder_ == null) {
          accessibilityRequirements_ = builderForValue.build();
          onChanged();
        } else {
          accessibilityRequirementsBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY choose
       * where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v0.TopologyRequirement accessibility_requirements = 7;</code>
       */
      public Builder mergeAccessibilityRequirements(csi.v0.Csi.TopologyRequirement value) {
        if (accessibilityRequirementsBuilder_ == null) {
          if (accessibilityRequirements_ != null) {
            accessibilityRequirements_ =
              csi.v0.Csi.TopologyRequirement.newBuilder(accessibilityRequirements_).mergeFrom(value).buildPartial();
          } else {
            accessibilityRequirements_ = value;
          }
          onChanged();
        } else {
          accessibilityRequirementsBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY choose
       * where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v0.TopologyRequirement accessibility_requirements = 7;</code>
       */
      public Builder clearAccessibilityRequirements() {
        if (accessibilityRequirementsBuilder_ == null) {
          accessibilityRequirements_ = null;
          onChanged();
        } else {
          accessibilityRequirements_ = null;
          accessibilityRequirementsBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY choose
       * where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v0.TopologyRequirement accessibility_requirements = 7;</code>
       */
      public csi.v0.Csi.TopologyRequirement.Builder getAccessibilityRequirementsBuilder() {
        
        onChanged();
        return getAccessibilityRequirementsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY choose
       * where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v0.TopologyRequirement accessibility_requirements = 7;</code>
       */
      public csi.v0.Csi.TopologyRequirementOrBuilder getAccessibilityRequirementsOrBuilder() {
        if (accessibilityRequirementsBuilder_ != null) {
          return accessibilityRequirementsBuilder_.getMessageOrBuilder();
        } else {
          return accessibilityRequirements_ == null ?
              csi.v0.Csi.TopologyRequirement.getDefaultInstance() : accessibilityRequirements_;
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume MUST be accessible from.
       * An SP SHALL advertise the requirements for topological
       * accessibility information in documentation. COs SHALL only specify
       * topological accessibility information supported by the SP.
       * This field is OPTIONAL.
       * This field SHALL NOT be specified unless the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * If this field is not specified and the SP has the
       * ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY choose
       * where the provisioned volume is accessible from.
       * </pre>
       *
       * <code>.csi.v0.TopologyRequirement accessibility_requirements = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.TopologyRequirement, csi.v0.Csi.TopologyRequirement.Builder, csi.v0.Csi.TopologyRequirementOrBuilder> 
          getAccessibilityRequirementsFieldBuilder() {
        if (accessibilityRequirementsBuilder_ == null) {
          accessibilityRequirementsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.TopologyRequirement, csi.v0.Csi.TopologyRequirement.Builder, csi.v0.Csi.TopologyRequirementOrBuilder>(
                  getAccessibilityRequirements(),
                  getParentForChildren(),
                  isClean());
          accessibilityRequirements_ = null;
        }
        return accessibilityRequirementsBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.CreateVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.CreateVolumeRequest)
    private static final csi.v0.Csi.CreateVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.CreateVolumeRequest();
    }

    public static csi.v0.Csi.CreateVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CreateVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<CreateVolumeRequest>() {
      @java.lang.Override
      public CreateVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CreateVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CreateVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CreateVolumeRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.CreateVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VolumeContentSourceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.VolumeContentSource)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.csi.v0.VolumeContentSource.SnapshotSource snapshot = 1;</code>
     */
    boolean hasSnapshot();
    /**
     * <code>.csi.v0.VolumeContentSource.SnapshotSource snapshot = 1;</code>
     */
    csi.v0.Csi.VolumeContentSource.SnapshotSource getSnapshot();
    /**
     * <code>.csi.v0.VolumeContentSource.SnapshotSource snapshot = 1;</code>
     */
    csi.v0.Csi.VolumeContentSource.SnapshotSourceOrBuilder getSnapshotOrBuilder();

    public csi.v0.Csi.VolumeContentSource.TypeCase getTypeCase();
  }
  /**
   * <pre>
   * Specifies what source the volume will be created from. One of the
   * type fields MUST be specified.
   * </pre>
   *
   * Protobuf type {@code csi.v0.VolumeContentSource}
   */
  public  static final class VolumeContentSource extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.VolumeContentSource)
      VolumeContentSourceOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use VolumeContentSource.newBuilder() to construct.
    private VolumeContentSource(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private VolumeContentSource() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private VolumeContentSource(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              csi.v0.Csi.VolumeContentSource.SnapshotSource.Builder subBuilder = null;
              if (typeCase_ == 1) {
                subBuilder = ((csi.v0.Csi.VolumeContentSource.SnapshotSource) type_).toBuilder();
              }
              type_ =
                  input.readMessage(csi.v0.Csi.VolumeContentSource.SnapshotSource.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((csi.v0.Csi.VolumeContentSource.SnapshotSource) type_);
                type_ = subBuilder.buildPartial();
              }
              typeCase_ = 1;
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_VolumeContentSource_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_VolumeContentSource_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.VolumeContentSource.class, csi.v0.Csi.VolumeContentSource.Builder.class);
    }

    public interface SnapshotSourceOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v0.VolumeContentSource.SnapshotSource)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Contains identity information for the existing source snapshot.
       * This field is REQUIRED. Plugin is REQUIRED to support creating
       * volume from snapshot if it supports the capability
       * CREATE_DELETE_SNAPSHOT.
       * </pre>
       *
       * <code>string id = 1;</code>
       */
      java.lang.String getId();
      /**
       * <pre>
       * Contains identity information for the existing source snapshot.
       * This field is REQUIRED. Plugin is REQUIRED to support creating
       * volume from snapshot if it supports the capability
       * CREATE_DELETE_SNAPSHOT.
       * </pre>
       *
       * <code>string id = 1;</code>
       */
      com.google.protobuf.ByteString
          getIdBytes();
    }
    /**
     * Protobuf type {@code csi.v0.VolumeContentSource.SnapshotSource}
     */
    public  static final class SnapshotSource extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v0.VolumeContentSource.SnapshotSource)
        SnapshotSourceOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use SnapshotSource.newBuilder() to construct.
      private SnapshotSource(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private SnapshotSource() {
        id_ = "";
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private SnapshotSource(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                java.lang.String s = input.readStringRequireUtf8();

                id_ = s;
                break;
              }
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_VolumeContentSource_SnapshotSource_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_VolumeContentSource_SnapshotSource_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.VolumeContentSource.SnapshotSource.class, csi.v0.Csi.VolumeContentSource.SnapshotSource.Builder.class);
      }

      public static final int ID_FIELD_NUMBER = 1;
      private volatile java.lang.Object id_;
      /**
       * <pre>
       * Contains identity information for the existing source snapshot.
       * This field is REQUIRED. Plugin is REQUIRED to support creating
       * volume from snapshot if it supports the capability
       * CREATE_DELETE_SNAPSHOT.
       * </pre>
       *
       * <code>string id = 1;</code>
       */
      public java.lang.String getId() {
        java.lang.Object ref = id_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          id_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * Contains identity information for the existing source snapshot.
       * This field is REQUIRED. Plugin is REQUIRED to support creating
       * volume from snapshot if it supports the capability
       * CREATE_DELETE_SNAPSHOT.
       * </pre>
       *
       * <code>string id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getIdBytes() {
        java.lang.Object ref = id_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          id_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (!getIdBytes().isEmpty()) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 1, id_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (!getIdBytes().isEmpty()) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, id_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v0.Csi.VolumeContentSource.SnapshotSource)) {
          return super.equals(obj);
        }
        csi.v0.Csi.VolumeContentSource.SnapshotSource other = (csi.v0.Csi.VolumeContentSource.SnapshotSource) obj;

        boolean result = true;
        result = result && getId()
            .equals(other.getId());
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + ID_FIELD_NUMBER;
        hash = (53 * hash) + getId().hashCode();
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v0.Csi.VolumeContentSource.SnapshotSource parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.VolumeContentSource.SnapshotSource parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeContentSource.SnapshotSource parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.VolumeContentSource.SnapshotSource parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeContentSource.SnapshotSource parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.VolumeContentSource.SnapshotSource parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeContentSource.SnapshotSource parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.VolumeContentSource.SnapshotSource parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeContentSource.SnapshotSource parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.VolumeContentSource.SnapshotSource parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeContentSource.SnapshotSource parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.VolumeContentSource.SnapshotSource parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v0.Csi.VolumeContentSource.SnapshotSource prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code csi.v0.VolumeContentSource.SnapshotSource}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v0.VolumeContentSource.SnapshotSource)
          csi.v0.Csi.VolumeContentSource.SnapshotSourceOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v0.Csi.internal_static_csi_v0_VolumeContentSource_SnapshotSource_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v0.Csi.internal_static_csi_v0_VolumeContentSource_SnapshotSource_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v0.Csi.VolumeContentSource.SnapshotSource.class, csi.v0.Csi.VolumeContentSource.SnapshotSource.Builder.class);
        }

        // Construct using csi.v0.Csi.VolumeContentSource.SnapshotSource.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          id_ = "";

          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v0.Csi.internal_static_csi_v0_VolumeContentSource_SnapshotSource_descriptor;
        }

        @java.lang.Override
        public csi.v0.Csi.VolumeContentSource.SnapshotSource getDefaultInstanceForType() {
          return csi.v0.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance();
        }

        @java.lang.Override
        public csi.v0.Csi.VolumeContentSource.SnapshotSource build() {
          csi.v0.Csi.VolumeContentSource.SnapshotSource result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public csi.v0.Csi.VolumeContentSource.SnapshotSource buildPartial() {
          csi.v0.Csi.VolumeContentSource.SnapshotSource result = new csi.v0.Csi.VolumeContentSource.SnapshotSource(this);
          result.id_ = id_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return (Builder) super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v0.Csi.VolumeContentSource.SnapshotSource) {
            return mergeFrom((csi.v0.Csi.VolumeContentSource.SnapshotSource)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v0.Csi.VolumeContentSource.SnapshotSource other) {
          if (other == csi.v0.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance()) return this;
          if (!other.getId().isEmpty()) {
            id_ = other.id_;
            onChanged();
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v0.Csi.VolumeContentSource.SnapshotSource parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v0.Csi.VolumeContentSource.SnapshotSource) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private java.lang.Object id_ = "";
        /**
         * <pre>
         * Contains identity information for the existing source snapshot.
         * This field is REQUIRED. Plugin is REQUIRED to support creating
         * volume from snapshot if it supports the capability
         * CREATE_DELETE_SNAPSHOT.
         * </pre>
         *
         * <code>string id = 1;</code>
         */
        public java.lang.String getId() {
          java.lang.Object ref = id_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            id_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * Contains identity information for the existing source snapshot.
         * This field is REQUIRED. Plugin is REQUIRED to support creating
         * volume from snapshot if it supports the capability
         * CREATE_DELETE_SNAPSHOT.
         * </pre>
         *
         * <code>string id = 1;</code>
         */
        public com.google.protobuf.ByteString
            getIdBytes() {
          java.lang.Object ref = id_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            id_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * Contains identity information for the existing source snapshot.
         * This field is REQUIRED. Plugin is REQUIRED to support creating
         * volume from snapshot if it supports the capability
         * CREATE_DELETE_SNAPSHOT.
         * </pre>
         *
         * <code>string id = 1;</code>
         */
        public Builder setId(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  
          id_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Contains identity information for the existing source snapshot.
         * This field is REQUIRED. Plugin is REQUIRED to support creating
         * volume from snapshot if it supports the capability
         * CREATE_DELETE_SNAPSHOT.
         * </pre>
         *
         * <code>string id = 1;</code>
         */
        public Builder clearId() {
          
          id_ = getDefaultInstance().getId();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Contains identity information for the existing source snapshot.
         * This field is REQUIRED. Plugin is REQUIRED to support creating
         * volume from snapshot if it supports the capability
         * CREATE_DELETE_SNAPSHOT.
         * </pre>
         *
         * <code>string id = 1;</code>
         */
        public Builder setIdBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          
          id_ = value;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v0.VolumeContentSource.SnapshotSource)
      }

      // @@protoc_insertion_point(class_scope:csi.v0.VolumeContentSource.SnapshotSource)
      private static final csi.v0.Csi.VolumeContentSource.SnapshotSource DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v0.Csi.VolumeContentSource.SnapshotSource();
      }

      public static csi.v0.Csi.VolumeContentSource.SnapshotSource getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<SnapshotSource>
          PARSER = new com.google.protobuf.AbstractParser<SnapshotSource>() {
        @java.lang.Override
        public SnapshotSource parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new SnapshotSource(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<SnapshotSource> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<SnapshotSource> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public csi.v0.Csi.VolumeContentSource.SnapshotSource getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int typeCase_ = 0;
    private java.lang.Object type_;
    public enum TypeCase
        implements com.google.protobuf.Internal.EnumLite {
      SNAPSHOT(1),
      TYPE_NOT_SET(0);
      private final int value;
      private TypeCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TypeCase valueOf(int value) {
        return forNumber(value);
      }

      public static TypeCase forNumber(int value) {
        switch (value) {
          case 1: return SNAPSHOT;
          case 0: return TYPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public TypeCase
    getTypeCase() {
      return TypeCase.forNumber(
          typeCase_);
    }

    public static final int SNAPSHOT_FIELD_NUMBER = 1;
    /**
     * <code>.csi.v0.VolumeContentSource.SnapshotSource snapshot = 1;</code>
     */
    public boolean hasSnapshot() {
      return typeCase_ == 1;
    }
    /**
     * <code>.csi.v0.VolumeContentSource.SnapshotSource snapshot = 1;</code>
     */
    public csi.v0.Csi.VolumeContentSource.SnapshotSource getSnapshot() {
      if (typeCase_ == 1) {
         return (csi.v0.Csi.VolumeContentSource.SnapshotSource) type_;
      }
      return csi.v0.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance();
    }
    /**
     * <code>.csi.v0.VolumeContentSource.SnapshotSource snapshot = 1;</code>
     */
    public csi.v0.Csi.VolumeContentSource.SnapshotSourceOrBuilder getSnapshotOrBuilder() {
      if (typeCase_ == 1) {
         return (csi.v0.Csi.VolumeContentSource.SnapshotSource) type_;
      }
      return csi.v0.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (typeCase_ == 1) {
        output.writeMessage(1, (csi.v0.Csi.VolumeContentSource.SnapshotSource) type_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (typeCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, (csi.v0.Csi.VolumeContentSource.SnapshotSource) type_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.VolumeContentSource)) {
        return super.equals(obj);
      }
      csi.v0.Csi.VolumeContentSource other = (csi.v0.Csi.VolumeContentSource) obj;

      boolean result = true;
      result = result && getTypeCase().equals(
          other.getTypeCase());
      if (!result) return false;
      switch (typeCase_) {
        case 1:
          result = result && getSnapshot()
              .equals(other.getSnapshot());
          break;
        case 0:
        default:
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      switch (typeCase_) {
        case 1:
          hash = (37 * hash) + SNAPSHOT_FIELD_NUMBER;
          hash = (53 * hash) + getSnapshot().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.VolumeContentSource parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.VolumeContentSource parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.VolumeContentSource parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.VolumeContentSource parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.VolumeContentSource parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.VolumeContentSource parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.VolumeContentSource parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.VolumeContentSource parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.VolumeContentSource parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.VolumeContentSource parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.VolumeContentSource parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.VolumeContentSource parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.VolumeContentSource prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specifies what source the volume will be created from. One of the
     * type fields MUST be specified.
     * </pre>
     *
     * Protobuf type {@code csi.v0.VolumeContentSource}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.VolumeContentSource)
        csi.v0.Csi.VolumeContentSourceOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_VolumeContentSource_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_VolumeContentSource_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.VolumeContentSource.class, csi.v0.Csi.VolumeContentSource.Builder.class);
      }

      // Construct using csi.v0.Csi.VolumeContentSource.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        typeCase_ = 0;
        type_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_VolumeContentSource_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.VolumeContentSource getDefaultInstanceForType() {
        return csi.v0.Csi.VolumeContentSource.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.VolumeContentSource build() {
        csi.v0.Csi.VolumeContentSource result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.VolumeContentSource buildPartial() {
        csi.v0.Csi.VolumeContentSource result = new csi.v0.Csi.VolumeContentSource(this);
        if (typeCase_ == 1) {
          if (snapshotBuilder_ == null) {
            result.type_ = type_;
          } else {
            result.type_ = snapshotBuilder_.build();
          }
        }
        result.typeCase_ = typeCase_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.VolumeContentSource) {
          return mergeFrom((csi.v0.Csi.VolumeContentSource)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.VolumeContentSource other) {
        if (other == csi.v0.Csi.VolumeContentSource.getDefaultInstance()) return this;
        switch (other.getTypeCase()) {
          case SNAPSHOT: {
            mergeSnapshot(other.getSnapshot());
            break;
          }
          case TYPE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.VolumeContentSource parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.VolumeContentSource) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int typeCase_ = 0;
      private java.lang.Object type_;
      public TypeCase
          getTypeCase() {
        return TypeCase.forNumber(
            typeCase_);
      }

      public Builder clearType() {
        typeCase_ = 0;
        type_ = null;
        onChanged();
        return this;
      }


      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeContentSource.SnapshotSource, csi.v0.Csi.VolumeContentSource.SnapshotSource.Builder, csi.v0.Csi.VolumeContentSource.SnapshotSourceOrBuilder> snapshotBuilder_;
      /**
       * <code>.csi.v0.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      public boolean hasSnapshot() {
        return typeCase_ == 1;
      }
      /**
       * <code>.csi.v0.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      public csi.v0.Csi.VolumeContentSource.SnapshotSource getSnapshot() {
        if (snapshotBuilder_ == null) {
          if (typeCase_ == 1) {
            return (csi.v0.Csi.VolumeContentSource.SnapshotSource) type_;
          }
          return csi.v0.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance();
        } else {
          if (typeCase_ == 1) {
            return snapshotBuilder_.getMessage();
          }
          return csi.v0.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance();
        }
      }
      /**
       * <code>.csi.v0.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      public Builder setSnapshot(csi.v0.Csi.VolumeContentSource.SnapshotSource value) {
        if (snapshotBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          type_ = value;
          onChanged();
        } else {
          snapshotBuilder_.setMessage(value);
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <code>.csi.v0.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      public Builder setSnapshot(
          csi.v0.Csi.VolumeContentSource.SnapshotSource.Builder builderForValue) {
        if (snapshotBuilder_ == null) {
          type_ = builderForValue.build();
          onChanged();
        } else {
          snapshotBuilder_.setMessage(builderForValue.build());
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <code>.csi.v0.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      public Builder mergeSnapshot(csi.v0.Csi.VolumeContentSource.SnapshotSource value) {
        if (snapshotBuilder_ == null) {
          if (typeCase_ == 1 &&
              type_ != csi.v0.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance()) {
            type_ = csi.v0.Csi.VolumeContentSource.SnapshotSource.newBuilder((csi.v0.Csi.VolumeContentSource.SnapshotSource) type_)
                .mergeFrom(value).buildPartial();
          } else {
            type_ = value;
          }
          onChanged();
        } else {
          if (typeCase_ == 1) {
            snapshotBuilder_.mergeFrom(value);
          }
          snapshotBuilder_.setMessage(value);
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <code>.csi.v0.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      public Builder clearSnapshot() {
        if (snapshotBuilder_ == null) {
          if (typeCase_ == 1) {
            typeCase_ = 0;
            type_ = null;
            onChanged();
          }
        } else {
          if (typeCase_ == 1) {
            typeCase_ = 0;
            type_ = null;
          }
          snapshotBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.csi.v0.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      public csi.v0.Csi.VolumeContentSource.SnapshotSource.Builder getSnapshotBuilder() {
        return getSnapshotFieldBuilder().getBuilder();
      }
      /**
       * <code>.csi.v0.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      public csi.v0.Csi.VolumeContentSource.SnapshotSourceOrBuilder getSnapshotOrBuilder() {
        if ((typeCase_ == 1) && (snapshotBuilder_ != null)) {
          return snapshotBuilder_.getMessageOrBuilder();
        } else {
          if (typeCase_ == 1) {
            return (csi.v0.Csi.VolumeContentSource.SnapshotSource) type_;
          }
          return csi.v0.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance();
        }
      }
      /**
       * <code>.csi.v0.VolumeContentSource.SnapshotSource snapshot = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeContentSource.SnapshotSource, csi.v0.Csi.VolumeContentSource.SnapshotSource.Builder, csi.v0.Csi.VolumeContentSource.SnapshotSourceOrBuilder> 
          getSnapshotFieldBuilder() {
        if (snapshotBuilder_ == null) {
          if (!(typeCase_ == 1)) {
            type_ = csi.v0.Csi.VolumeContentSource.SnapshotSource.getDefaultInstance();
          }
          snapshotBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.VolumeContentSource.SnapshotSource, csi.v0.Csi.VolumeContentSource.SnapshotSource.Builder, csi.v0.Csi.VolumeContentSource.SnapshotSourceOrBuilder>(
                  (csi.v0.Csi.VolumeContentSource.SnapshotSource) type_,
                  getParentForChildren(),
                  isClean());
          type_ = null;
        }
        typeCase_ = 1;
        onChanged();;
        return snapshotBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.VolumeContentSource)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.VolumeContentSource)
    private static final csi.v0.Csi.VolumeContentSource DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.VolumeContentSource();
    }

    public static csi.v0.Csi.VolumeContentSource getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<VolumeContentSource>
        PARSER = new com.google.protobuf.AbstractParser<VolumeContentSource>() {
      @java.lang.Override
      public VolumeContentSource parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new VolumeContentSource(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<VolumeContentSource> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VolumeContentSource> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.VolumeContentSource getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CreateVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.CreateVolumeResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Contains all attributes of the newly created volume that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v0.Volume volume = 1;</code>
     */
    boolean hasVolume();
    /**
     * <pre>
     * Contains all attributes of the newly created volume that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v0.Volume volume = 1;</code>
     */
    csi.v0.Csi.Volume getVolume();
    /**
     * <pre>
     * Contains all attributes of the newly created volume that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v0.Volume volume = 1;</code>
     */
    csi.v0.Csi.VolumeOrBuilder getVolumeOrBuilder();
  }
  /**
   * Protobuf type {@code csi.v0.CreateVolumeResponse}
   */
  public  static final class CreateVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.CreateVolumeResponse)
      CreateVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CreateVolumeResponse.newBuilder() to construct.
    private CreateVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CreateVolumeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CreateVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              csi.v0.Csi.Volume.Builder subBuilder = null;
              if (volume_ != null) {
                subBuilder = volume_.toBuilder();
              }
              volume_ = input.readMessage(csi.v0.Csi.Volume.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(volume_);
                volume_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_CreateVolumeResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_CreateVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.CreateVolumeResponse.class, csi.v0.Csi.CreateVolumeResponse.Builder.class);
    }

    public static final int VOLUME_FIELD_NUMBER = 1;
    private csi.v0.Csi.Volume volume_;
    /**
     * <pre>
     * Contains all attributes of the newly created volume that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v0.Volume volume = 1;</code>
     */
    public boolean hasVolume() {
      return volume_ != null;
    }
    /**
     * <pre>
     * Contains all attributes of the newly created volume that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v0.Volume volume = 1;</code>
     */
    public csi.v0.Csi.Volume getVolume() {
      return volume_ == null ? csi.v0.Csi.Volume.getDefaultInstance() : volume_;
    }
    /**
     * <pre>
     * Contains all attributes of the newly created volume that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v0.Volume volume = 1;</code>
     */
    public csi.v0.Csi.VolumeOrBuilder getVolumeOrBuilder() {
      return getVolume();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (volume_ != null) {
        output.writeMessage(1, getVolume());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (volume_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getVolume());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.CreateVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.CreateVolumeResponse other = (csi.v0.Csi.CreateVolumeResponse) obj;

      boolean result = true;
      result = result && (hasVolume() == other.hasVolume());
      if (hasVolume()) {
        result = result && getVolume()
            .equals(other.getVolume());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasVolume()) {
        hash = (37 * hash) + VOLUME_FIELD_NUMBER;
        hash = (53 * hash) + getVolume().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.CreateVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.CreateVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.CreateVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.CreateVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.CreateVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.CreateVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.CreateVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.CreateVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.CreateVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.CreateVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.CreateVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.CreateVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.CreateVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.CreateVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.CreateVolumeResponse)
        csi.v0.Csi.CreateVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_CreateVolumeResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_CreateVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.CreateVolumeResponse.class, csi.v0.Csi.CreateVolumeResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.CreateVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (volumeBuilder_ == null) {
          volume_ = null;
        } else {
          volume_ = null;
          volumeBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_CreateVolumeResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.CreateVolumeResponse getDefaultInstanceForType() {
        return csi.v0.Csi.CreateVolumeResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.CreateVolumeResponse build() {
        csi.v0.Csi.CreateVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.CreateVolumeResponse buildPartial() {
        csi.v0.Csi.CreateVolumeResponse result = new csi.v0.Csi.CreateVolumeResponse(this);
        if (volumeBuilder_ == null) {
          result.volume_ = volume_;
        } else {
          result.volume_ = volumeBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.CreateVolumeResponse) {
          return mergeFrom((csi.v0.Csi.CreateVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.CreateVolumeResponse other) {
        if (other == csi.v0.Csi.CreateVolumeResponse.getDefaultInstance()) return this;
        if (other.hasVolume()) {
          mergeVolume(other.getVolume());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.CreateVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.CreateVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private csi.v0.Csi.Volume volume_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.Volume, csi.v0.Csi.Volume.Builder, csi.v0.Csi.VolumeOrBuilder> volumeBuilder_;
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Volume volume = 1;</code>
       */
      public boolean hasVolume() {
        return volumeBuilder_ != null || volume_ != null;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Volume volume = 1;</code>
       */
      public csi.v0.Csi.Volume getVolume() {
        if (volumeBuilder_ == null) {
          return volume_ == null ? csi.v0.Csi.Volume.getDefaultInstance() : volume_;
        } else {
          return volumeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Volume volume = 1;</code>
       */
      public Builder setVolume(csi.v0.Csi.Volume value) {
        if (volumeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          volume_ = value;
          onChanged();
        } else {
          volumeBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Volume volume = 1;</code>
       */
      public Builder setVolume(
          csi.v0.Csi.Volume.Builder builderForValue) {
        if (volumeBuilder_ == null) {
          volume_ = builderForValue.build();
          onChanged();
        } else {
          volumeBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Volume volume = 1;</code>
       */
      public Builder mergeVolume(csi.v0.Csi.Volume value) {
        if (volumeBuilder_ == null) {
          if (volume_ != null) {
            volume_ =
              csi.v0.Csi.Volume.newBuilder(volume_).mergeFrom(value).buildPartial();
          } else {
            volume_ = value;
          }
          onChanged();
        } else {
          volumeBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Volume volume = 1;</code>
       */
      public Builder clearVolume() {
        if (volumeBuilder_ == null) {
          volume_ = null;
          onChanged();
        } else {
          volume_ = null;
          volumeBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Volume volume = 1;</code>
       */
      public csi.v0.Csi.Volume.Builder getVolumeBuilder() {
        
        onChanged();
        return getVolumeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Volume volume = 1;</code>
       */
      public csi.v0.Csi.VolumeOrBuilder getVolumeOrBuilder() {
        if (volumeBuilder_ != null) {
          return volumeBuilder_.getMessageOrBuilder();
        } else {
          return volume_ == null ?
              csi.v0.Csi.Volume.getDefaultInstance() : volume_;
        }
      }
      /**
       * <pre>
       * Contains all attributes of the newly created volume that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Volume volume = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.Volume, csi.v0.Csi.Volume.Builder, csi.v0.Csi.VolumeOrBuilder> 
          getVolumeFieldBuilder() {
        if (volumeBuilder_ == null) {
          volumeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.Volume, csi.v0.Csi.Volume.Builder, csi.v0.Csi.VolumeOrBuilder>(
                  getVolume(),
                  getParentForChildren(),
                  isClean());
          volume_ = null;
        }
        return volumeBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.CreateVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.CreateVolumeResponse)
    private static final csi.v0.Csi.CreateVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.CreateVolumeResponse();
    }

    public static csi.v0.Csi.CreateVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CreateVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<CreateVolumeResponse>() {
      @java.lang.Override
      public CreateVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CreateVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CreateVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CreateVolumeResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.CreateVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VolumeCapabilityOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.VolumeCapability)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.csi.v0.VolumeCapability.BlockVolume block = 1;</code>
     */
    boolean hasBlock();
    /**
     * <code>.csi.v0.VolumeCapability.BlockVolume block = 1;</code>
     */
    csi.v0.Csi.VolumeCapability.BlockVolume getBlock();
    /**
     * <code>.csi.v0.VolumeCapability.BlockVolume block = 1;</code>
     */
    csi.v0.Csi.VolumeCapability.BlockVolumeOrBuilder getBlockOrBuilder();

    /**
     * <code>.csi.v0.VolumeCapability.MountVolume mount = 2;</code>
     */
    boolean hasMount();
    /**
     * <code>.csi.v0.VolumeCapability.MountVolume mount = 2;</code>
     */
    csi.v0.Csi.VolumeCapability.MountVolume getMount();
    /**
     * <code>.csi.v0.VolumeCapability.MountVolume mount = 2;</code>
     */
    csi.v0.Csi.VolumeCapability.MountVolumeOrBuilder getMountOrBuilder();

    /**
     * <pre>
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability.AccessMode access_mode = 3;</code>
     */
    boolean hasAccessMode();
    /**
     * <pre>
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability.AccessMode access_mode = 3;</code>
     */
    csi.v0.Csi.VolumeCapability.AccessMode getAccessMode();
    /**
     * <pre>
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability.AccessMode access_mode = 3;</code>
     */
    csi.v0.Csi.VolumeCapability.AccessModeOrBuilder getAccessModeOrBuilder();

    public csi.v0.Csi.VolumeCapability.AccessTypeCase getAccessTypeCase();
  }
  /**
   * <pre>
   * Specify a capability of a volume.
   * </pre>
   *
   * Protobuf type {@code csi.v0.VolumeCapability}
   */
  public  static final class VolumeCapability extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.VolumeCapability)
      VolumeCapabilityOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use VolumeCapability.newBuilder() to construct.
    private VolumeCapability(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private VolumeCapability() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private VolumeCapability(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              csi.v0.Csi.VolumeCapability.BlockVolume.Builder subBuilder = null;
              if (accessTypeCase_ == 1) {
                subBuilder = ((csi.v0.Csi.VolumeCapability.BlockVolume) accessType_).toBuilder();
              }
              accessType_ =
                  input.readMessage(csi.v0.Csi.VolumeCapability.BlockVolume.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((csi.v0.Csi.VolumeCapability.BlockVolume) accessType_);
                accessType_ = subBuilder.buildPartial();
              }
              accessTypeCase_ = 1;
              break;
            }
            case 18: {
              csi.v0.Csi.VolumeCapability.MountVolume.Builder subBuilder = null;
              if (accessTypeCase_ == 2) {
                subBuilder = ((csi.v0.Csi.VolumeCapability.MountVolume) accessType_).toBuilder();
              }
              accessType_ =
                  input.readMessage(csi.v0.Csi.VolumeCapability.MountVolume.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((csi.v0.Csi.VolumeCapability.MountVolume) accessType_);
                accessType_ = subBuilder.buildPartial();
              }
              accessTypeCase_ = 2;
              break;
            }
            case 26: {
              csi.v0.Csi.VolumeCapability.AccessMode.Builder subBuilder = null;
              if (accessMode_ != null) {
                subBuilder = accessMode_.toBuilder();
              }
              accessMode_ = input.readMessage(csi.v0.Csi.VolumeCapability.AccessMode.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(accessMode_);
                accessMode_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.VolumeCapability.class, csi.v0.Csi.VolumeCapability.Builder.class);
    }

    public interface BlockVolumeOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v0.VolumeCapability.BlockVolume)
        com.google.protobuf.MessageOrBuilder {
    }
    /**
     * <pre>
     * Indicate that the volume will be accessed via the block device API.
     * </pre>
     *
     * Protobuf type {@code csi.v0.VolumeCapability.BlockVolume}
     */
    public  static final class BlockVolume extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v0.VolumeCapability.BlockVolume)
        BlockVolumeOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use BlockVolume.newBuilder() to construct.
      private BlockVolume(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private BlockVolume() {
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private BlockVolume(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_BlockVolume_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_BlockVolume_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.VolumeCapability.BlockVolume.class, csi.v0.Csi.VolumeCapability.BlockVolume.Builder.class);
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v0.Csi.VolumeCapability.BlockVolume)) {
          return super.equals(obj);
        }
        csi.v0.Csi.VolumeCapability.BlockVolume other = (csi.v0.Csi.VolumeCapability.BlockVolume) obj;

        boolean result = true;
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v0.Csi.VolumeCapability.BlockVolume parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.VolumeCapability.BlockVolume parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeCapability.BlockVolume parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.VolumeCapability.BlockVolume parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeCapability.BlockVolume parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.VolumeCapability.BlockVolume parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeCapability.BlockVolume parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.VolumeCapability.BlockVolume parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeCapability.BlockVolume parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.VolumeCapability.BlockVolume parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeCapability.BlockVolume parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.VolumeCapability.BlockVolume parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v0.Csi.VolumeCapability.BlockVolume prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Indicate that the volume will be accessed via the block device API.
       * </pre>
       *
       * Protobuf type {@code csi.v0.VolumeCapability.BlockVolume}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v0.VolumeCapability.BlockVolume)
          csi.v0.Csi.VolumeCapability.BlockVolumeOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_BlockVolume_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_BlockVolume_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v0.Csi.VolumeCapability.BlockVolume.class, csi.v0.Csi.VolumeCapability.BlockVolume.Builder.class);
        }

        // Construct using csi.v0.Csi.VolumeCapability.BlockVolume.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_BlockVolume_descriptor;
        }

        @java.lang.Override
        public csi.v0.Csi.VolumeCapability.BlockVolume getDefaultInstanceForType() {
          return csi.v0.Csi.VolumeCapability.BlockVolume.getDefaultInstance();
        }

        @java.lang.Override
        public csi.v0.Csi.VolumeCapability.BlockVolume build() {
          csi.v0.Csi.VolumeCapability.BlockVolume result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public csi.v0.Csi.VolumeCapability.BlockVolume buildPartial() {
          csi.v0.Csi.VolumeCapability.BlockVolume result = new csi.v0.Csi.VolumeCapability.BlockVolume(this);
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return (Builder) super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v0.Csi.VolumeCapability.BlockVolume) {
            return mergeFrom((csi.v0.Csi.VolumeCapability.BlockVolume)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v0.Csi.VolumeCapability.BlockVolume other) {
          if (other == csi.v0.Csi.VolumeCapability.BlockVolume.getDefaultInstance()) return this;
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v0.Csi.VolumeCapability.BlockVolume parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v0.Csi.VolumeCapability.BlockVolume) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v0.VolumeCapability.BlockVolume)
      }

      // @@protoc_insertion_point(class_scope:csi.v0.VolumeCapability.BlockVolume)
      private static final csi.v0.Csi.VolumeCapability.BlockVolume DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v0.Csi.VolumeCapability.BlockVolume();
      }

      public static csi.v0.Csi.VolumeCapability.BlockVolume getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<BlockVolume>
          PARSER = new com.google.protobuf.AbstractParser<BlockVolume>() {
        @java.lang.Override
        public BlockVolume parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new BlockVolume(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<BlockVolume> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<BlockVolume> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public csi.v0.Csi.VolumeCapability.BlockVolume getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface MountVolumeOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v0.VolumeCapability.MountVolume)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * The filesystem type. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string fs_type = 1;</code>
       */
      java.lang.String getFsType();
      /**
       * <pre>
       * The filesystem type. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string fs_type = 1;</code>
       */
      com.google.protobuf.ByteString
          getFsTypeBytes();

      /**
       * <pre>
       * The mount options that can be used for the volume. This field is
       * OPTIONAL. `mount_flags` MAY contain sensitive information.
       * Therefore, the CO and the Plugin MUST NOT leak this information
       * to untrusted entities. The total size of this repeated field
       * SHALL NOT exceed 4 KiB.
       * </pre>
       *
       * <code>repeated string mount_flags = 2;</code>
       */
      java.util.List<java.lang.String>
          getMountFlagsList();
      /**
       * <pre>
       * The mount options that can be used for the volume. This field is
       * OPTIONAL. `mount_flags` MAY contain sensitive information.
       * Therefore, the CO and the Plugin MUST NOT leak this information
       * to untrusted entities. The total size of this repeated field
       * SHALL NOT exceed 4 KiB.
       * </pre>
       *
       * <code>repeated string mount_flags = 2;</code>
       */
      int getMountFlagsCount();
      /**
       * <pre>
       * The mount options that can be used for the volume. This field is
       * OPTIONAL. `mount_flags` MAY contain sensitive information.
       * Therefore, the CO and the Plugin MUST NOT leak this information
       * to untrusted entities. The total size of this repeated field
       * SHALL NOT exceed 4 KiB.
       * </pre>
       *
       * <code>repeated string mount_flags = 2;</code>
       */
      java.lang.String getMountFlags(int index);
      /**
       * <pre>
       * The mount options that can be used for the volume. This field is
       * OPTIONAL. `mount_flags` MAY contain sensitive information.
       * Therefore, the CO and the Plugin MUST NOT leak this information
       * to untrusted entities. The total size of this repeated field
       * SHALL NOT exceed 4 KiB.
       * </pre>
       *
       * <code>repeated string mount_flags = 2;</code>
       */
      com.google.protobuf.ByteString
          getMountFlagsBytes(int index);
    }
    /**
     * <pre>
     * Indicate that the volume will be accessed via the filesystem API.
     * </pre>
     *
     * Protobuf type {@code csi.v0.VolumeCapability.MountVolume}
     */
    public  static final class MountVolume extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v0.VolumeCapability.MountVolume)
        MountVolumeOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use MountVolume.newBuilder() to construct.
      private MountVolume(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private MountVolume() {
        fsType_ = "";
        mountFlags_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private MountVolume(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                java.lang.String s = input.readStringRequireUtf8();

                fsType_ = s;
                break;
              }
              case 18: {
                java.lang.String s = input.readStringRequireUtf8();
                if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                  mountFlags_ = new com.google.protobuf.LazyStringArrayList();
                  mutable_bitField0_ |= 0x00000002;
                }
                mountFlags_.add(s);
                break;
              }
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
            mountFlags_ = mountFlags_.getUnmodifiableView();
          }
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_MountVolume_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_MountVolume_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.VolumeCapability.MountVolume.class, csi.v0.Csi.VolumeCapability.MountVolume.Builder.class);
      }

      private int bitField0_;
      public static final int FS_TYPE_FIELD_NUMBER = 1;
      private volatile java.lang.Object fsType_;
      /**
       * <pre>
       * The filesystem type. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string fs_type = 1;</code>
       */
      public java.lang.String getFsType() {
        java.lang.Object ref = fsType_;
        if (ref instanceof java.lang.String) {
          return (java.lang.String) ref;
        } else {
          com.google.protobuf.ByteString bs = 
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          fsType_ = s;
          return s;
        }
      }
      /**
       * <pre>
       * The filesystem type. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string fs_type = 1;</code>
       */
      public com.google.protobuf.ByteString
          getFsTypeBytes() {
        java.lang.Object ref = fsType_;
        if (ref instanceof java.lang.String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          fsType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }

      public static final int MOUNT_FLAGS_FIELD_NUMBER = 2;
      private com.google.protobuf.LazyStringList mountFlags_;
      /**
       * <pre>
       * The mount options that can be used for the volume. This field is
       * OPTIONAL. `mount_flags` MAY contain sensitive information.
       * Therefore, the CO and the Plugin MUST NOT leak this information
       * to untrusted entities. The total size of this repeated field
       * SHALL NOT exceed 4 KiB.
       * </pre>
       *
       * <code>repeated string mount_flags = 2;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getMountFlagsList() {
        return mountFlags_;
      }
      /**
       * <pre>
       * The mount options that can be used for the volume. This field is
       * OPTIONAL. `mount_flags` MAY contain sensitive information.
       * Therefore, the CO and the Plugin MUST NOT leak this information
       * to untrusted entities. The total size of this repeated field
       * SHALL NOT exceed 4 KiB.
       * </pre>
       *
       * <code>repeated string mount_flags = 2;</code>
       */
      public int getMountFlagsCount() {
        return mountFlags_.size();
      }
      /**
       * <pre>
       * The mount options that can be used for the volume. This field is
       * OPTIONAL. `mount_flags` MAY contain sensitive information.
       * Therefore, the CO and the Plugin MUST NOT leak this information
       * to untrusted entities. The total size of this repeated field
       * SHALL NOT exceed 4 KiB.
       * </pre>
       *
       * <code>repeated string mount_flags = 2;</code>
       */
      public java.lang.String getMountFlags(int index) {
        return mountFlags_.get(index);
      }
      /**
       * <pre>
       * The mount options that can be used for the volume. This field is
       * OPTIONAL. `mount_flags` MAY contain sensitive information.
       * Therefore, the CO and the Plugin MUST NOT leak this information
       * to untrusted entities. The total size of this repeated field
       * SHALL NOT exceed 4 KiB.
       * </pre>
       *
       * <code>repeated string mount_flags = 2;</code>
       */
      public com.google.protobuf.ByteString
          getMountFlagsBytes(int index) {
        return mountFlags_.getByteString(index);
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (!getFsTypeBytes().isEmpty()) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 1, fsType_);
        }
        for (int i = 0; i < mountFlags_.size(); i++) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 2, mountFlags_.getRaw(i));
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (!getFsTypeBytes().isEmpty()) {
          size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, fsType_);
        }
        {
          int dataSize = 0;
          for (int i = 0; i < mountFlags_.size(); i++) {
            dataSize += computeStringSizeNoTag(mountFlags_.getRaw(i));
          }
          size += dataSize;
          size += 1 * getMountFlagsList().size();
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v0.Csi.VolumeCapability.MountVolume)) {
          return super.equals(obj);
        }
        csi.v0.Csi.VolumeCapability.MountVolume other = (csi.v0.Csi.VolumeCapability.MountVolume) obj;

        boolean result = true;
        result = result && getFsType()
            .equals(other.getFsType());
        result = result && getMountFlagsList()
            .equals(other.getMountFlagsList());
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + FS_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getFsType().hashCode();
        if (getMountFlagsCount() > 0) {
          hash = (37 * hash) + MOUNT_FLAGS_FIELD_NUMBER;
          hash = (53 * hash) + getMountFlagsList().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v0.Csi.VolumeCapability.MountVolume parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.VolumeCapability.MountVolume parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeCapability.MountVolume parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.VolumeCapability.MountVolume parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeCapability.MountVolume parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.VolumeCapability.MountVolume parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeCapability.MountVolume parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.VolumeCapability.MountVolume parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeCapability.MountVolume parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.VolumeCapability.MountVolume parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeCapability.MountVolume parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.VolumeCapability.MountVolume parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v0.Csi.VolumeCapability.MountVolume prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Indicate that the volume will be accessed via the filesystem API.
       * </pre>
       *
       * Protobuf type {@code csi.v0.VolumeCapability.MountVolume}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v0.VolumeCapability.MountVolume)
          csi.v0.Csi.VolumeCapability.MountVolumeOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_MountVolume_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_MountVolume_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v0.Csi.VolumeCapability.MountVolume.class, csi.v0.Csi.VolumeCapability.MountVolume.Builder.class);
        }

        // Construct using csi.v0.Csi.VolumeCapability.MountVolume.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          fsType_ = "";

          mountFlags_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000002);
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_MountVolume_descriptor;
        }

        @java.lang.Override
        public csi.v0.Csi.VolumeCapability.MountVolume getDefaultInstanceForType() {
          return csi.v0.Csi.VolumeCapability.MountVolume.getDefaultInstance();
        }

        @java.lang.Override
        public csi.v0.Csi.VolumeCapability.MountVolume build() {
          csi.v0.Csi.VolumeCapability.MountVolume result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public csi.v0.Csi.VolumeCapability.MountVolume buildPartial() {
          csi.v0.Csi.VolumeCapability.MountVolume result = new csi.v0.Csi.VolumeCapability.MountVolume(this);
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          result.fsType_ = fsType_;
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            mountFlags_ = mountFlags_.getUnmodifiableView();
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.mountFlags_ = mountFlags_;
          result.bitField0_ = to_bitField0_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return (Builder) super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v0.Csi.VolumeCapability.MountVolume) {
            return mergeFrom((csi.v0.Csi.VolumeCapability.MountVolume)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v0.Csi.VolumeCapability.MountVolume other) {
          if (other == csi.v0.Csi.VolumeCapability.MountVolume.getDefaultInstance()) return this;
          if (!other.getFsType().isEmpty()) {
            fsType_ = other.fsType_;
            onChanged();
          }
          if (!other.mountFlags_.isEmpty()) {
            if (mountFlags_.isEmpty()) {
              mountFlags_ = other.mountFlags_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureMountFlagsIsMutable();
              mountFlags_.addAll(other.mountFlags_);
            }
            onChanged();
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v0.Csi.VolumeCapability.MountVolume parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v0.Csi.VolumeCapability.MountVolume) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }
        private int bitField0_;

        private java.lang.Object fsType_ = "";
        /**
         * <pre>
         * The filesystem type. This field is OPTIONAL.
         * An empty string is equal to an unspecified field value.
         * </pre>
         *
         * <code>string fs_type = 1;</code>
         */
        public java.lang.String getFsType() {
          java.lang.Object ref = fsType_;
          if (!(ref instanceof java.lang.String)) {
            com.google.protobuf.ByteString bs =
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            fsType_ = s;
            return s;
          } else {
            return (java.lang.String) ref;
          }
        }
        /**
         * <pre>
         * The filesystem type. This field is OPTIONAL.
         * An empty string is equal to an unspecified field value.
         * </pre>
         *
         * <code>string fs_type = 1;</code>
         */
        public com.google.protobuf.ByteString
            getFsTypeBytes() {
          java.lang.Object ref = fsType_;
          if (ref instanceof String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            fsType_ = b;
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }
        /**
         * <pre>
         * The filesystem type. This field is OPTIONAL.
         * An empty string is equal to an unspecified field value.
         * </pre>
         *
         * <code>string fs_type = 1;</code>
         */
        public Builder setFsType(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  
          fsType_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The filesystem type. This field is OPTIONAL.
         * An empty string is equal to an unspecified field value.
         * </pre>
         *
         * <code>string fs_type = 1;</code>
         */
        public Builder clearFsType() {
          
          fsType_ = getDefaultInstance().getFsType();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The filesystem type. This field is OPTIONAL.
         * An empty string is equal to an unspecified field value.
         * </pre>
         *
         * <code>string fs_type = 1;</code>
         */
        public Builder setFsTypeBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          
          fsType_ = value;
          onChanged();
          return this;
        }

        private com.google.protobuf.LazyStringList mountFlags_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        private void ensureMountFlagsIsMutable() {
          if (!((bitField0_ & 0x00000002) == 0x00000002)) {
            mountFlags_ = new com.google.protobuf.LazyStringArrayList(mountFlags_);
            bitField0_ |= 0x00000002;
           }
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public com.google.protobuf.ProtocolStringList
            getMountFlagsList() {
          return mountFlags_.getUnmodifiableView();
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public int getMountFlagsCount() {
          return mountFlags_.size();
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public java.lang.String getMountFlags(int index) {
          return mountFlags_.get(index);
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public com.google.protobuf.ByteString
            getMountFlagsBytes(int index) {
          return mountFlags_.getByteString(index);
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public Builder setMountFlags(
            int index, java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureMountFlagsIsMutable();
          mountFlags_.set(index, value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public Builder addMountFlags(
            java.lang.String value) {
          if (value == null) {
    throw new NullPointerException();
  }
  ensureMountFlagsIsMutable();
          mountFlags_.add(value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public Builder addAllMountFlags(
            java.lang.Iterable<java.lang.String> values) {
          ensureMountFlagsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, mountFlags_);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public Builder clearMountFlags() {
          mountFlags_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The mount options that can be used for the volume. This field is
         * OPTIONAL. `mount_flags` MAY contain sensitive information.
         * Therefore, the CO and the Plugin MUST NOT leak this information
         * to untrusted entities. The total size of this repeated field
         * SHALL NOT exceed 4 KiB.
         * </pre>
         *
         * <code>repeated string mount_flags = 2;</code>
         */
        public Builder addMountFlagsBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
          ensureMountFlagsIsMutable();
          mountFlags_.add(value);
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v0.VolumeCapability.MountVolume)
      }

      // @@protoc_insertion_point(class_scope:csi.v0.VolumeCapability.MountVolume)
      private static final csi.v0.Csi.VolumeCapability.MountVolume DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v0.Csi.VolumeCapability.MountVolume();
      }

      public static csi.v0.Csi.VolumeCapability.MountVolume getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<MountVolume>
          PARSER = new com.google.protobuf.AbstractParser<MountVolume>() {
        @java.lang.Override
        public MountVolume parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new MountVolume(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<MountVolume> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<MountVolume> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public csi.v0.Csi.VolumeCapability.MountVolume getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface AccessModeOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v0.VolumeCapability.AccessMode)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability.AccessMode.Mode mode = 1;</code>
       */
      int getModeValue();
      /**
       * <pre>
       * This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability.AccessMode.Mode mode = 1;</code>
       */
      csi.v0.Csi.VolumeCapability.AccessMode.Mode getMode();
    }
    /**
     * <pre>
     * Specify how a volume can be accessed.
     * </pre>
     *
     * Protobuf type {@code csi.v0.VolumeCapability.AccessMode}
     */
    public  static final class AccessMode extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v0.VolumeCapability.AccessMode)
        AccessModeOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use AccessMode.newBuilder() to construct.
      private AccessMode(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private AccessMode() {
        mode_ = 0;
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private AccessMode(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int rawValue = input.readEnum();

                mode_ = rawValue;
                break;
              }
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_AccessMode_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_AccessMode_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.VolumeCapability.AccessMode.class, csi.v0.Csi.VolumeCapability.AccessMode.Builder.class);
      }

      /**
       * Protobuf enum {@code csi.v0.VolumeCapability.AccessMode.Mode}
       */
      public enum Mode
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <code>UNKNOWN = 0;</code>
         */
        UNKNOWN(0),
        /**
         * <pre>
         * Can only be published once as read/write on a single node, at
         * any given time.
         * </pre>
         *
         * <code>SINGLE_NODE_WRITER = 1;</code>
         */
        SINGLE_NODE_WRITER(1),
        /**
         * <pre>
         * Can only be published once as readonly on a single node, at
         * any given time.
         * </pre>
         *
         * <code>SINGLE_NODE_READER_ONLY = 2;</code>
         */
        SINGLE_NODE_READER_ONLY(2),
        /**
         * <pre>
         * Can be published as readonly at multiple nodes simultaneously.
         * </pre>
         *
         * <code>MULTI_NODE_READER_ONLY = 3;</code>
         */
        MULTI_NODE_READER_ONLY(3),
        /**
         * <pre>
         * Can be published at multiple nodes simultaneously. Only one of
         * the node can be used as read/write. The rest will be readonly.
         * </pre>
         *
         * <code>MULTI_NODE_SINGLE_WRITER = 4;</code>
         */
        MULTI_NODE_SINGLE_WRITER(4),
        /**
         * <pre>
         * Can be published as read/write at multiple nodes
         * simultaneously.
         * </pre>
         *
         * <code>MULTI_NODE_MULTI_WRITER = 5;</code>
         */
        MULTI_NODE_MULTI_WRITER(5),
        UNRECOGNIZED(-1),
        ;

        /**
         * <code>UNKNOWN = 0;</code>
         */
        public static final int UNKNOWN_VALUE = 0;
        /**
         * <pre>
         * Can only be published once as read/write on a single node, at
         * any given time.
         * </pre>
         *
         * <code>SINGLE_NODE_WRITER = 1;</code>
         */
        public static final int SINGLE_NODE_WRITER_VALUE = 1;
        /**
         * <pre>
         * Can only be published once as readonly on a single node, at
         * any given time.
         * </pre>
         *
         * <code>SINGLE_NODE_READER_ONLY = 2;</code>
         */
        public static final int SINGLE_NODE_READER_ONLY_VALUE = 2;
        /**
         * <pre>
         * Can be published as readonly at multiple nodes simultaneously.
         * </pre>
         *
         * <code>MULTI_NODE_READER_ONLY = 3;</code>
         */
        public static final int MULTI_NODE_READER_ONLY_VALUE = 3;
        /**
         * <pre>
         * Can be published at multiple nodes simultaneously. Only one of
         * the node can be used as read/write. The rest will be readonly.
         * </pre>
         *
         * <code>MULTI_NODE_SINGLE_WRITER = 4;</code>
         */
        public static final int MULTI_NODE_SINGLE_WRITER_VALUE = 4;
        /**
         * <pre>
         * Can be published as read/write at multiple nodes
         * simultaneously.
         * </pre>
         *
         * <code>MULTI_NODE_MULTI_WRITER = 5;</code>
         */
        public static final int MULTI_NODE_MULTI_WRITER_VALUE = 5;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static Mode valueOf(int value) {
          return forNumber(value);
        }

        public static Mode forNumber(int value) {
          switch (value) {
            case 0: return UNKNOWN;
            case 1: return SINGLE_NODE_WRITER;
            case 2: return SINGLE_NODE_READER_ONLY;
            case 3: return MULTI_NODE_READER_ONLY;
            case 4: return MULTI_NODE_SINGLE_WRITER;
            case 5: return MULTI_NODE_MULTI_WRITER;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<Mode>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            Mode> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Mode>() {
                public Mode findValueByNumber(int number) {
                  return Mode.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return csi.v0.Csi.VolumeCapability.AccessMode.getDescriptor().getEnumTypes().get(0);
        }

        private static final Mode[] VALUES = values();

        public static Mode valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private Mode(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:csi.v0.VolumeCapability.AccessMode.Mode)
      }

      public static final int MODE_FIELD_NUMBER = 1;
      private int mode_;
      /**
       * <pre>
       * This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability.AccessMode.Mode mode = 1;</code>
       */
      public int getModeValue() {
        return mode_;
      }
      /**
       * <pre>
       * This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability.AccessMode.Mode mode = 1;</code>
       */
      public csi.v0.Csi.VolumeCapability.AccessMode.Mode getMode() {
        @SuppressWarnings("deprecation")
        csi.v0.Csi.VolumeCapability.AccessMode.Mode result = csi.v0.Csi.VolumeCapability.AccessMode.Mode.valueOf(mode_);
        return result == null ? csi.v0.Csi.VolumeCapability.AccessMode.Mode.UNRECOGNIZED : result;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (mode_ != csi.v0.Csi.VolumeCapability.AccessMode.Mode.UNKNOWN.getNumber()) {
          output.writeEnum(1, mode_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (mode_ != csi.v0.Csi.VolumeCapability.AccessMode.Mode.UNKNOWN.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(1, mode_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v0.Csi.VolumeCapability.AccessMode)) {
          return super.equals(obj);
        }
        csi.v0.Csi.VolumeCapability.AccessMode other = (csi.v0.Csi.VolumeCapability.AccessMode) obj;

        boolean result = true;
        result = result && mode_ == other.mode_;
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + MODE_FIELD_NUMBER;
        hash = (53 * hash) + mode_;
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v0.Csi.VolumeCapability.AccessMode parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.VolumeCapability.AccessMode parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeCapability.AccessMode parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.VolumeCapability.AccessMode parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeCapability.AccessMode parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.VolumeCapability.AccessMode parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeCapability.AccessMode parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.VolumeCapability.AccessMode parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeCapability.AccessMode parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.VolumeCapability.AccessMode parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.VolumeCapability.AccessMode parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.VolumeCapability.AccessMode parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v0.Csi.VolumeCapability.AccessMode prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Specify how a volume can be accessed.
       * </pre>
       *
       * Protobuf type {@code csi.v0.VolumeCapability.AccessMode}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v0.VolumeCapability.AccessMode)
          csi.v0.Csi.VolumeCapability.AccessModeOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_AccessMode_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_AccessMode_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v0.Csi.VolumeCapability.AccessMode.class, csi.v0.Csi.VolumeCapability.AccessMode.Builder.class);
        }

        // Construct using csi.v0.Csi.VolumeCapability.AccessMode.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          mode_ = 0;

          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_AccessMode_descriptor;
        }

        @java.lang.Override
        public csi.v0.Csi.VolumeCapability.AccessMode getDefaultInstanceForType() {
          return csi.v0.Csi.VolumeCapability.AccessMode.getDefaultInstance();
        }

        @java.lang.Override
        public csi.v0.Csi.VolumeCapability.AccessMode build() {
          csi.v0.Csi.VolumeCapability.AccessMode result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public csi.v0.Csi.VolumeCapability.AccessMode buildPartial() {
          csi.v0.Csi.VolumeCapability.AccessMode result = new csi.v0.Csi.VolumeCapability.AccessMode(this);
          result.mode_ = mode_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return (Builder) super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v0.Csi.VolumeCapability.AccessMode) {
            return mergeFrom((csi.v0.Csi.VolumeCapability.AccessMode)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v0.Csi.VolumeCapability.AccessMode other) {
          if (other == csi.v0.Csi.VolumeCapability.AccessMode.getDefaultInstance()) return this;
          if (other.mode_ != 0) {
            setModeValue(other.getModeValue());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v0.Csi.VolumeCapability.AccessMode parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v0.Csi.VolumeCapability.AccessMode) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private int mode_ = 0;
        /**
         * <pre>
         * This field is REQUIRED.
         * </pre>
         *
         * <code>.csi.v0.VolumeCapability.AccessMode.Mode mode = 1;</code>
         */
        public int getModeValue() {
          return mode_;
        }
        /**
         * <pre>
         * This field is REQUIRED.
         * </pre>
         *
         * <code>.csi.v0.VolumeCapability.AccessMode.Mode mode = 1;</code>
         */
        public Builder setModeValue(int value) {
          mode_ = value;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * This field is REQUIRED.
         * </pre>
         *
         * <code>.csi.v0.VolumeCapability.AccessMode.Mode mode = 1;</code>
         */
        public csi.v0.Csi.VolumeCapability.AccessMode.Mode getMode() {
          @SuppressWarnings("deprecation")
          csi.v0.Csi.VolumeCapability.AccessMode.Mode result = csi.v0.Csi.VolumeCapability.AccessMode.Mode.valueOf(mode_);
          return result == null ? csi.v0.Csi.VolumeCapability.AccessMode.Mode.UNRECOGNIZED : result;
        }
        /**
         * <pre>
         * This field is REQUIRED.
         * </pre>
         *
         * <code>.csi.v0.VolumeCapability.AccessMode.Mode mode = 1;</code>
         */
        public Builder setMode(csi.v0.Csi.VolumeCapability.AccessMode.Mode value) {
          if (value == null) {
            throw new NullPointerException();
          }
          
          mode_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * This field is REQUIRED.
         * </pre>
         *
         * <code>.csi.v0.VolumeCapability.AccessMode.Mode mode = 1;</code>
         */
        public Builder clearMode() {
          
          mode_ = 0;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v0.VolumeCapability.AccessMode)
      }

      // @@protoc_insertion_point(class_scope:csi.v0.VolumeCapability.AccessMode)
      private static final csi.v0.Csi.VolumeCapability.AccessMode DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v0.Csi.VolumeCapability.AccessMode();
      }

      public static csi.v0.Csi.VolumeCapability.AccessMode getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<AccessMode>
          PARSER = new com.google.protobuf.AbstractParser<AccessMode>() {
        @java.lang.Override
        public AccessMode parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new AccessMode(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<AccessMode> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<AccessMode> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public csi.v0.Csi.VolumeCapability.AccessMode getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int accessTypeCase_ = 0;
    private java.lang.Object accessType_;
    public enum AccessTypeCase
        implements com.google.protobuf.Internal.EnumLite {
      BLOCK(1),
      MOUNT(2),
      ACCESSTYPE_NOT_SET(0);
      private final int value;
      private AccessTypeCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static AccessTypeCase valueOf(int value) {
        return forNumber(value);
      }

      public static AccessTypeCase forNumber(int value) {
        switch (value) {
          case 1: return BLOCK;
          case 2: return MOUNT;
          case 0: return ACCESSTYPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public AccessTypeCase
    getAccessTypeCase() {
      return AccessTypeCase.forNumber(
          accessTypeCase_);
    }

    public static final int BLOCK_FIELD_NUMBER = 1;
    /**
     * <code>.csi.v0.VolumeCapability.BlockVolume block = 1;</code>
     */
    public boolean hasBlock() {
      return accessTypeCase_ == 1;
    }
    /**
     * <code>.csi.v0.VolumeCapability.BlockVolume block = 1;</code>
     */
    public csi.v0.Csi.VolumeCapability.BlockVolume getBlock() {
      if (accessTypeCase_ == 1) {
         return (csi.v0.Csi.VolumeCapability.BlockVolume) accessType_;
      }
      return csi.v0.Csi.VolumeCapability.BlockVolume.getDefaultInstance();
    }
    /**
     * <code>.csi.v0.VolumeCapability.BlockVolume block = 1;</code>
     */
    public csi.v0.Csi.VolumeCapability.BlockVolumeOrBuilder getBlockOrBuilder() {
      if (accessTypeCase_ == 1) {
         return (csi.v0.Csi.VolumeCapability.BlockVolume) accessType_;
      }
      return csi.v0.Csi.VolumeCapability.BlockVolume.getDefaultInstance();
    }

    public static final int MOUNT_FIELD_NUMBER = 2;
    /**
     * <code>.csi.v0.VolumeCapability.MountVolume mount = 2;</code>
     */
    public boolean hasMount() {
      return accessTypeCase_ == 2;
    }
    /**
     * <code>.csi.v0.VolumeCapability.MountVolume mount = 2;</code>
     */
    public csi.v0.Csi.VolumeCapability.MountVolume getMount() {
      if (accessTypeCase_ == 2) {
         return (csi.v0.Csi.VolumeCapability.MountVolume) accessType_;
      }
      return csi.v0.Csi.VolumeCapability.MountVolume.getDefaultInstance();
    }
    /**
     * <code>.csi.v0.VolumeCapability.MountVolume mount = 2;</code>
     */
    public csi.v0.Csi.VolumeCapability.MountVolumeOrBuilder getMountOrBuilder() {
      if (accessTypeCase_ == 2) {
         return (csi.v0.Csi.VolumeCapability.MountVolume) accessType_;
      }
      return csi.v0.Csi.VolumeCapability.MountVolume.getDefaultInstance();
    }

    public static final int ACCESS_MODE_FIELD_NUMBER = 3;
    private csi.v0.Csi.VolumeCapability.AccessMode accessMode_;
    /**
     * <pre>
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability.AccessMode access_mode = 3;</code>
     */
    public boolean hasAccessMode() {
      return accessMode_ != null;
    }
    /**
     * <pre>
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability.AccessMode access_mode = 3;</code>
     */
    public csi.v0.Csi.VolumeCapability.AccessMode getAccessMode() {
      return accessMode_ == null ? csi.v0.Csi.VolumeCapability.AccessMode.getDefaultInstance() : accessMode_;
    }
    /**
     * <pre>
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability.AccessMode access_mode = 3;</code>
     */
    public csi.v0.Csi.VolumeCapability.AccessModeOrBuilder getAccessModeOrBuilder() {
      return getAccessMode();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (accessTypeCase_ == 1) {
        output.writeMessage(1, (csi.v0.Csi.VolumeCapability.BlockVolume) accessType_);
      }
      if (accessTypeCase_ == 2) {
        output.writeMessage(2, (csi.v0.Csi.VolumeCapability.MountVolume) accessType_);
      }
      if (accessMode_ != null) {
        output.writeMessage(3, getAccessMode());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (accessTypeCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, (csi.v0.Csi.VolumeCapability.BlockVolume) accessType_);
      }
      if (accessTypeCase_ == 2) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, (csi.v0.Csi.VolumeCapability.MountVolume) accessType_);
      }
      if (accessMode_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getAccessMode());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.VolumeCapability)) {
        return super.equals(obj);
      }
      csi.v0.Csi.VolumeCapability other = (csi.v0.Csi.VolumeCapability) obj;

      boolean result = true;
      result = result && (hasAccessMode() == other.hasAccessMode());
      if (hasAccessMode()) {
        result = result && getAccessMode()
            .equals(other.getAccessMode());
      }
      result = result && getAccessTypeCase().equals(
          other.getAccessTypeCase());
      if (!result) return false;
      switch (accessTypeCase_) {
        case 1:
          result = result && getBlock()
              .equals(other.getBlock());
          break;
        case 2:
          result = result && getMount()
              .equals(other.getMount());
          break;
        case 0:
        default:
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasAccessMode()) {
        hash = (37 * hash) + ACCESS_MODE_FIELD_NUMBER;
        hash = (53 * hash) + getAccessMode().hashCode();
      }
      switch (accessTypeCase_) {
        case 1:
          hash = (37 * hash) + BLOCK_FIELD_NUMBER;
          hash = (53 * hash) + getBlock().hashCode();
          break;
        case 2:
          hash = (37 * hash) + MOUNT_FIELD_NUMBER;
          hash = (53 * hash) + getMount().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.VolumeCapability parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.VolumeCapability parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.VolumeCapability parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.VolumeCapability parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.VolumeCapability parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.VolumeCapability parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.VolumeCapability parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.VolumeCapability parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.VolumeCapability parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.VolumeCapability parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.VolumeCapability parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.VolumeCapability parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.VolumeCapability prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specify a capability of a volume.
     * </pre>
     *
     * Protobuf type {@code csi.v0.VolumeCapability}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.VolumeCapability)
        csi.v0.Csi.VolumeCapabilityOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.VolumeCapability.class, csi.v0.Csi.VolumeCapability.Builder.class);
      }

      // Construct using csi.v0.Csi.VolumeCapability.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (accessModeBuilder_ == null) {
          accessMode_ = null;
        } else {
          accessMode_ = null;
          accessModeBuilder_ = null;
        }
        accessTypeCase_ = 0;
        accessType_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_VolumeCapability_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.VolumeCapability getDefaultInstanceForType() {
        return csi.v0.Csi.VolumeCapability.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.VolumeCapability build() {
        csi.v0.Csi.VolumeCapability result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.VolumeCapability buildPartial() {
        csi.v0.Csi.VolumeCapability result = new csi.v0.Csi.VolumeCapability(this);
        if (accessTypeCase_ == 1) {
          if (blockBuilder_ == null) {
            result.accessType_ = accessType_;
          } else {
            result.accessType_ = blockBuilder_.build();
          }
        }
        if (accessTypeCase_ == 2) {
          if (mountBuilder_ == null) {
            result.accessType_ = accessType_;
          } else {
            result.accessType_ = mountBuilder_.build();
          }
        }
        if (accessModeBuilder_ == null) {
          result.accessMode_ = accessMode_;
        } else {
          result.accessMode_ = accessModeBuilder_.build();
        }
        result.accessTypeCase_ = accessTypeCase_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.VolumeCapability) {
          return mergeFrom((csi.v0.Csi.VolumeCapability)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.VolumeCapability other) {
        if (other == csi.v0.Csi.VolumeCapability.getDefaultInstance()) return this;
        if (other.hasAccessMode()) {
          mergeAccessMode(other.getAccessMode());
        }
        switch (other.getAccessTypeCase()) {
          case BLOCK: {
            mergeBlock(other.getBlock());
            break;
          }
          case MOUNT: {
            mergeMount(other.getMount());
            break;
          }
          case ACCESSTYPE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.VolumeCapability parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.VolumeCapability) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int accessTypeCase_ = 0;
      private java.lang.Object accessType_;
      public AccessTypeCase
          getAccessTypeCase() {
        return AccessTypeCase.forNumber(
            accessTypeCase_);
      }

      public Builder clearAccessType() {
        accessTypeCase_ = 0;
        accessType_ = null;
        onChanged();
        return this;
      }


      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeCapability.BlockVolume, csi.v0.Csi.VolumeCapability.BlockVolume.Builder, csi.v0.Csi.VolumeCapability.BlockVolumeOrBuilder> blockBuilder_;
      /**
       * <code>.csi.v0.VolumeCapability.BlockVolume block = 1;</code>
       */
      public boolean hasBlock() {
        return accessTypeCase_ == 1;
      }
      /**
       * <code>.csi.v0.VolumeCapability.BlockVolume block = 1;</code>
       */
      public csi.v0.Csi.VolumeCapability.BlockVolume getBlock() {
        if (blockBuilder_ == null) {
          if (accessTypeCase_ == 1) {
            return (csi.v0.Csi.VolumeCapability.BlockVolume) accessType_;
          }
          return csi.v0.Csi.VolumeCapability.BlockVolume.getDefaultInstance();
        } else {
          if (accessTypeCase_ == 1) {
            return blockBuilder_.getMessage();
          }
          return csi.v0.Csi.VolumeCapability.BlockVolume.getDefaultInstance();
        }
      }
      /**
       * <code>.csi.v0.VolumeCapability.BlockVolume block = 1;</code>
       */
      public Builder setBlock(csi.v0.Csi.VolumeCapability.BlockVolume value) {
        if (blockBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          accessType_ = value;
          onChanged();
        } else {
          blockBuilder_.setMessage(value);
        }
        accessTypeCase_ = 1;
        return this;
      }
      /**
       * <code>.csi.v0.VolumeCapability.BlockVolume block = 1;</code>
       */
      public Builder setBlock(
          csi.v0.Csi.VolumeCapability.BlockVolume.Builder builderForValue) {
        if (blockBuilder_ == null) {
          accessType_ = builderForValue.build();
          onChanged();
        } else {
          blockBuilder_.setMessage(builderForValue.build());
        }
        accessTypeCase_ = 1;
        return this;
      }
      /**
       * <code>.csi.v0.VolumeCapability.BlockVolume block = 1;</code>
       */
      public Builder mergeBlock(csi.v0.Csi.VolumeCapability.BlockVolume value) {
        if (blockBuilder_ == null) {
          if (accessTypeCase_ == 1 &&
              accessType_ != csi.v0.Csi.VolumeCapability.BlockVolume.getDefaultInstance()) {
            accessType_ = csi.v0.Csi.VolumeCapability.BlockVolume.newBuilder((csi.v0.Csi.VolumeCapability.BlockVolume) accessType_)
                .mergeFrom(value).buildPartial();
          } else {
            accessType_ = value;
          }
          onChanged();
        } else {
          if (accessTypeCase_ == 1) {
            blockBuilder_.mergeFrom(value);
          }
          blockBuilder_.setMessage(value);
        }
        accessTypeCase_ = 1;
        return this;
      }
      /**
       * <code>.csi.v0.VolumeCapability.BlockVolume block = 1;</code>
       */
      public Builder clearBlock() {
        if (blockBuilder_ == null) {
          if (accessTypeCase_ == 1) {
            accessTypeCase_ = 0;
            accessType_ = null;
            onChanged();
          }
        } else {
          if (accessTypeCase_ == 1) {
            accessTypeCase_ = 0;
            accessType_ = null;
          }
          blockBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.csi.v0.VolumeCapability.BlockVolume block = 1;</code>
       */
      public csi.v0.Csi.VolumeCapability.BlockVolume.Builder getBlockBuilder() {
        return getBlockFieldBuilder().getBuilder();
      }
      /**
       * <code>.csi.v0.VolumeCapability.BlockVolume block = 1;</code>
       */
      public csi.v0.Csi.VolumeCapability.BlockVolumeOrBuilder getBlockOrBuilder() {
        if ((accessTypeCase_ == 1) && (blockBuilder_ != null)) {
          return blockBuilder_.getMessageOrBuilder();
        } else {
          if (accessTypeCase_ == 1) {
            return (csi.v0.Csi.VolumeCapability.BlockVolume) accessType_;
          }
          return csi.v0.Csi.VolumeCapability.BlockVolume.getDefaultInstance();
        }
      }
      /**
       * <code>.csi.v0.VolumeCapability.BlockVolume block = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeCapability.BlockVolume, csi.v0.Csi.VolumeCapability.BlockVolume.Builder, csi.v0.Csi.VolumeCapability.BlockVolumeOrBuilder> 
          getBlockFieldBuilder() {
        if (blockBuilder_ == null) {
          if (!(accessTypeCase_ == 1)) {
            accessType_ = csi.v0.Csi.VolumeCapability.BlockVolume.getDefaultInstance();
          }
          blockBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.VolumeCapability.BlockVolume, csi.v0.Csi.VolumeCapability.BlockVolume.Builder, csi.v0.Csi.VolumeCapability.BlockVolumeOrBuilder>(
                  (csi.v0.Csi.VolumeCapability.BlockVolume) accessType_,
                  getParentForChildren(),
                  isClean());
          accessType_ = null;
        }
        accessTypeCase_ = 1;
        onChanged();;
        return blockBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeCapability.MountVolume, csi.v0.Csi.VolumeCapability.MountVolume.Builder, csi.v0.Csi.VolumeCapability.MountVolumeOrBuilder> mountBuilder_;
      /**
       * <code>.csi.v0.VolumeCapability.MountVolume mount = 2;</code>
       */
      public boolean hasMount() {
        return accessTypeCase_ == 2;
      }
      /**
       * <code>.csi.v0.VolumeCapability.MountVolume mount = 2;</code>
       */
      public csi.v0.Csi.VolumeCapability.MountVolume getMount() {
        if (mountBuilder_ == null) {
          if (accessTypeCase_ == 2) {
            return (csi.v0.Csi.VolumeCapability.MountVolume) accessType_;
          }
          return csi.v0.Csi.VolumeCapability.MountVolume.getDefaultInstance();
        } else {
          if (accessTypeCase_ == 2) {
            return mountBuilder_.getMessage();
          }
          return csi.v0.Csi.VolumeCapability.MountVolume.getDefaultInstance();
        }
      }
      /**
       * <code>.csi.v0.VolumeCapability.MountVolume mount = 2;</code>
       */
      public Builder setMount(csi.v0.Csi.VolumeCapability.MountVolume value) {
        if (mountBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          accessType_ = value;
          onChanged();
        } else {
          mountBuilder_.setMessage(value);
        }
        accessTypeCase_ = 2;
        return this;
      }
      /**
       * <code>.csi.v0.VolumeCapability.MountVolume mount = 2;</code>
       */
      public Builder setMount(
          csi.v0.Csi.VolumeCapability.MountVolume.Builder builderForValue) {
        if (mountBuilder_ == null) {
          accessType_ = builderForValue.build();
          onChanged();
        } else {
          mountBuilder_.setMessage(builderForValue.build());
        }
        accessTypeCase_ = 2;
        return this;
      }
      /**
       * <code>.csi.v0.VolumeCapability.MountVolume mount = 2;</code>
       */
      public Builder mergeMount(csi.v0.Csi.VolumeCapability.MountVolume value) {
        if (mountBuilder_ == null) {
          if (accessTypeCase_ == 2 &&
              accessType_ != csi.v0.Csi.VolumeCapability.MountVolume.getDefaultInstance()) {
            accessType_ = csi.v0.Csi.VolumeCapability.MountVolume.newBuilder((csi.v0.Csi.VolumeCapability.MountVolume) accessType_)
                .mergeFrom(value).buildPartial();
          } else {
            accessType_ = value;
          }
          onChanged();
        } else {
          if (accessTypeCase_ == 2) {
            mountBuilder_.mergeFrom(value);
          }
          mountBuilder_.setMessage(value);
        }
        accessTypeCase_ = 2;
        return this;
      }
      /**
       * <code>.csi.v0.VolumeCapability.MountVolume mount = 2;</code>
       */
      public Builder clearMount() {
        if (mountBuilder_ == null) {
          if (accessTypeCase_ == 2) {
            accessTypeCase_ = 0;
            accessType_ = null;
            onChanged();
          }
        } else {
          if (accessTypeCase_ == 2) {
            accessTypeCase_ = 0;
            accessType_ = null;
          }
          mountBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.csi.v0.VolumeCapability.MountVolume mount = 2;</code>
       */
      public csi.v0.Csi.VolumeCapability.MountVolume.Builder getMountBuilder() {
        return getMountFieldBuilder().getBuilder();
      }
      /**
       * <code>.csi.v0.VolumeCapability.MountVolume mount = 2;</code>
       */
      public csi.v0.Csi.VolumeCapability.MountVolumeOrBuilder getMountOrBuilder() {
        if ((accessTypeCase_ == 2) && (mountBuilder_ != null)) {
          return mountBuilder_.getMessageOrBuilder();
        } else {
          if (accessTypeCase_ == 2) {
            return (csi.v0.Csi.VolumeCapability.MountVolume) accessType_;
          }
          return csi.v0.Csi.VolumeCapability.MountVolume.getDefaultInstance();
        }
      }
      /**
       * <code>.csi.v0.VolumeCapability.MountVolume mount = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeCapability.MountVolume, csi.v0.Csi.VolumeCapability.MountVolume.Builder, csi.v0.Csi.VolumeCapability.MountVolumeOrBuilder> 
          getMountFieldBuilder() {
        if (mountBuilder_ == null) {
          if (!(accessTypeCase_ == 2)) {
            accessType_ = csi.v0.Csi.VolumeCapability.MountVolume.getDefaultInstance();
          }
          mountBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.VolumeCapability.MountVolume, csi.v0.Csi.VolumeCapability.MountVolume.Builder, csi.v0.Csi.VolumeCapability.MountVolumeOrBuilder>(
                  (csi.v0.Csi.VolumeCapability.MountVolume) accessType_,
                  getParentForChildren(),
                  isClean());
          accessType_ = null;
        }
        accessTypeCase_ = 2;
        onChanged();;
        return mountBuilder_;
      }

      private csi.v0.Csi.VolumeCapability.AccessMode accessMode_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeCapability.AccessMode, csi.v0.Csi.VolumeCapability.AccessMode.Builder, csi.v0.Csi.VolumeCapability.AccessModeOrBuilder> accessModeBuilder_;
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      public boolean hasAccessMode() {
        return accessModeBuilder_ != null || accessMode_ != null;
      }
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      public csi.v0.Csi.VolumeCapability.AccessMode getAccessMode() {
        if (accessModeBuilder_ == null) {
          return accessMode_ == null ? csi.v0.Csi.VolumeCapability.AccessMode.getDefaultInstance() : accessMode_;
        } else {
          return accessModeBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      public Builder setAccessMode(csi.v0.Csi.VolumeCapability.AccessMode value) {
        if (accessModeBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          accessMode_ = value;
          onChanged();
        } else {
          accessModeBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      public Builder setAccessMode(
          csi.v0.Csi.VolumeCapability.AccessMode.Builder builderForValue) {
        if (accessModeBuilder_ == null) {
          accessMode_ = builderForValue.build();
          onChanged();
        } else {
          accessModeBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      public Builder mergeAccessMode(csi.v0.Csi.VolumeCapability.AccessMode value) {
        if (accessModeBuilder_ == null) {
          if (accessMode_ != null) {
            accessMode_ =
              csi.v0.Csi.VolumeCapability.AccessMode.newBuilder(accessMode_).mergeFrom(value).buildPartial();
          } else {
            accessMode_ = value;
          }
          onChanged();
        } else {
          accessModeBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      public Builder clearAccessMode() {
        if (accessModeBuilder_ == null) {
          accessMode_ = null;
          onChanged();
        } else {
          accessMode_ = null;
          accessModeBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      public csi.v0.Csi.VolumeCapability.AccessMode.Builder getAccessModeBuilder() {
        
        onChanged();
        return getAccessModeFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      public csi.v0.Csi.VolumeCapability.AccessModeOrBuilder getAccessModeOrBuilder() {
        if (accessModeBuilder_ != null) {
          return accessModeBuilder_.getMessageOrBuilder();
        } else {
          return accessMode_ == null ?
              csi.v0.Csi.VolumeCapability.AccessMode.getDefaultInstance() : accessMode_;
        }
      }
      /**
       * <pre>
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability.AccessMode access_mode = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeCapability.AccessMode, csi.v0.Csi.VolumeCapability.AccessMode.Builder, csi.v0.Csi.VolumeCapability.AccessModeOrBuilder> 
          getAccessModeFieldBuilder() {
        if (accessModeBuilder_ == null) {
          accessModeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.VolumeCapability.AccessMode, csi.v0.Csi.VolumeCapability.AccessMode.Builder, csi.v0.Csi.VolumeCapability.AccessModeOrBuilder>(
                  getAccessMode(),
                  getParentForChildren(),
                  isClean());
          accessMode_ = null;
        }
        return accessModeBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.VolumeCapability)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.VolumeCapability)
    private static final csi.v0.Csi.VolumeCapability DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.VolumeCapability();
    }

    public static csi.v0.Csi.VolumeCapability getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<VolumeCapability>
        PARSER = new com.google.protobuf.AbstractParser<VolumeCapability>() {
      @java.lang.Override
      public VolumeCapability parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new VolumeCapability(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<VolumeCapability> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VolumeCapability> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.VolumeCapability getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CapacityRangeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.CapacityRange)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Volume MUST be at least this big. This field is OPTIONAL.
     * A value of 0 is equal to an unspecified field value.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 required_bytes = 1;</code>
     */
    long getRequiredBytes();

    /**
     * <pre>
     * Volume MUST not be bigger than this. This field is OPTIONAL.
     * A value of 0 is equal to an unspecified field value.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 limit_bytes = 2;</code>
     */
    long getLimitBytes();
  }
  /**
   * <pre>
   * The capacity of the storage space in bytes. To specify an exact size,
   * `required_bytes` and `limit_bytes` SHALL be set to the same value. At
   * least one of the these fields MUST be specified.
   * </pre>
   *
   * Protobuf type {@code csi.v0.CapacityRange}
   */
  public  static final class CapacityRange extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.CapacityRange)
      CapacityRangeOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CapacityRange.newBuilder() to construct.
    private CapacityRange(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CapacityRange() {
      requiredBytes_ = 0L;
      limitBytes_ = 0L;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CapacityRange(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {

              requiredBytes_ = input.readInt64();
              break;
            }
            case 16: {

              limitBytes_ = input.readInt64();
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_CapacityRange_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_CapacityRange_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.CapacityRange.class, csi.v0.Csi.CapacityRange.Builder.class);
    }

    public static final int REQUIRED_BYTES_FIELD_NUMBER = 1;
    private long requiredBytes_;
    /**
     * <pre>
     * Volume MUST be at least this big. This field is OPTIONAL.
     * A value of 0 is equal to an unspecified field value.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 required_bytes = 1;</code>
     */
    public long getRequiredBytes() {
      return requiredBytes_;
    }

    public static final int LIMIT_BYTES_FIELD_NUMBER = 2;
    private long limitBytes_;
    /**
     * <pre>
     * Volume MUST not be bigger than this. This field is OPTIONAL.
     * A value of 0 is equal to an unspecified field value.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 limit_bytes = 2;</code>
     */
    public long getLimitBytes() {
      return limitBytes_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (requiredBytes_ != 0L) {
        output.writeInt64(1, requiredBytes_);
      }
      if (limitBytes_ != 0L) {
        output.writeInt64(2, limitBytes_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (requiredBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, requiredBytes_);
      }
      if (limitBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, limitBytes_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.CapacityRange)) {
        return super.equals(obj);
      }
      csi.v0.Csi.CapacityRange other = (csi.v0.Csi.CapacityRange) obj;

      boolean result = true;
      result = result && (getRequiredBytes()
          == other.getRequiredBytes());
      result = result && (getLimitBytes()
          == other.getLimitBytes());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + REQUIRED_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getRequiredBytes());
      hash = (37 * hash) + LIMIT_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getLimitBytes());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.CapacityRange parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.CapacityRange parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.CapacityRange parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.CapacityRange parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.CapacityRange parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.CapacityRange parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.CapacityRange parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.CapacityRange parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.CapacityRange parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.CapacityRange parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.CapacityRange parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.CapacityRange parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.CapacityRange prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The capacity of the storage space in bytes. To specify an exact size,
     * `required_bytes` and `limit_bytes` SHALL be set to the same value. At
     * least one of the these fields MUST be specified.
     * </pre>
     *
     * Protobuf type {@code csi.v0.CapacityRange}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.CapacityRange)
        csi.v0.Csi.CapacityRangeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_CapacityRange_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_CapacityRange_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.CapacityRange.class, csi.v0.Csi.CapacityRange.Builder.class);
      }

      // Construct using csi.v0.Csi.CapacityRange.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        requiredBytes_ = 0L;

        limitBytes_ = 0L;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_CapacityRange_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.CapacityRange getDefaultInstanceForType() {
        return csi.v0.Csi.CapacityRange.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.CapacityRange build() {
        csi.v0.Csi.CapacityRange result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.CapacityRange buildPartial() {
        csi.v0.Csi.CapacityRange result = new csi.v0.Csi.CapacityRange(this);
        result.requiredBytes_ = requiredBytes_;
        result.limitBytes_ = limitBytes_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.CapacityRange) {
          return mergeFrom((csi.v0.Csi.CapacityRange)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.CapacityRange other) {
        if (other == csi.v0.Csi.CapacityRange.getDefaultInstance()) return this;
        if (other.getRequiredBytes() != 0L) {
          setRequiredBytes(other.getRequiredBytes());
        }
        if (other.getLimitBytes() != 0L) {
          setLimitBytes(other.getLimitBytes());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.CapacityRange parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.CapacityRange) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private long requiredBytes_ ;
      /**
       * <pre>
       * Volume MUST be at least this big. This field is OPTIONAL.
       * A value of 0 is equal to an unspecified field value.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 required_bytes = 1;</code>
       */
      public long getRequiredBytes() {
        return requiredBytes_;
      }
      /**
       * <pre>
       * Volume MUST be at least this big. This field is OPTIONAL.
       * A value of 0 is equal to an unspecified field value.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 required_bytes = 1;</code>
       */
      public Builder setRequiredBytes(long value) {
        
        requiredBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Volume MUST be at least this big. This field is OPTIONAL.
       * A value of 0 is equal to an unspecified field value.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 required_bytes = 1;</code>
       */
      public Builder clearRequiredBytes() {
        
        requiredBytes_ = 0L;
        onChanged();
        return this;
      }

      private long limitBytes_ ;
      /**
       * <pre>
       * Volume MUST not be bigger than this. This field is OPTIONAL.
       * A value of 0 is equal to an unspecified field value.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 limit_bytes = 2;</code>
       */
      public long getLimitBytes() {
        return limitBytes_;
      }
      /**
       * <pre>
       * Volume MUST not be bigger than this. This field is OPTIONAL.
       * A value of 0 is equal to an unspecified field value.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 limit_bytes = 2;</code>
       */
      public Builder setLimitBytes(long value) {
        
        limitBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Volume MUST not be bigger than this. This field is OPTIONAL.
       * A value of 0 is equal to an unspecified field value.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 limit_bytes = 2;</code>
       */
      public Builder clearLimitBytes() {
        
        limitBytes_ = 0L;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.CapacityRange)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.CapacityRange)
    private static final csi.v0.Csi.CapacityRange DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.CapacityRange();
    }

    public static csi.v0.Csi.CapacityRange getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CapacityRange>
        PARSER = new com.google.protobuf.AbstractParser<CapacityRange>() {
      @java.lang.Override
      public CapacityRange parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CapacityRange(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CapacityRange> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CapacityRange> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.CapacityRange getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VolumeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.Volume)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The capacity of the volume in bytes. This field is OPTIONAL. If not
     * set (value of 0), it indicates that the capacity of the volume is
     * unknown (e.g., NFS share).
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 capacity_bytes = 1;</code>
     */
    long getCapacityBytes();

    /**
     * <pre>
     * Contains identity information for the created volume. This field is
     * REQUIRED. The identity information will be used by the CO in
     * subsequent calls to refer to the provisioned volume.
     * </pre>
     *
     * <code>string id = 2;</code>
     */
    java.lang.String getId();
    /**
     * <pre>
     * Contains identity information for the created volume. This field is
     * REQUIRED. The identity information will be used by the CO in
     * subsequent calls to refer to the provisioned volume.
     * </pre>
     *
     * <code>string id = 2;</code>
     */
    com.google.protobuf.ByteString
        getIdBytes();

    /**
     * <pre>
     * Attributes reflect static properties of a volume and MUST be passed
     * to volume validation and publishing calls.
     * Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
     * and SHALL be safe for the CO to cache. Attributes SHOULD NOT
     * contain sensitive information. Attributes MAY NOT uniquely identify
     * a volume. A volume uniquely identified by `id` SHALL always report
     * the same attributes. This field is OPTIONAL and when present MUST
     * be passed to volume validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attributes = 3;</code>
     */
    int getAttributesCount();
    /**
     * <pre>
     * Attributes reflect static properties of a volume and MUST be passed
     * to volume validation and publishing calls.
     * Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
     * and SHALL be safe for the CO to cache. Attributes SHOULD NOT
     * contain sensitive information. Attributes MAY NOT uniquely identify
     * a volume. A volume uniquely identified by `id` SHALL always report
     * the same attributes. This field is OPTIONAL and when present MUST
     * be passed to volume validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attributes = 3;</code>
     */
    boolean containsAttributes(
        java.lang.String key);
    /**
     * Use {@link #getAttributesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getAttributes();
    /**
     * <pre>
     * Attributes reflect static properties of a volume and MUST be passed
     * to volume validation and publishing calls.
     * Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
     * and SHALL be safe for the CO to cache. Attributes SHOULD NOT
     * contain sensitive information. Attributes MAY NOT uniquely identify
     * a volume. A volume uniquely identified by `id` SHALL always report
     * the same attributes. This field is OPTIONAL and when present MUST
     * be passed to volume validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attributes = 3;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getAttributesMap();
    /**
     * <pre>
     * Attributes reflect static properties of a volume and MUST be passed
     * to volume validation and publishing calls.
     * Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
     * and SHALL be safe for the CO to cache. Attributes SHOULD NOT
     * contain sensitive information. Attributes MAY NOT uniquely identify
     * a volume. A volume uniquely identified by `id` SHALL always report
     * the same attributes. This field is OPTIONAL and when present MUST
     * be passed to volume validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attributes = 3;</code>
     */

    java.lang.String getAttributesOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Attributes reflect static properties of a volume and MUST be passed
     * to volume validation and publishing calls.
     * Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
     * and SHALL be safe for the CO to cache. Attributes SHOULD NOT
     * contain sensitive information. Attributes MAY NOT uniquely identify
     * a volume. A volume uniquely identified by `id` SHALL always report
     * the same attributes. This field is OPTIONAL and when present MUST
     * be passed to volume validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attributes = 3;</code>
     */

    java.lang.String getAttributesOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * If specified, indicates that the volume is not empty and is
     * pre-populated with data from the specified source.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v0.VolumeContentSource content_source = 4;</code>
     */
    boolean hasContentSource();
    /**
     * <pre>
     * If specified, indicates that the volume is not empty and is
     * pre-populated with data from the specified source.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v0.VolumeContentSource content_source = 4;</code>
     */
    csi.v0.Csi.VolumeContentSource getContentSource();
    /**
     * <pre>
     * If specified, indicates that the volume is not empty and is
     * pre-populated with data from the specified source.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v0.VolumeContentSource content_source = 4;</code>
     */
    csi.v0.Csi.VolumeContentSourceOrBuilder getContentSourceOrBuilder();

    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * may schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
     */
    java.util.List<csi.v0.Csi.Topology> 
        getAccessibleTopologyList();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * may schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
     */
    csi.v0.Csi.Topology getAccessibleTopology(int index);
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * may schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
     */
    int getAccessibleTopologyCount();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * may schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
     */
    java.util.List<? extends csi.v0.Csi.TopologyOrBuilder> 
        getAccessibleTopologyOrBuilderList();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * may schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
     */
    csi.v0.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder(
        int index);
  }
  /**
   * <pre>
   * The information about a provisioned volume.
   * </pre>
   *
   * Protobuf type {@code csi.v0.Volume}
   */
  public  static final class Volume extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.Volume)
      VolumeOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Volume.newBuilder() to construct.
    private Volume(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Volume() {
      capacityBytes_ = 0L;
      id_ = "";
      accessibleTopology_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Volume(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {

              capacityBytes_ = input.readInt64();
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              id_ = s;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                attributes_ = com.google.protobuf.MapField.newMapField(
                    AttributesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000004;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              attributes__ = input.readMessage(
                  AttributesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              attributes_.getMutableMap().put(
                  attributes__.getKey(), attributes__.getValue());
              break;
            }
            case 34: {
              csi.v0.Csi.VolumeContentSource.Builder subBuilder = null;
              if (contentSource_ != null) {
                subBuilder = contentSource_.toBuilder();
              }
              contentSource_ = input.readMessage(csi.v0.Csi.VolumeContentSource.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(contentSource_);
                contentSource_ = subBuilder.buildPartial();
              }

              break;
            }
            case 42: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                accessibleTopology_ = new java.util.ArrayList<csi.v0.Csi.Topology>();
                mutable_bitField0_ |= 0x00000010;
              }
              accessibleTopology_.add(
                  input.readMessage(csi.v0.Csi.Topology.parser(), extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
          accessibleTopology_ = java.util.Collections.unmodifiableList(accessibleTopology_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_Volume_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 3:
          return internalGetAttributes();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_Volume_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.Volume.class, csi.v0.Csi.Volume.Builder.class);
    }

    private int bitField0_;
    public static final int CAPACITY_BYTES_FIELD_NUMBER = 1;
    private long capacityBytes_;
    /**
     * <pre>
     * The capacity of the volume in bytes. This field is OPTIONAL. If not
     * set (value of 0), it indicates that the capacity of the volume is
     * unknown (e.g., NFS share).
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 capacity_bytes = 1;</code>
     */
    public long getCapacityBytes() {
      return capacityBytes_;
    }

    public static final int ID_FIELD_NUMBER = 2;
    private volatile java.lang.Object id_;
    /**
     * <pre>
     * Contains identity information for the created volume. This field is
     * REQUIRED. The identity information will be used by the CO in
     * subsequent calls to refer to the provisioned volume.
     * </pre>
     *
     * <code>string id = 2;</code>
     */
    public java.lang.String getId() {
      java.lang.Object ref = id_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        id_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Contains identity information for the created volume. This field is
     * REQUIRED. The identity information will be used by the CO in
     * subsequent calls to refer to the provisioned volume.
     * </pre>
     *
     * <code>string id = 2;</code>
     */
    public com.google.protobuf.ByteString
        getIdBytes() {
      java.lang.Object ref = id_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        id_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ATTRIBUTES_FIELD_NUMBER = 3;
    private static final class AttributesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_Volume_AttributesEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> attributes_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetAttributes() {
      if (attributes_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            AttributesDefaultEntryHolder.defaultEntry);
      }
      return attributes_;
    }

    public int getAttributesCount() {
      return internalGetAttributes().getMap().size();
    }
    /**
     * <pre>
     * Attributes reflect static properties of a volume and MUST be passed
     * to volume validation and publishing calls.
     * Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
     * and SHALL be safe for the CO to cache. Attributes SHOULD NOT
     * contain sensitive information. Attributes MAY NOT uniquely identify
     * a volume. A volume uniquely identified by `id` SHALL always report
     * the same attributes. This field is OPTIONAL and when present MUST
     * be passed to volume validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attributes = 3;</code>
     */

    public boolean containsAttributes(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetAttributes().getMap().containsKey(key);
    }
    /**
     * Use {@link #getAttributesMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getAttributes() {
      return getAttributesMap();
    }
    /**
     * <pre>
     * Attributes reflect static properties of a volume and MUST be passed
     * to volume validation and publishing calls.
     * Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
     * and SHALL be safe for the CO to cache. Attributes SHOULD NOT
     * contain sensitive information. Attributes MAY NOT uniquely identify
     * a volume. A volume uniquely identified by `id` SHALL always report
     * the same attributes. This field is OPTIONAL and when present MUST
     * be passed to volume validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attributes = 3;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getAttributesMap() {
      return internalGetAttributes().getMap();
    }
    /**
     * <pre>
     * Attributes reflect static properties of a volume and MUST be passed
     * to volume validation and publishing calls.
     * Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
     * and SHALL be safe for the CO to cache. Attributes SHOULD NOT
     * contain sensitive information. Attributes MAY NOT uniquely identify
     * a volume. A volume uniquely identified by `id` SHALL always report
     * the same attributes. This field is OPTIONAL and when present MUST
     * be passed to volume validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attributes = 3;</code>
     */

    public java.lang.String getAttributesOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetAttributes().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Attributes reflect static properties of a volume and MUST be passed
     * to volume validation and publishing calls.
     * Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
     * and SHALL be safe for the CO to cache. Attributes SHOULD NOT
     * contain sensitive information. Attributes MAY NOT uniquely identify
     * a volume. A volume uniquely identified by `id` SHALL always report
     * the same attributes. This field is OPTIONAL and when present MUST
     * be passed to volume validation and publishing calls.
     * </pre>
     *
     * <code>map&lt;string, string&gt; attributes = 3;</code>
     */

    public java.lang.String getAttributesOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetAttributes().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int CONTENT_SOURCE_FIELD_NUMBER = 4;
    private csi.v0.Csi.VolumeContentSource contentSource_;
    /**
     * <pre>
     * If specified, indicates that the volume is not empty and is
     * pre-populated with data from the specified source.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v0.VolumeContentSource content_source = 4;</code>
     */
    public boolean hasContentSource() {
      return contentSource_ != null;
    }
    /**
     * <pre>
     * If specified, indicates that the volume is not empty and is
     * pre-populated with data from the specified source.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v0.VolumeContentSource content_source = 4;</code>
     */
    public csi.v0.Csi.VolumeContentSource getContentSource() {
      return contentSource_ == null ? csi.v0.Csi.VolumeContentSource.getDefaultInstance() : contentSource_;
    }
    /**
     * <pre>
     * If specified, indicates that the volume is not empty and is
     * pre-populated with data from the specified source.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>.csi.v0.VolumeContentSource content_source = 4;</code>
     */
    public csi.v0.Csi.VolumeContentSourceOrBuilder getContentSourceOrBuilder() {
      return getContentSource();
    }

    public static final int ACCESSIBLE_TOPOLOGY_FIELD_NUMBER = 5;
    private java.util.List<csi.v0.Csi.Topology> accessibleTopology_;
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * may schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
     */
    public java.util.List<csi.v0.Csi.Topology> getAccessibleTopologyList() {
      return accessibleTopology_;
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * may schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
     */
    public java.util.List<? extends csi.v0.Csi.TopologyOrBuilder> 
        getAccessibleTopologyOrBuilderList() {
      return accessibleTopology_;
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * may schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
     */
    public int getAccessibleTopologyCount() {
      return accessibleTopology_.size();
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * may schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
     */
    public csi.v0.Csi.Topology getAccessibleTopology(int index) {
      return accessibleTopology_.get(index);
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the provisioned
     * volume is accessible from.
     * A plugin that returns this field MUST also set the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * An SP MAY specify multiple topologies to indicate the volume is
     * accessible from multiple locations.
     * COs MAY use this information along with the topology information
     * returned by NodeGetInfo to ensure that a given volume is accessible
     * from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the volume is equally accessible from all nodes in the cluster and
     * may schedule workloads referencing the volume on any available
     * node.
     * Example 1:
     *   accessible_topology = {"region": "R1", "zone": "Z2"}
     * Indicates a volume accessible only from the "region" "R1" and the
     * "zone" "Z2".
     * Example 2:
     *   accessible_topology =
     *     {"region": "R1", "zone": "Z2"},
     *     {"region": "R1", "zone": "Z3"}
     * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
     * in the "region" "R1".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
     */
    public csi.v0.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder(
        int index) {
      return accessibleTopology_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (capacityBytes_ != 0L) {
        output.writeInt64(1, capacityBytes_);
      }
      if (!getIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, id_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetAttributes(),
          AttributesDefaultEntryHolder.defaultEntry,
          3);
      if (contentSource_ != null) {
        output.writeMessage(4, getContentSource());
      }
      for (int i = 0; i < accessibleTopology_.size(); i++) {
        output.writeMessage(5, accessibleTopology_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (capacityBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, capacityBytes_);
      }
      if (!getIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, id_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetAttributes().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        attributes__ = AttributesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(3, attributes__);
      }
      if (contentSource_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getContentSource());
      }
      for (int i = 0; i < accessibleTopology_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, accessibleTopology_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.Volume)) {
        return super.equals(obj);
      }
      csi.v0.Csi.Volume other = (csi.v0.Csi.Volume) obj;

      boolean result = true;
      result = result && (getCapacityBytes()
          == other.getCapacityBytes());
      result = result && getId()
          .equals(other.getId());
      result = result && internalGetAttributes().equals(
          other.internalGetAttributes());
      result = result && (hasContentSource() == other.hasContentSource());
      if (hasContentSource()) {
        result = result && getContentSource()
            .equals(other.getContentSource());
      }
      result = result && getAccessibleTopologyList()
          .equals(other.getAccessibleTopologyList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + CAPACITY_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getCapacityBytes());
      hash = (37 * hash) + ID_FIELD_NUMBER;
      hash = (53 * hash) + getId().hashCode();
      if (!internalGetAttributes().getMap().isEmpty()) {
        hash = (37 * hash) + ATTRIBUTES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetAttributes().hashCode();
      }
      if (hasContentSource()) {
        hash = (37 * hash) + CONTENT_SOURCE_FIELD_NUMBER;
        hash = (53 * hash) + getContentSource().hashCode();
      }
      if (getAccessibleTopologyCount() > 0) {
        hash = (37 * hash) + ACCESSIBLE_TOPOLOGY_FIELD_NUMBER;
        hash = (53 * hash) + getAccessibleTopologyList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.Volume parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.Volume parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.Volume parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.Volume parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.Volume parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.Volume parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.Volume parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.Volume parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.Volume parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.Volume parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.Volume parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.Volume parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.Volume prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The information about a provisioned volume.
     * </pre>
     *
     * Protobuf type {@code csi.v0.Volume}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.Volume)
        csi.v0.Csi.VolumeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_Volume_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetAttributes();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetMutableAttributes();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_Volume_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.Volume.class, csi.v0.Csi.Volume.Builder.class);
      }

      // Construct using csi.v0.Csi.Volume.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getAccessibleTopologyFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        capacityBytes_ = 0L;

        id_ = "";

        internalGetMutableAttributes().clear();
        if (contentSourceBuilder_ == null) {
          contentSource_ = null;
        } else {
          contentSource_ = null;
          contentSourceBuilder_ = null;
        }
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
        } else {
          accessibleTopologyBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_Volume_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.Volume getDefaultInstanceForType() {
        return csi.v0.Csi.Volume.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.Volume build() {
        csi.v0.Csi.Volume result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.Volume buildPartial() {
        csi.v0.Csi.Volume result = new csi.v0.Csi.Volume(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.capacityBytes_ = capacityBytes_;
        result.id_ = id_;
        result.attributes_ = internalGetAttributes();
        result.attributes_.makeImmutable();
        if (contentSourceBuilder_ == null) {
          result.contentSource_ = contentSource_;
        } else {
          result.contentSource_ = contentSourceBuilder_.build();
        }
        if (accessibleTopologyBuilder_ == null) {
          if (((bitField0_ & 0x00000010) == 0x00000010)) {
            accessibleTopology_ = java.util.Collections.unmodifiableList(accessibleTopology_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.accessibleTopology_ = accessibleTopology_;
        } else {
          result.accessibleTopology_ = accessibleTopologyBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.Volume) {
          return mergeFrom((csi.v0.Csi.Volume)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.Volume other) {
        if (other == csi.v0.Csi.Volume.getDefaultInstance()) return this;
        if (other.getCapacityBytes() != 0L) {
          setCapacityBytes(other.getCapacityBytes());
        }
        if (!other.getId().isEmpty()) {
          id_ = other.id_;
          onChanged();
        }
        internalGetMutableAttributes().mergeFrom(
            other.internalGetAttributes());
        if (other.hasContentSource()) {
          mergeContentSource(other.getContentSource());
        }
        if (accessibleTopologyBuilder_ == null) {
          if (!other.accessibleTopology_.isEmpty()) {
            if (accessibleTopology_.isEmpty()) {
              accessibleTopology_ = other.accessibleTopology_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureAccessibleTopologyIsMutable();
              accessibleTopology_.addAll(other.accessibleTopology_);
            }
            onChanged();
          }
        } else {
          if (!other.accessibleTopology_.isEmpty()) {
            if (accessibleTopologyBuilder_.isEmpty()) {
              accessibleTopologyBuilder_.dispose();
              accessibleTopologyBuilder_ = null;
              accessibleTopology_ = other.accessibleTopology_;
              bitField0_ = (bitField0_ & ~0x00000010);
              accessibleTopologyBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getAccessibleTopologyFieldBuilder() : null;
            } else {
              accessibleTopologyBuilder_.addAllMessages(other.accessibleTopology_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.Volume parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.Volume) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private long capacityBytes_ ;
      /**
       * <pre>
       * The capacity of the volume in bytes. This field is OPTIONAL. If not
       * set (value of 0), it indicates that the capacity of the volume is
       * unknown (e.g., NFS share).
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 capacity_bytes = 1;</code>
       */
      public long getCapacityBytes() {
        return capacityBytes_;
      }
      /**
       * <pre>
       * The capacity of the volume in bytes. This field is OPTIONAL. If not
       * set (value of 0), it indicates that the capacity of the volume is
       * unknown (e.g., NFS share).
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 capacity_bytes = 1;</code>
       */
      public Builder setCapacityBytes(long value) {
        
        capacityBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The capacity of the volume in bytes. This field is OPTIONAL. If not
       * set (value of 0), it indicates that the capacity of the volume is
       * unknown (e.g., NFS share).
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 capacity_bytes = 1;</code>
       */
      public Builder clearCapacityBytes() {
        
        capacityBytes_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object id_ = "";
      /**
       * <pre>
       * Contains identity information for the created volume. This field is
       * REQUIRED. The identity information will be used by the CO in
       * subsequent calls to refer to the provisioned volume.
       * </pre>
       *
       * <code>string id = 2;</code>
       */
      public java.lang.String getId() {
        java.lang.Object ref = id_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          id_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Contains identity information for the created volume. This field is
       * REQUIRED. The identity information will be used by the CO in
       * subsequent calls to refer to the provisioned volume.
       * </pre>
       *
       * <code>string id = 2;</code>
       */
      public com.google.protobuf.ByteString
          getIdBytes() {
        java.lang.Object ref = id_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          id_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Contains identity information for the created volume. This field is
       * REQUIRED. The identity information will be used by the CO in
       * subsequent calls to refer to the provisioned volume.
       * </pre>
       *
       * <code>string id = 2;</code>
       */
      public Builder setId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        id_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Contains identity information for the created volume. This field is
       * REQUIRED. The identity information will be used by the CO in
       * subsequent calls to refer to the provisioned volume.
       * </pre>
       *
       * <code>string id = 2;</code>
       */
      public Builder clearId() {
        
        id_ = getDefaultInstance().getId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Contains identity information for the created volume. This field is
       * REQUIRED. The identity information will be used by the CO in
       * subsequent calls to refer to the provisioned volume.
       * </pre>
       *
       * <code>string id = 2;</code>
       */
      public Builder setIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        id_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> attributes_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetAttributes() {
        if (attributes_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              AttributesDefaultEntryHolder.defaultEntry);
        }
        return attributes_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableAttributes() {
        onChanged();;
        if (attributes_ == null) {
          attributes_ = com.google.protobuf.MapField.newMapField(
              AttributesDefaultEntryHolder.defaultEntry);
        }
        if (!attributes_.isMutable()) {
          attributes_ = attributes_.copy();
        }
        return attributes_;
      }

      public int getAttributesCount() {
        return internalGetAttributes().getMap().size();
      }
      /**
       * <pre>
       * Attributes reflect static properties of a volume and MUST be passed
       * to volume validation and publishing calls.
       * Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
       * and SHALL be safe for the CO to cache. Attributes SHOULD NOT
       * contain sensitive information. Attributes MAY NOT uniquely identify
       * a volume. A volume uniquely identified by `id` SHALL always report
       * the same attributes. This field is OPTIONAL and when present MUST
       * be passed to volume validation and publishing calls.
       * </pre>
       *
       * <code>map&lt;string, string&gt; attributes = 3;</code>
       */

      public boolean containsAttributes(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetAttributes().getMap().containsKey(key);
      }
      /**
       * Use {@link #getAttributesMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getAttributes() {
        return getAttributesMap();
      }
      /**
       * <pre>
       * Attributes reflect static properties of a volume and MUST be passed
       * to volume validation and publishing calls.
       * Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
       * and SHALL be safe for the CO to cache. Attributes SHOULD NOT
       * contain sensitive information. Attributes MAY NOT uniquely identify
       * a volume. A volume uniquely identified by `id` SHALL always report
       * the same attributes. This field is OPTIONAL and when present MUST
       * be passed to volume validation and publishing calls.
       * </pre>
       *
       * <code>map&lt;string, string&gt; attributes = 3;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getAttributesMap() {
        return internalGetAttributes().getMap();
      }
      /**
       * <pre>
       * Attributes reflect static properties of a volume and MUST be passed
       * to volume validation and publishing calls.
       * Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
       * and SHALL be safe for the CO to cache. Attributes SHOULD NOT
       * contain sensitive information. Attributes MAY NOT uniquely identify
       * a volume. A volume uniquely identified by `id` SHALL always report
       * the same attributes. This field is OPTIONAL and when present MUST
       * be passed to volume validation and publishing calls.
       * </pre>
       *
       * <code>map&lt;string, string&gt; attributes = 3;</code>
       */

      public java.lang.String getAttributesOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetAttributes().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Attributes reflect static properties of a volume and MUST be passed
       * to volume validation and publishing calls.
       * Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
       * and SHALL be safe for the CO to cache. Attributes SHOULD NOT
       * contain sensitive information. Attributes MAY NOT uniquely identify
       * a volume. A volume uniquely identified by `id` SHALL always report
       * the same attributes. This field is OPTIONAL and when present MUST
       * be passed to volume validation and publishing calls.
       * </pre>
       *
       * <code>map&lt;string, string&gt; attributes = 3;</code>
       */

      public java.lang.String getAttributesOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetAttributes().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearAttributes() {
        internalGetMutableAttributes().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Attributes reflect static properties of a volume and MUST be passed
       * to volume validation and publishing calls.
       * Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
       * and SHALL be safe for the CO to cache. Attributes SHOULD NOT
       * contain sensitive information. Attributes MAY NOT uniquely identify
       * a volume. A volume uniquely identified by `id` SHALL always report
       * the same attributes. This field is OPTIONAL and when present MUST
       * be passed to volume validation and publishing calls.
       * </pre>
       *
       * <code>map&lt;string, string&gt; attributes = 3;</code>
       */

      public Builder removeAttributes(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableAttributes().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableAttributes() {
        return internalGetMutableAttributes().getMutableMap();
      }
      /**
       * <pre>
       * Attributes reflect static properties of a volume and MUST be passed
       * to volume validation and publishing calls.
       * Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
       * and SHALL be safe for the CO to cache. Attributes SHOULD NOT
       * contain sensitive information. Attributes MAY NOT uniquely identify
       * a volume. A volume uniquely identified by `id` SHALL always report
       * the same attributes. This field is OPTIONAL and when present MUST
       * be passed to volume validation and publishing calls.
       * </pre>
       *
       * <code>map&lt;string, string&gt; attributes = 3;</code>
       */
      public Builder putAttributes(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableAttributes().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Attributes reflect static properties of a volume and MUST be passed
       * to volume validation and publishing calls.
       * Attributes SHALL be opaque to a CO. Attributes SHALL NOT be mutable
       * and SHALL be safe for the CO to cache. Attributes SHOULD NOT
       * contain sensitive information. Attributes MAY NOT uniquely identify
       * a volume. A volume uniquely identified by `id` SHALL always report
       * the same attributes. This field is OPTIONAL and when present MUST
       * be passed to volume validation and publishing calls.
       * </pre>
       *
       * <code>map&lt;string, string&gt; attributes = 3;</code>
       */

      public Builder putAllAttributes(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableAttributes().getMutableMap()
            .putAll(values);
        return this;
      }

      private csi.v0.Csi.VolumeContentSource contentSource_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeContentSource, csi.v0.Csi.VolumeContentSource.Builder, csi.v0.Csi.VolumeContentSourceOrBuilder> contentSourceBuilder_;
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource content_source = 4;</code>
       */
      public boolean hasContentSource() {
        return contentSourceBuilder_ != null || contentSource_ != null;
      }
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource content_source = 4;</code>
       */
      public csi.v0.Csi.VolumeContentSource getContentSource() {
        if (contentSourceBuilder_ == null) {
          return contentSource_ == null ? csi.v0.Csi.VolumeContentSource.getDefaultInstance() : contentSource_;
        } else {
          return contentSourceBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource content_source = 4;</code>
       */
      public Builder setContentSource(csi.v0.Csi.VolumeContentSource value) {
        if (contentSourceBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          contentSource_ = value;
          onChanged();
        } else {
          contentSourceBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource content_source = 4;</code>
       */
      public Builder setContentSource(
          csi.v0.Csi.VolumeContentSource.Builder builderForValue) {
        if (contentSourceBuilder_ == null) {
          contentSource_ = builderForValue.build();
          onChanged();
        } else {
          contentSourceBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource content_source = 4;</code>
       */
      public Builder mergeContentSource(csi.v0.Csi.VolumeContentSource value) {
        if (contentSourceBuilder_ == null) {
          if (contentSource_ != null) {
            contentSource_ =
              csi.v0.Csi.VolumeContentSource.newBuilder(contentSource_).mergeFrom(value).buildPartial();
          } else {
            contentSource_ = value;
          }
          onChanged();
        } else {
          contentSourceBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource content_source = 4;</code>
       */
      public Builder clearContentSource() {
        if (contentSourceBuilder_ == null) {
          contentSource_ = null;
          onChanged();
        } else {
          contentSource_ = null;
          contentSourceBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource content_source = 4;</code>
       */
      public csi.v0.Csi.VolumeContentSource.Builder getContentSourceBuilder() {
        
        onChanged();
        return getContentSourceFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource content_source = 4;</code>
       */
      public csi.v0.Csi.VolumeContentSourceOrBuilder getContentSourceOrBuilder() {
        if (contentSourceBuilder_ != null) {
          return contentSourceBuilder_.getMessageOrBuilder();
        } else {
          return contentSource_ == null ?
              csi.v0.Csi.VolumeContentSource.getDefaultInstance() : contentSource_;
        }
      }
      /**
       * <pre>
       * If specified, indicates that the volume is not empty and is
       * pre-populated with data from the specified source.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>.csi.v0.VolumeContentSource content_source = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeContentSource, csi.v0.Csi.VolumeContentSource.Builder, csi.v0.Csi.VolumeContentSourceOrBuilder> 
          getContentSourceFieldBuilder() {
        if (contentSourceBuilder_ == null) {
          contentSourceBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.VolumeContentSource, csi.v0.Csi.VolumeContentSource.Builder, csi.v0.Csi.VolumeContentSourceOrBuilder>(
                  getContentSource(),
                  getParentForChildren(),
                  isClean());
          contentSource_ = null;
        }
        return contentSourceBuilder_;
      }

      private java.util.List<csi.v0.Csi.Topology> accessibleTopology_ =
        java.util.Collections.emptyList();
      private void ensureAccessibleTopologyIsMutable() {
        if (!((bitField0_ & 0x00000010) == 0x00000010)) {
          accessibleTopology_ = new java.util.ArrayList<csi.v0.Csi.Topology>(accessibleTopology_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder> accessibleTopologyBuilder_;

      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public java.util.List<csi.v0.Csi.Topology> getAccessibleTopologyList() {
        if (accessibleTopologyBuilder_ == null) {
          return java.util.Collections.unmodifiableList(accessibleTopology_);
        } else {
          return accessibleTopologyBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public int getAccessibleTopologyCount() {
        if (accessibleTopologyBuilder_ == null) {
          return accessibleTopology_.size();
        } else {
          return accessibleTopologyBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public csi.v0.Csi.Topology getAccessibleTopology(int index) {
        if (accessibleTopologyBuilder_ == null) {
          return accessibleTopology_.get(index);
        } else {
          return accessibleTopologyBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public Builder setAccessibleTopology(
          int index, csi.v0.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.set(index, value);
          onChanged();
        } else {
          accessibleTopologyBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public Builder setAccessibleTopology(
          int index, csi.v0.Csi.Topology.Builder builderForValue) {
        if (accessibleTopologyBuilder_ == null) {
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.set(index, builderForValue.build());
          onChanged();
        } else {
          accessibleTopologyBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public Builder addAccessibleTopology(csi.v0.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.add(value);
          onChanged();
        } else {
          accessibleTopologyBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public Builder addAccessibleTopology(
          int index, csi.v0.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.add(index, value);
          onChanged();
        } else {
          accessibleTopologyBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public Builder addAccessibleTopology(
          csi.v0.Csi.Topology.Builder builderForValue) {
        if (accessibleTopologyBuilder_ == null) {
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.add(builderForValue.build());
          onChanged();
        } else {
          accessibleTopologyBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public Builder addAccessibleTopology(
          int index, csi.v0.Csi.Topology.Builder builderForValue) {
        if (accessibleTopologyBuilder_ == null) {
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.add(index, builderForValue.build());
          onChanged();
        } else {
          accessibleTopologyBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public Builder addAllAccessibleTopology(
          java.lang.Iterable<? extends csi.v0.Csi.Topology> values) {
        if (accessibleTopologyBuilder_ == null) {
          ensureAccessibleTopologyIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, accessibleTopology_);
          onChanged();
        } else {
          accessibleTopologyBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public Builder clearAccessibleTopology() {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          accessibleTopologyBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public Builder removeAccessibleTopology(int index) {
        if (accessibleTopologyBuilder_ == null) {
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.remove(index);
          onChanged();
        } else {
          accessibleTopologyBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public csi.v0.Csi.Topology.Builder getAccessibleTopologyBuilder(
          int index) {
        return getAccessibleTopologyFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public csi.v0.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder(
          int index) {
        if (accessibleTopologyBuilder_ == null) {
          return accessibleTopology_.get(index);  } else {
          return accessibleTopologyBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public java.util.List<? extends csi.v0.Csi.TopologyOrBuilder> 
           getAccessibleTopologyOrBuilderList() {
        if (accessibleTopologyBuilder_ != null) {
          return accessibleTopologyBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(accessibleTopology_);
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public csi.v0.Csi.Topology.Builder addAccessibleTopologyBuilder() {
        return getAccessibleTopologyFieldBuilder().addBuilder(
            csi.v0.Csi.Topology.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public csi.v0.Csi.Topology.Builder addAccessibleTopologyBuilder(
          int index) {
        return getAccessibleTopologyFieldBuilder().addBuilder(
            index, csi.v0.Csi.Topology.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the provisioned
       * volume is accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * An SP MAY specify multiple topologies to indicate the volume is
       * accessible from multiple locations.
       * COs MAY use this information along with the topology information
       * returned by NodeGetInfo to ensure that a given volume is accessible
       * from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the volume is equally accessible from all nodes in the cluster and
       * may schedule workloads referencing the volume on any available
       * node.
       * Example 1:
       *   accessible_topology = {"region": "R1", "zone": "Z2"}
       * Indicates a volume accessible only from the "region" "R1" and the
       * "zone" "Z2".
       * Example 2:
       *   accessible_topology =
       *     {"region": "R1", "zone": "Z2"},
       *     {"region": "R1", "zone": "Z3"}
       * Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
       * in the "region" "R1".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 5;</code>
       */
      public java.util.List<csi.v0.Csi.Topology.Builder> 
           getAccessibleTopologyBuilderList() {
        return getAccessibleTopologyFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder> 
          getAccessibleTopologyFieldBuilder() {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopologyBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder>(
                  accessibleTopology_,
                  ((bitField0_ & 0x00000010) == 0x00000010),
                  getParentForChildren(),
                  isClean());
          accessibleTopology_ = null;
        }
        return accessibleTopologyBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.Volume)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.Volume)
    private static final csi.v0.Csi.Volume DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.Volume();
    }

    public static csi.v0.Csi.Volume getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Volume>
        PARSER = new com.google.protobuf.AbstractParser<Volume>() {
      @java.lang.Override
      public Volume parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Volume(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Volume> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Volume> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.Volume getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TopologyRequirementOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.TopologyRequirement)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, than the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, than the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, than the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology requisite = 1;</code>
     */
    java.util.List<csi.v0.Csi.Topology> 
        getRequisiteList();
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, than the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, than the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, than the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology requisite = 1;</code>
     */
    csi.v0.Csi.Topology getRequisite(int index);
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, than the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, than the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, than the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology requisite = 1;</code>
     */
    int getRequisiteCount();
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, than the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, than the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, than the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology requisite = 1;</code>
     */
    java.util.List<? extends csi.v0.Csi.TopologyOrBuilder> 
        getRequisiteOrBuilderList();
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, than the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, than the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, than the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology requisite = 1;</code>
     */
    csi.v0.Csi.TopologyOrBuilder getRequisiteOrBuilder(
        int index);

    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology preferred = 2;</code>
     */
    java.util.List<csi.v0.Csi.Topology> 
        getPreferredList();
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology preferred = 2;</code>
     */
    csi.v0.Csi.Topology getPreferred(int index);
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology preferred = 2;</code>
     */
    int getPreferredCount();
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology preferred = 2;</code>
     */
    java.util.List<? extends csi.v0.Csi.TopologyOrBuilder> 
        getPreferredOrBuilderList();
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology preferred = 2;</code>
     */
    csi.v0.Csi.TopologyOrBuilder getPreferredOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code csi.v0.TopologyRequirement}
   */
  public  static final class TopologyRequirement extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.TopologyRequirement)
      TopologyRequirementOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TopologyRequirement.newBuilder() to construct.
    private TopologyRequirement(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TopologyRequirement() {
      requisite_ = java.util.Collections.emptyList();
      preferred_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private TopologyRequirement(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                requisite_ = new java.util.ArrayList<csi.v0.Csi.Topology>();
                mutable_bitField0_ |= 0x00000001;
              }
              requisite_.add(
                  input.readMessage(csi.v0.Csi.Topology.parser(), extensionRegistry));
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                preferred_ = new java.util.ArrayList<csi.v0.Csi.Topology>();
                mutable_bitField0_ |= 0x00000002;
              }
              preferred_.add(
                  input.readMessage(csi.v0.Csi.Topology.parser(), extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          requisite_ = java.util.Collections.unmodifiableList(requisite_);
        }
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          preferred_ = java.util.Collections.unmodifiableList(preferred_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_TopologyRequirement_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_TopologyRequirement_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.TopologyRequirement.class, csi.v0.Csi.TopologyRequirement.Builder.class);
    }

    public static final int REQUISITE_FIELD_NUMBER = 1;
    private java.util.List<csi.v0.Csi.Topology> requisite_;
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, than the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, than the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, than the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology requisite = 1;</code>
     */
    public java.util.List<csi.v0.Csi.Topology> getRequisiteList() {
      return requisite_;
    }
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, than the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, than the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, than the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology requisite = 1;</code>
     */
    public java.util.List<? extends csi.v0.Csi.TopologyOrBuilder> 
        getRequisiteOrBuilderList() {
      return requisite_;
    }
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, than the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, than the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, than the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology requisite = 1;</code>
     */
    public int getRequisiteCount() {
      return requisite_.size();
    }
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, than the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, than the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, than the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology requisite = 1;</code>
     */
    public csi.v0.Csi.Topology getRequisite(int index) {
      return requisite_.get(index);
    }
    /**
     * <pre>
     * Specifies the list of topologies the provisioned volume MUST be
     * accessible from.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * If requisite is specified, the provisioned volume MUST be
     * accessible from at least one of the requisite topologies.
     * Given
     *   x = number of topologies provisioned volume is accessible from
     *   n = number of requisite topologies
     * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
     * If x==n, than the SP MUST make the provisioned volume available to
     * all topologies from the list of requisite topologies. If it is
     * unable to do so, the SP MUST fail the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and both "zone" "Z2" and "zone" "Z3".
     * If x&lt;n, than the SP SHALL choose x unique topologies from the list
     * of requisite topologies. If it is unable to do so, the SP MUST fail
     * the CreateVolume call.
     * For example, if a volume should be accessible from a single zone,
     * and requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * then the SP may choose to make the provisioned volume available in
     * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
     * Similarly, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"}
     * then the provisioned volume MUST be accessible from any combination
     * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
     *  "R1/Z4", or "R1/Z3" and "R1/Z4".
     * If x&gt;n, than the SP MUST make the provisioned volume available from
     * all topologies from the list of requisite topologies and MAY choose
     * the remaining x-n unique topologies from the list of all possible
     * topologies. If it is unable to do so, the SP MUST fail the
     * CreateVolume call.
     * For example, if a volume should be accessible from two zones, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"}
     * then the provisioned volume MUST be accessible from the "region"
     * "R1" and the "zone" "Z2" and the SP may select the second zone
     * independently, e.g. "R1/Z4".
     * </pre>
     *
     * <code>repeated .csi.v0.Topology requisite = 1;</code>
     */
    public csi.v0.Csi.TopologyOrBuilder getRequisiteOrBuilder(
        int index) {
      return requisite_.get(index);
    }

    public static final int PREFERRED_FIELD_NUMBER = 2;
    private java.util.List<csi.v0.Csi.Topology> preferred_;
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology preferred = 2;</code>
     */
    public java.util.List<csi.v0.Csi.Topology> getPreferredList() {
      return preferred_;
    }
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology preferred = 2;</code>
     */
    public java.util.List<? extends csi.v0.Csi.TopologyOrBuilder> 
        getPreferredOrBuilderList() {
      return preferred_;
    }
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology preferred = 2;</code>
     */
    public int getPreferredCount() {
      return preferred_.size();
    }
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology preferred = 2;</code>
     */
    public csi.v0.Csi.Topology getPreferred(int index) {
      return preferred_.get(index);
    }
    /**
     * <pre>
     * Specifies the list of topologies the CO would prefer the volume to
     * be provisioned in.
     * This field is OPTIONAL. If TopologyRequirement is specified either
     * requisite or preferred or both MUST be specified.
     * An SP MUST attempt to make the provisioned volume available using
     * the preferred topologies in order from first to last.
     * If requisite is specified, all topologies in preferred list MUST
     * also be present in the list of requisite topologies.
     * If the SP is unable to to make the provisioned volume available
     * from any of the preferred topologies, the SP MAY choose a topology
     * from the list of requisite topologies.
     * If the list of requisite topologies is not specified, then the SP
     * MAY choose from the list of all possible topologies.
     * If the list of requisite topologies is specified and the SP is
     * unable to to make the provisioned volume available from any of the
     * requisite topologies it MUST fail the CreateVolume call.
     * Example 1:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"}
     * preferred =
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * available from "zone" "Z3" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible.
     * Example 2:
     * Given a volume should be accessible from a single zone, and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z2"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from "zone" "Z4" in the "region" "R1" and fall back to
     * "zone" "Z2" in the "region" "R1" if that is not possible. If that
     * is not possible, the SP may choose between either the "zone"
     * "Z3" or "Z5" in the "region" "R1".
     * Example 3:
     * Given a volume should be accessible from TWO zones (because an
     * opaque parameter in CreateVolumeRequest, for example, specifies
     * the volume is accessible from two zones, aka synchronously
     * replicated), and
     * requisite =
     *   {"region": "R1", "zone": "Z2"},
     *   {"region": "R1", "zone": "Z3"},
     *   {"region": "R1", "zone": "Z4"},
     *   {"region": "R1", "zone": "Z5"}
     * preferred =
     *   {"region": "R1", "zone": "Z5"},
     *   {"region": "R1", "zone": "Z3"}
     * then the the SP SHOULD first attempt to make the provisioned volume
     * accessible from the combination of the two "zones" "Z5" and "Z3" in
     * the "region" "R1". If that's not possible, it should fall back to
     * a combination of "Z5" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of "Z3" and other possibilities from the list of
     * requisite. If that's not possible, it should fall back  to a
     * combination of other possibilities from the list of requisite.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology preferred = 2;</code>
     */
    public csi.v0.Csi.TopologyOrBuilder getPreferredOrBuilder(
        int index) {
      return preferred_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < requisite_.size(); i++) {
        output.writeMessage(1, requisite_.get(i));
      }
      for (int i = 0; i < preferred_.size(); i++) {
        output.writeMessage(2, preferred_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < requisite_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, requisite_.get(i));
      }
      for (int i = 0; i < preferred_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, preferred_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.TopologyRequirement)) {
        return super.equals(obj);
      }
      csi.v0.Csi.TopologyRequirement other = (csi.v0.Csi.TopologyRequirement) obj;

      boolean result = true;
      result = result && getRequisiteList()
          .equals(other.getRequisiteList());
      result = result && getPreferredList()
          .equals(other.getPreferredList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getRequisiteCount() > 0) {
        hash = (37 * hash) + REQUISITE_FIELD_NUMBER;
        hash = (53 * hash) + getRequisiteList().hashCode();
      }
      if (getPreferredCount() > 0) {
        hash = (37 * hash) + PREFERRED_FIELD_NUMBER;
        hash = (53 * hash) + getPreferredList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.TopologyRequirement parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.TopologyRequirement parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.TopologyRequirement parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.TopologyRequirement parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.TopologyRequirement parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.TopologyRequirement parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.TopologyRequirement parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.TopologyRequirement parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.TopologyRequirement parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.TopologyRequirement parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.TopologyRequirement parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.TopologyRequirement parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.TopologyRequirement prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.TopologyRequirement}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.TopologyRequirement)
        csi.v0.Csi.TopologyRequirementOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_TopologyRequirement_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_TopologyRequirement_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.TopologyRequirement.class, csi.v0.Csi.TopologyRequirement.Builder.class);
      }

      // Construct using csi.v0.Csi.TopologyRequirement.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getRequisiteFieldBuilder();
          getPreferredFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (requisiteBuilder_ == null) {
          requisite_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          requisiteBuilder_.clear();
        }
        if (preferredBuilder_ == null) {
          preferred_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          preferredBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_TopologyRequirement_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.TopologyRequirement getDefaultInstanceForType() {
        return csi.v0.Csi.TopologyRequirement.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.TopologyRequirement build() {
        csi.v0.Csi.TopologyRequirement result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.TopologyRequirement buildPartial() {
        csi.v0.Csi.TopologyRequirement result = new csi.v0.Csi.TopologyRequirement(this);
        int from_bitField0_ = bitField0_;
        if (requisiteBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            requisite_ = java.util.Collections.unmodifiableList(requisite_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.requisite_ = requisite_;
        } else {
          result.requisite_ = requisiteBuilder_.build();
        }
        if (preferredBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            preferred_ = java.util.Collections.unmodifiableList(preferred_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.preferred_ = preferred_;
        } else {
          result.preferred_ = preferredBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.TopologyRequirement) {
          return mergeFrom((csi.v0.Csi.TopologyRequirement)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.TopologyRequirement other) {
        if (other == csi.v0.Csi.TopologyRequirement.getDefaultInstance()) return this;
        if (requisiteBuilder_ == null) {
          if (!other.requisite_.isEmpty()) {
            if (requisite_.isEmpty()) {
              requisite_ = other.requisite_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureRequisiteIsMutable();
              requisite_.addAll(other.requisite_);
            }
            onChanged();
          }
        } else {
          if (!other.requisite_.isEmpty()) {
            if (requisiteBuilder_.isEmpty()) {
              requisiteBuilder_.dispose();
              requisiteBuilder_ = null;
              requisite_ = other.requisite_;
              bitField0_ = (bitField0_ & ~0x00000001);
              requisiteBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getRequisiteFieldBuilder() : null;
            } else {
              requisiteBuilder_.addAllMessages(other.requisite_);
            }
          }
        }
        if (preferredBuilder_ == null) {
          if (!other.preferred_.isEmpty()) {
            if (preferred_.isEmpty()) {
              preferred_ = other.preferred_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensurePreferredIsMutable();
              preferred_.addAll(other.preferred_);
            }
            onChanged();
          }
        } else {
          if (!other.preferred_.isEmpty()) {
            if (preferredBuilder_.isEmpty()) {
              preferredBuilder_.dispose();
              preferredBuilder_ = null;
              preferred_ = other.preferred_;
              bitField0_ = (bitField0_ & ~0x00000002);
              preferredBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getPreferredFieldBuilder() : null;
            } else {
              preferredBuilder_.addAllMessages(other.preferred_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.TopologyRequirement parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.TopologyRequirement) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<csi.v0.Csi.Topology> requisite_ =
        java.util.Collections.emptyList();
      private void ensureRequisiteIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          requisite_ = new java.util.ArrayList<csi.v0.Csi.Topology>(requisite_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder> requisiteBuilder_;

      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public java.util.List<csi.v0.Csi.Topology> getRequisiteList() {
        if (requisiteBuilder_ == null) {
          return java.util.Collections.unmodifiableList(requisite_);
        } else {
          return requisiteBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public int getRequisiteCount() {
        if (requisiteBuilder_ == null) {
          return requisite_.size();
        } else {
          return requisiteBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public csi.v0.Csi.Topology getRequisite(int index) {
        if (requisiteBuilder_ == null) {
          return requisite_.get(index);
        } else {
          return requisiteBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public Builder setRequisite(
          int index, csi.v0.Csi.Topology value) {
        if (requisiteBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRequisiteIsMutable();
          requisite_.set(index, value);
          onChanged();
        } else {
          requisiteBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public Builder setRequisite(
          int index, csi.v0.Csi.Topology.Builder builderForValue) {
        if (requisiteBuilder_ == null) {
          ensureRequisiteIsMutable();
          requisite_.set(index, builderForValue.build());
          onChanged();
        } else {
          requisiteBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public Builder addRequisite(csi.v0.Csi.Topology value) {
        if (requisiteBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRequisiteIsMutable();
          requisite_.add(value);
          onChanged();
        } else {
          requisiteBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public Builder addRequisite(
          int index, csi.v0.Csi.Topology value) {
        if (requisiteBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRequisiteIsMutable();
          requisite_.add(index, value);
          onChanged();
        } else {
          requisiteBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public Builder addRequisite(
          csi.v0.Csi.Topology.Builder builderForValue) {
        if (requisiteBuilder_ == null) {
          ensureRequisiteIsMutable();
          requisite_.add(builderForValue.build());
          onChanged();
        } else {
          requisiteBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public Builder addRequisite(
          int index, csi.v0.Csi.Topology.Builder builderForValue) {
        if (requisiteBuilder_ == null) {
          ensureRequisiteIsMutable();
          requisite_.add(index, builderForValue.build());
          onChanged();
        } else {
          requisiteBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public Builder addAllRequisite(
          java.lang.Iterable<? extends csi.v0.Csi.Topology> values) {
        if (requisiteBuilder_ == null) {
          ensureRequisiteIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, requisite_);
          onChanged();
        } else {
          requisiteBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public Builder clearRequisite() {
        if (requisiteBuilder_ == null) {
          requisite_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          requisiteBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public Builder removeRequisite(int index) {
        if (requisiteBuilder_ == null) {
          ensureRequisiteIsMutable();
          requisite_.remove(index);
          onChanged();
        } else {
          requisiteBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public csi.v0.Csi.Topology.Builder getRequisiteBuilder(
          int index) {
        return getRequisiteFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public csi.v0.Csi.TopologyOrBuilder getRequisiteOrBuilder(
          int index) {
        if (requisiteBuilder_ == null) {
          return requisite_.get(index);  } else {
          return requisiteBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public java.util.List<? extends csi.v0.Csi.TopologyOrBuilder> 
           getRequisiteOrBuilderList() {
        if (requisiteBuilder_ != null) {
          return requisiteBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(requisite_);
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public csi.v0.Csi.Topology.Builder addRequisiteBuilder() {
        return getRequisiteFieldBuilder().addBuilder(
            csi.v0.Csi.Topology.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public csi.v0.Csi.Topology.Builder addRequisiteBuilder(
          int index) {
        return getRequisiteFieldBuilder().addBuilder(
            index, csi.v0.Csi.Topology.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies the list of topologies the provisioned volume MUST be
       * accessible from.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * If requisite is specified, the provisioned volume MUST be
       * accessible from at least one of the requisite topologies.
       * Given
       *   x = number of topologies provisioned volume is accessible from
       *   n = number of requisite topologies
       * The CO MUST ensure n &gt;= 1. The SP MUST ensure x &gt;= 1
       * If x==n, than the SP MUST make the provisioned volume available to
       * all topologies from the list of requisite topologies. If it is
       * unable to do so, the SP MUST fail the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and both "zone" "Z2" and "zone" "Z3".
       * If x&lt;n, than the SP SHALL choose x unique topologies from the list
       * of requisite topologies. If it is unable to do so, the SP MUST fail
       * the CreateVolume call.
       * For example, if a volume should be accessible from a single zone,
       * and requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * then the SP may choose to make the provisioned volume available in
       * either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
       * Similarly, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"}
       * then the provisioned volume MUST be accessible from any combination
       * of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
       *  "R1/Z4", or "R1/Z3" and "R1/Z4".
       * If x&gt;n, than the SP MUST make the provisioned volume available from
       * all topologies from the list of requisite topologies and MAY choose
       * the remaining x-n unique topologies from the list of all possible
       * topologies. If it is unable to do so, the SP MUST fail the
       * CreateVolume call.
       * For example, if a volume should be accessible from two zones, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"}
       * then the provisioned volume MUST be accessible from the "region"
       * "R1" and the "zone" "Z2" and the SP may select the second zone
       * independently, e.g. "R1/Z4".
       * </pre>
       *
       * <code>repeated .csi.v0.Topology requisite = 1;</code>
       */
      public java.util.List<csi.v0.Csi.Topology.Builder> 
           getRequisiteBuilderList() {
        return getRequisiteFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder> 
          getRequisiteFieldBuilder() {
        if (requisiteBuilder_ == null) {
          requisiteBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder>(
                  requisite_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          requisite_ = null;
        }
        return requisiteBuilder_;
      }

      private java.util.List<csi.v0.Csi.Topology> preferred_ =
        java.util.Collections.emptyList();
      private void ensurePreferredIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          preferred_ = new java.util.ArrayList<csi.v0.Csi.Topology>(preferred_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder> preferredBuilder_;

      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public java.util.List<csi.v0.Csi.Topology> getPreferredList() {
        if (preferredBuilder_ == null) {
          return java.util.Collections.unmodifiableList(preferred_);
        } else {
          return preferredBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public int getPreferredCount() {
        if (preferredBuilder_ == null) {
          return preferred_.size();
        } else {
          return preferredBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public csi.v0.Csi.Topology getPreferred(int index) {
        if (preferredBuilder_ == null) {
          return preferred_.get(index);
        } else {
          return preferredBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public Builder setPreferred(
          int index, csi.v0.Csi.Topology value) {
        if (preferredBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePreferredIsMutable();
          preferred_.set(index, value);
          onChanged();
        } else {
          preferredBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public Builder setPreferred(
          int index, csi.v0.Csi.Topology.Builder builderForValue) {
        if (preferredBuilder_ == null) {
          ensurePreferredIsMutable();
          preferred_.set(index, builderForValue.build());
          onChanged();
        } else {
          preferredBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public Builder addPreferred(csi.v0.Csi.Topology value) {
        if (preferredBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePreferredIsMutable();
          preferred_.add(value);
          onChanged();
        } else {
          preferredBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public Builder addPreferred(
          int index, csi.v0.Csi.Topology value) {
        if (preferredBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePreferredIsMutable();
          preferred_.add(index, value);
          onChanged();
        } else {
          preferredBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public Builder addPreferred(
          csi.v0.Csi.Topology.Builder builderForValue) {
        if (preferredBuilder_ == null) {
          ensurePreferredIsMutable();
          preferred_.add(builderForValue.build());
          onChanged();
        } else {
          preferredBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public Builder addPreferred(
          int index, csi.v0.Csi.Topology.Builder builderForValue) {
        if (preferredBuilder_ == null) {
          ensurePreferredIsMutable();
          preferred_.add(index, builderForValue.build());
          onChanged();
        } else {
          preferredBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public Builder addAllPreferred(
          java.lang.Iterable<? extends csi.v0.Csi.Topology> values) {
        if (preferredBuilder_ == null) {
          ensurePreferredIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, preferred_);
          onChanged();
        } else {
          preferredBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public Builder clearPreferred() {
        if (preferredBuilder_ == null) {
          preferred_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          preferredBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public Builder removePreferred(int index) {
        if (preferredBuilder_ == null) {
          ensurePreferredIsMutable();
          preferred_.remove(index);
          onChanged();
        } else {
          preferredBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public csi.v0.Csi.Topology.Builder getPreferredBuilder(
          int index) {
        return getPreferredFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public csi.v0.Csi.TopologyOrBuilder getPreferredOrBuilder(
          int index) {
        if (preferredBuilder_ == null) {
          return preferred_.get(index);  } else {
          return preferredBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public java.util.List<? extends csi.v0.Csi.TopologyOrBuilder> 
           getPreferredOrBuilderList() {
        if (preferredBuilder_ != null) {
          return preferredBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(preferred_);
        }
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public csi.v0.Csi.Topology.Builder addPreferredBuilder() {
        return getPreferredFieldBuilder().addBuilder(
            csi.v0.Csi.Topology.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public csi.v0.Csi.Topology.Builder addPreferredBuilder(
          int index) {
        return getPreferredFieldBuilder().addBuilder(
            index, csi.v0.Csi.Topology.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies the list of topologies the CO would prefer the volume to
       * be provisioned in.
       * This field is OPTIONAL. If TopologyRequirement is specified either
       * requisite or preferred or both MUST be specified.
       * An SP MUST attempt to make the provisioned volume available using
       * the preferred topologies in order from first to last.
       * If requisite is specified, all topologies in preferred list MUST
       * also be present in the list of requisite topologies.
       * If the SP is unable to to make the provisioned volume available
       * from any of the preferred topologies, the SP MAY choose a topology
       * from the list of requisite topologies.
       * If the list of requisite topologies is not specified, then the SP
       * MAY choose from the list of all possible topologies.
       * If the list of requisite topologies is specified and the SP is
       * unable to to make the provisioned volume available from any of the
       * requisite topologies it MUST fail the CreateVolume call.
       * Example 1:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"}
       * preferred =
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * available from "zone" "Z3" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible.
       * Example 2:
       * Given a volume should be accessible from a single zone, and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z2"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from "zone" "Z4" in the "region" "R1" and fall back to
       * "zone" "Z2" in the "region" "R1" if that is not possible. If that
       * is not possible, the SP may choose between either the "zone"
       * "Z3" or "Z5" in the "region" "R1".
       * Example 3:
       * Given a volume should be accessible from TWO zones (because an
       * opaque parameter in CreateVolumeRequest, for example, specifies
       * the volume is accessible from two zones, aka synchronously
       * replicated), and
       * requisite =
       *   {"region": "R1", "zone": "Z2"},
       *   {"region": "R1", "zone": "Z3"},
       *   {"region": "R1", "zone": "Z4"},
       *   {"region": "R1", "zone": "Z5"}
       * preferred =
       *   {"region": "R1", "zone": "Z5"},
       *   {"region": "R1", "zone": "Z3"}
       * then the the SP SHOULD first attempt to make the provisioned volume
       * accessible from the combination of the two "zones" "Z5" and "Z3" in
       * the "region" "R1". If that's not possible, it should fall back to
       * a combination of "Z5" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of "Z3" and other possibilities from the list of
       * requisite. If that's not possible, it should fall back  to a
       * combination of other possibilities from the list of requisite.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology preferred = 2;</code>
       */
      public java.util.List<csi.v0.Csi.Topology.Builder> 
           getPreferredBuilderList() {
        return getPreferredFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder> 
          getPreferredFieldBuilder() {
        if (preferredBuilder_ == null) {
          preferredBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder>(
                  preferred_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          preferred_ = null;
        }
        return preferredBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.TopologyRequirement)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.TopologyRequirement)
    private static final csi.v0.Csi.TopologyRequirement DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.TopologyRequirement();
    }

    public static csi.v0.Csi.TopologyRequirement getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TopologyRequirement>
        PARSER = new com.google.protobuf.AbstractParser<TopologyRequirement>() {
      @java.lang.Override
      public TopologyRequirement parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new TopologyRequirement(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<TopologyRequirement> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TopologyRequirement> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.TopologyRequirement getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TopologyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.Topology)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */
    int getSegmentsCount();
    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */
    boolean containsSegments(
        java.lang.String key);
    /**
     * Use {@link #getSegmentsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getSegments();
    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getSegmentsMap();
    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */

    java.lang.String getSegmentsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */

    java.lang.String getSegmentsOrThrow(
        java.lang.String key);
  }
  /**
   * <pre>
   * Topology is a map of topological domains to topological segments.
   * A topological domain is a sub-division of a cluster, like "region",
   * "zone", "rack", etc.
   * A topological segment is a specific instance of a topological domain,
   * like "zone3", "rack3", etc.
   * For example {"com.company/zone": "Z1", "com.company/rack": "R3"}
   * Valid keys have two segments: an optional prefix and name, separated
   * by a slash (/), for example: "com.company.example/zone".
   * The key name segment is required. The prefix is optional.
   * Both the key name and the prefix MUST each be 63 characters or less,
   * begin and end with an alphanumeric character ([a-z0-9A-Z]) and
   * contain only dashes (-), underscores (_), dots (.), or alphanumerics
   * in between, for example "zone".
   * The key prefix MUST follow reverse domain name notation format
   * (https://en.wikipedia.org/wiki/Reverse_domain_name_notation).
   * The key prefix SHOULD include the plugin's host company name and/or
   * the plugin name, to minimize the possibility of collisions with keys
   * from other plugins.
   * If a key prefix is specified, it MUST be identical across all
   * topology keys returned by the SP (across all RPCs).
   * Keys MUST be case-insensitive. Meaning the keys "Zone" and "zone"
   * MUST not both exist.
   * Each value (topological segment) MUST contain 1 or more strings.
   * Each string MUST be 63 characters or less and begin and end with an
   * alphanumeric character with '-', '_', '.', or alphanumerics in
   * between.
   * </pre>
   *
   * Protobuf type {@code csi.v0.Topology}
   */
  public  static final class Topology extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.Topology)
      TopologyOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Topology.newBuilder() to construct.
    private Topology(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Topology() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Topology(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                segments_ = com.google.protobuf.MapField.newMapField(
                    SegmentsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000001;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              segments__ = input.readMessage(
                  SegmentsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              segments_.getMutableMap().put(
                  segments__.getKey(), segments__.getValue());
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_Topology_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 1:
          return internalGetSegments();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_Topology_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.Topology.class, csi.v0.Csi.Topology.Builder.class);
    }

    public static final int SEGMENTS_FIELD_NUMBER = 1;
    private static final class SegmentsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_Topology_SegmentsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> segments_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetSegments() {
      if (segments_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            SegmentsDefaultEntryHolder.defaultEntry);
      }
      return segments_;
    }

    public int getSegmentsCount() {
      return internalGetSegments().getMap().size();
    }
    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */

    public boolean containsSegments(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetSegments().getMap().containsKey(key);
    }
    /**
     * Use {@link #getSegmentsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getSegments() {
      return getSegmentsMap();
    }
    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getSegmentsMap() {
      return internalGetSegments().getMap();
    }
    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */

    public java.lang.String getSegmentsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSegments().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;string, string&gt; segments = 1;</code>
     */

    public java.lang.String getSegmentsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetSegments().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetSegments(),
          SegmentsDefaultEntryHolder.defaultEntry,
          1);
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetSegments().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        segments__ = SegmentsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, segments__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.Topology)) {
        return super.equals(obj);
      }
      csi.v0.Csi.Topology other = (csi.v0.Csi.Topology) obj;

      boolean result = true;
      result = result && internalGetSegments().equals(
          other.internalGetSegments());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (!internalGetSegments().getMap().isEmpty()) {
        hash = (37 * hash) + SEGMENTS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetSegments().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.Topology parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.Topology parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.Topology parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.Topology parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.Topology parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.Topology parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.Topology parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.Topology parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.Topology parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.Topology parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.Topology parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.Topology parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.Topology prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Topology is a map of topological domains to topological segments.
     * A topological domain is a sub-division of a cluster, like "region",
     * "zone", "rack", etc.
     * A topological segment is a specific instance of a topological domain,
     * like "zone3", "rack3", etc.
     * For example {"com.company/zone": "Z1", "com.company/rack": "R3"}
     * Valid keys have two segments: an optional prefix and name, separated
     * by a slash (/), for example: "com.company.example/zone".
     * The key name segment is required. The prefix is optional.
     * Both the key name and the prefix MUST each be 63 characters or less,
     * begin and end with an alphanumeric character ([a-z0-9A-Z]) and
     * contain only dashes (-), underscores (_), dots (.), or alphanumerics
     * in between, for example "zone".
     * The key prefix MUST follow reverse domain name notation format
     * (https://en.wikipedia.org/wiki/Reverse_domain_name_notation).
     * The key prefix SHOULD include the plugin's host company name and/or
     * the plugin name, to minimize the possibility of collisions with keys
     * from other plugins.
     * If a key prefix is specified, it MUST be identical across all
     * topology keys returned by the SP (across all RPCs).
     * Keys MUST be case-insensitive. Meaning the keys "Zone" and "zone"
     * MUST not both exist.
     * Each value (topological segment) MUST contain 1 or more strings.
     * Each string MUST be 63 characters or less and begin and end with an
     * alphanumeric character with '-', '_', '.', or alphanumerics in
     * between.
     * </pre>
     *
     * Protobuf type {@code csi.v0.Topology}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.Topology)
        csi.v0.Csi.TopologyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_Topology_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetSegments();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetMutableSegments();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_Topology_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.Topology.class, csi.v0.Csi.Topology.Builder.class);
      }

      // Construct using csi.v0.Csi.Topology.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        internalGetMutableSegments().clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_Topology_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.Topology getDefaultInstanceForType() {
        return csi.v0.Csi.Topology.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.Topology build() {
        csi.v0.Csi.Topology result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.Topology buildPartial() {
        csi.v0.Csi.Topology result = new csi.v0.Csi.Topology(this);
        int from_bitField0_ = bitField0_;
        result.segments_ = internalGetSegments();
        result.segments_.makeImmutable();
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.Topology) {
          return mergeFrom((csi.v0.Csi.Topology)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.Topology other) {
        if (other == csi.v0.Csi.Topology.getDefaultInstance()) return this;
        internalGetMutableSegments().mergeFrom(
            other.internalGetSegments());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.Topology parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.Topology) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> segments_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetSegments() {
        if (segments_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              SegmentsDefaultEntryHolder.defaultEntry);
        }
        return segments_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableSegments() {
        onChanged();;
        if (segments_ == null) {
          segments_ = com.google.protobuf.MapField.newMapField(
              SegmentsDefaultEntryHolder.defaultEntry);
        }
        if (!segments_.isMutable()) {
          segments_ = segments_.copy();
        }
        return segments_;
      }

      public int getSegmentsCount() {
        return internalGetSegments().getMap().size();
      }
      /**
       * <code>map&lt;string, string&gt; segments = 1;</code>
       */

      public boolean containsSegments(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetSegments().getMap().containsKey(key);
      }
      /**
       * Use {@link #getSegmentsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getSegments() {
        return getSegmentsMap();
      }
      /**
       * <code>map&lt;string, string&gt; segments = 1;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getSegmentsMap() {
        return internalGetSegments().getMap();
      }
      /**
       * <code>map&lt;string, string&gt; segments = 1;</code>
       */

      public java.lang.String getSegmentsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSegments().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;string, string&gt; segments = 1;</code>
       */

      public java.lang.String getSegmentsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetSegments().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearSegments() {
        internalGetMutableSegments().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <code>map&lt;string, string&gt; segments = 1;</code>
       */

      public Builder removeSegments(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSegments().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableSegments() {
        return internalGetMutableSegments().getMutableMap();
      }
      /**
       * <code>map&lt;string, string&gt; segments = 1;</code>
       */
      public Builder putSegments(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableSegments().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, string&gt; segments = 1;</code>
       */

      public Builder putAllSegments(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableSegments().getMutableMap()
            .putAll(values);
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.Topology)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.Topology)
    private static final csi.v0.Csi.Topology DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.Topology();
    }

    public static csi.v0.Csi.Topology getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Topology>
        PARSER = new com.google.protobuf.AbstractParser<Topology>() {
      @java.lang.Override
      public Topology parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Topology(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Topology> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Topology> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.Topology getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeleteVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.DeleteVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume to be deprovisioned.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume to be deprovisioned.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_delete_secrets = 2;</code>
     */
    int getControllerDeleteSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_delete_secrets = 2;</code>
     */
    boolean containsControllerDeleteSecrets(
        java.lang.String key);
    /**
     * Use {@link #getControllerDeleteSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getControllerDeleteSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_delete_secrets = 2;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getControllerDeleteSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_delete_secrets = 2;</code>
     */

    java.lang.String getControllerDeleteSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_delete_secrets = 2;</code>
     */

    java.lang.String getControllerDeleteSecretsOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v0.DeleteVolumeRequest}
   */
  public  static final class DeleteVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.DeleteVolumeRequest)
      DeleteVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DeleteVolumeRequest.newBuilder() to construct.
    private DeleteVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DeleteVolumeRequest() {
      volumeId_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DeleteVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                controllerDeleteSecrets_ = com.google.protobuf.MapField.newMapField(
                    ControllerDeleteSecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000002;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              controllerDeleteSecrets__ = input.readMessage(
                  ControllerDeleteSecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              controllerDeleteSecrets_.getMutableMap().put(
                  controllerDeleteSecrets__.getKey(), controllerDeleteSecrets__.getValue());
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_DeleteVolumeRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetControllerDeleteSecrets();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_DeleteVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.DeleteVolumeRequest.class, csi.v0.Csi.DeleteVolumeRequest.Builder.class);
    }

    private int bitField0_;
    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume to be deprovisioned.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume to be deprovisioned.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CONTROLLER_DELETE_SECRETS_FIELD_NUMBER = 2;
    private static final class ControllerDeleteSecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_DeleteVolumeRequest_ControllerDeleteSecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> controllerDeleteSecrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetControllerDeleteSecrets() {
      if (controllerDeleteSecrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ControllerDeleteSecretsDefaultEntryHolder.defaultEntry);
      }
      return controllerDeleteSecrets_;
    }

    public int getControllerDeleteSecretsCount() {
      return internalGetControllerDeleteSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_delete_secrets = 2;</code>
     */

    public boolean containsControllerDeleteSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetControllerDeleteSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getControllerDeleteSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getControllerDeleteSecrets() {
      return getControllerDeleteSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_delete_secrets = 2;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getControllerDeleteSecretsMap() {
      return internalGetControllerDeleteSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_delete_secrets = 2;</code>
     */

    public java.lang.String getControllerDeleteSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetControllerDeleteSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete volume deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_delete_secrets = 2;</code>
     */

    public java.lang.String getControllerDeleteSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetControllerDeleteSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetControllerDeleteSecrets(),
          ControllerDeleteSecretsDefaultEntryHolder.defaultEntry,
          2);
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetControllerDeleteSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        controllerDeleteSecrets__ = ControllerDeleteSecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, controllerDeleteSecrets__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.DeleteVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.DeleteVolumeRequest other = (csi.v0.Csi.DeleteVolumeRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && internalGetControllerDeleteSecrets().equals(
          other.internalGetControllerDeleteSecrets());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      if (!internalGetControllerDeleteSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + CONTROLLER_DELETE_SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetControllerDeleteSecrets().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.DeleteVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.DeleteVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.DeleteVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.DeleteVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.DeleteVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.DeleteVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.DeleteVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.DeleteVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.DeleteVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.DeleteVolumeRequest)
        csi.v0.Csi.DeleteVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_DeleteVolumeRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetControllerDeleteSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutableControllerDeleteSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_DeleteVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.DeleteVolumeRequest.class, csi.v0.Csi.DeleteVolumeRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.DeleteVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        internalGetMutableControllerDeleteSecrets().clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_DeleteVolumeRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.DeleteVolumeRequest getDefaultInstanceForType() {
        return csi.v0.Csi.DeleteVolumeRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.DeleteVolumeRequest build() {
        csi.v0.Csi.DeleteVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.DeleteVolumeRequest buildPartial() {
        csi.v0.Csi.DeleteVolumeRequest result = new csi.v0.Csi.DeleteVolumeRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.volumeId_ = volumeId_;
        result.controllerDeleteSecrets_ = internalGetControllerDeleteSecrets();
        result.controllerDeleteSecrets_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.DeleteVolumeRequest) {
          return mergeFrom((csi.v0.Csi.DeleteVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.DeleteVolumeRequest other) {
        if (other == csi.v0.Csi.DeleteVolumeRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        internalGetMutableControllerDeleteSecrets().mergeFrom(
            other.internalGetControllerDeleteSecrets());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.DeleteVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.DeleteVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume to be deprovisioned.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to be deprovisioned.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to be deprovisioned.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to be deprovisioned.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to be deprovisioned.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> controllerDeleteSecrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetControllerDeleteSecrets() {
        if (controllerDeleteSecrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ControllerDeleteSecretsDefaultEntryHolder.defaultEntry);
        }
        return controllerDeleteSecrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableControllerDeleteSecrets() {
        onChanged();;
        if (controllerDeleteSecrets_ == null) {
          controllerDeleteSecrets_ = com.google.protobuf.MapField.newMapField(
              ControllerDeleteSecretsDefaultEntryHolder.defaultEntry);
        }
        if (!controllerDeleteSecrets_.isMutable()) {
          controllerDeleteSecrets_ = controllerDeleteSecrets_.copy();
        }
        return controllerDeleteSecrets_;
      }

      public int getControllerDeleteSecretsCount() {
        return internalGetControllerDeleteSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_delete_secrets = 2;</code>
       */

      public boolean containsControllerDeleteSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetControllerDeleteSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getControllerDeleteSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getControllerDeleteSecrets() {
        return getControllerDeleteSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_delete_secrets = 2;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getControllerDeleteSecretsMap() {
        return internalGetControllerDeleteSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_delete_secrets = 2;</code>
       */

      public java.lang.String getControllerDeleteSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetControllerDeleteSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_delete_secrets = 2;</code>
       */

      public java.lang.String getControllerDeleteSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetControllerDeleteSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearControllerDeleteSecrets() {
        internalGetMutableControllerDeleteSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_delete_secrets = 2;</code>
       */

      public Builder removeControllerDeleteSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableControllerDeleteSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableControllerDeleteSecrets() {
        return internalGetMutableControllerDeleteSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_delete_secrets = 2;</code>
       */
      public Builder putControllerDeleteSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableControllerDeleteSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete volume deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_delete_secrets = 2;</code>
       */

      public Builder putAllControllerDeleteSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableControllerDeleteSecrets().getMutableMap()
            .putAll(values);
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.DeleteVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.DeleteVolumeRequest)
    private static final csi.v0.Csi.DeleteVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.DeleteVolumeRequest();
    }

    public static csi.v0.Csi.DeleteVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DeleteVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<DeleteVolumeRequest>() {
      @java.lang.Override
      public DeleteVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new DeleteVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DeleteVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeleteVolumeRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.DeleteVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeleteVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.DeleteVolumeResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v0.DeleteVolumeResponse}
   */
  public  static final class DeleteVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.DeleteVolumeResponse)
      DeleteVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DeleteVolumeResponse.newBuilder() to construct.
    private DeleteVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DeleteVolumeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DeleteVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_DeleteVolumeResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_DeleteVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.DeleteVolumeResponse.class, csi.v0.Csi.DeleteVolumeResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.DeleteVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.DeleteVolumeResponse other = (csi.v0.Csi.DeleteVolumeResponse) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.DeleteVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.DeleteVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.DeleteVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.DeleteVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.DeleteVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.DeleteVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.DeleteVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.DeleteVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v0.DeleteVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.DeleteVolumeResponse)
        csi.v0.Csi.DeleteVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_DeleteVolumeResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_DeleteVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.DeleteVolumeResponse.class, csi.v0.Csi.DeleteVolumeResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.DeleteVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_DeleteVolumeResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.DeleteVolumeResponse getDefaultInstanceForType() {
        return csi.v0.Csi.DeleteVolumeResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.DeleteVolumeResponse build() {
        csi.v0.Csi.DeleteVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.DeleteVolumeResponse buildPartial() {
        csi.v0.Csi.DeleteVolumeResponse result = new csi.v0.Csi.DeleteVolumeResponse(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.DeleteVolumeResponse) {
          return mergeFrom((csi.v0.Csi.DeleteVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.DeleteVolumeResponse other) {
        if (other == csi.v0.Csi.DeleteVolumeResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.DeleteVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.DeleteVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.DeleteVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.DeleteVolumeResponse)
    private static final csi.v0.Csi.DeleteVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.DeleteVolumeResponse();
    }

    public static csi.v0.Csi.DeleteVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DeleteVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<DeleteVolumeResponse>() {
      @java.lang.Override
      public DeleteVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new DeleteVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DeleteVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeleteVolumeResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.DeleteVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerPublishVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.ControllerPublishVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume to be used on a node.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume to be used on a node.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * The ID of the node. This field is REQUIRED. The CO SHALL set this
     * field to match the node ID returned by `NodeGetInfo`.
     * </pre>
     *
     * <code>string node_id = 2;</code>
     */
    java.lang.String getNodeId();
    /**
     * <pre>
     * The ID of the node. This field is REQUIRED. The CO SHALL set this
     * field to match the node ID returned by `NodeGetInfo`.
     * </pre>
     *
     * <code>string node_id = 2;</code>
     */
    com.google.protobuf.ByteString
        getNodeIdBytes();

    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 3;</code>
     */
    boolean hasVolumeCapability();
    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 3;</code>
     */
    csi.v0.Csi.VolumeCapability getVolumeCapability();
    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 3;</code>
     */
    csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder();

    /**
     * <pre>
     * Whether to publish the volume in readonly mode. This field is
     * REQUIRED.
     * </pre>
     *
     * <code>bool readonly = 4;</code>
     */
    boolean getReadonly();

    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_publish_secrets = 5;</code>
     */
    int getControllerPublishSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_publish_secrets = 5;</code>
     */
    boolean containsControllerPublishSecrets(
        java.lang.String key);
    /**
     * Use {@link #getControllerPublishSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getControllerPublishSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_publish_secrets = 5;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getControllerPublishSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_publish_secrets = 5;</code>
     */

    java.lang.String getControllerPublishSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_publish_secrets = 5;</code>
     */

    java.lang.String getControllerPublishSecretsOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Attributes of the volume to be used on a node. This field is
     * OPTIONAL and MUST match the attributes of the Volume identified
     * by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */
    int getVolumeAttributesCount();
    /**
     * <pre>
     * Attributes of the volume to be used on a node. This field is
     * OPTIONAL and MUST match the attributes of the Volume identified
     * by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */
    boolean containsVolumeAttributes(
        java.lang.String key);
    /**
     * Use {@link #getVolumeAttributesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeAttributes();
    /**
     * <pre>
     * Attributes of the volume to be used on a node. This field is
     * OPTIONAL and MUST match the attributes of the Volume identified
     * by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeAttributesMap();
    /**
     * <pre>
     * Attributes of the volume to be used on a node. This field is
     * OPTIONAL and MUST match the attributes of the Volume identified
     * by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */

    java.lang.String getVolumeAttributesOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Attributes of the volume to be used on a node. This field is
     * OPTIONAL and MUST match the attributes of the Volume identified
     * by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */

    java.lang.String getVolumeAttributesOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v0.ControllerPublishVolumeRequest}
   */
  public  static final class ControllerPublishVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.ControllerPublishVolumeRequest)
      ControllerPublishVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ControllerPublishVolumeRequest.newBuilder() to construct.
    private ControllerPublishVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ControllerPublishVolumeRequest() {
      volumeId_ = "";
      nodeId_ = "";
      readonly_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ControllerPublishVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              nodeId_ = s;
              break;
            }
            case 26: {
              csi.v0.Csi.VolumeCapability.Builder subBuilder = null;
              if (volumeCapability_ != null) {
                subBuilder = volumeCapability_.toBuilder();
              }
              volumeCapability_ = input.readMessage(csi.v0.Csi.VolumeCapability.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(volumeCapability_);
                volumeCapability_ = subBuilder.buildPartial();
              }

              break;
            }
            case 32: {

              readonly_ = input.readBool();
              break;
            }
            case 42: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                controllerPublishSecrets_ = com.google.protobuf.MapField.newMapField(
                    ControllerPublishSecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000010;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              controllerPublishSecrets__ = input.readMessage(
                  ControllerPublishSecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              controllerPublishSecrets_.getMutableMap().put(
                  controllerPublishSecrets__.getKey(), controllerPublishSecrets__.getValue());
              break;
            }
            case 50: {
              if (!((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
                volumeAttributes_ = com.google.protobuf.MapField.newMapField(
                    VolumeAttributesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000020;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              volumeAttributes__ = input.readMessage(
                  VolumeAttributesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              volumeAttributes_.getMutableMap().put(
                  volumeAttributes__.getKey(), volumeAttributes__.getValue());
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_ControllerPublishVolumeRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 5:
          return internalGetControllerPublishSecrets();
        case 6:
          return internalGetVolumeAttributes();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_ControllerPublishVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.ControllerPublishVolumeRequest.class, csi.v0.Csi.ControllerPublishVolumeRequest.Builder.class);
    }

    private int bitField0_;
    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume to be used on a node.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume to be used on a node.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NODE_ID_FIELD_NUMBER = 2;
    private volatile java.lang.Object nodeId_;
    /**
     * <pre>
     * The ID of the node. This field is REQUIRED. The CO SHALL set this
     * field to match the node ID returned by `NodeGetInfo`.
     * </pre>
     *
     * <code>string node_id = 2;</code>
     */
    public java.lang.String getNodeId() {
      java.lang.Object ref = nodeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        nodeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the node. This field is REQUIRED. The CO SHALL set this
     * field to match the node ID returned by `NodeGetInfo`.
     * </pre>
     *
     * <code>string node_id = 2;</code>
     */
    public com.google.protobuf.ByteString
        getNodeIdBytes() {
      java.lang.Object ref = nodeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nodeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VOLUME_CAPABILITY_FIELD_NUMBER = 3;
    private csi.v0.Csi.VolumeCapability volumeCapability_;
    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 3;</code>
     */
    public boolean hasVolumeCapability() {
      return volumeCapability_ != null;
    }
    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 3;</code>
     */
    public csi.v0.Csi.VolumeCapability getVolumeCapability() {
      return volumeCapability_ == null ? csi.v0.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
    }
    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 3;</code>
     */
    public csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder() {
      return getVolumeCapability();
    }

    public static final int READONLY_FIELD_NUMBER = 4;
    private boolean readonly_;
    /**
     * <pre>
     * Whether to publish the volume in readonly mode. This field is
     * REQUIRED.
     * </pre>
     *
     * <code>bool readonly = 4;</code>
     */
    public boolean getReadonly() {
      return readonly_;
    }

    public static final int CONTROLLER_PUBLISH_SECRETS_FIELD_NUMBER = 5;
    private static final class ControllerPublishSecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_ControllerPublishVolumeRequest_ControllerPublishSecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> controllerPublishSecrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetControllerPublishSecrets() {
      if (controllerPublishSecrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ControllerPublishSecretsDefaultEntryHolder.defaultEntry);
      }
      return controllerPublishSecrets_;
    }

    public int getControllerPublishSecretsCount() {
      return internalGetControllerPublishSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_publish_secrets = 5;</code>
     */

    public boolean containsControllerPublishSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetControllerPublishSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getControllerPublishSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getControllerPublishSecrets() {
      return getControllerPublishSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_publish_secrets = 5;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getControllerPublishSecretsMap() {
      return internalGetControllerPublishSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_publish_secrets = 5;</code>
     */

    public java.lang.String getControllerPublishSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetControllerPublishSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete controller publish volume
     * request. This field is OPTIONAL. Refer to the
     * `Secrets Requirements` section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_publish_secrets = 5;</code>
     */

    public java.lang.String getControllerPublishSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetControllerPublishSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int VOLUME_ATTRIBUTES_FIELD_NUMBER = 6;
    private static final class VolumeAttributesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_ControllerPublishVolumeRequest_VolumeAttributesEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> volumeAttributes_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetVolumeAttributes() {
      if (volumeAttributes_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            VolumeAttributesDefaultEntryHolder.defaultEntry);
      }
      return volumeAttributes_;
    }

    public int getVolumeAttributesCount() {
      return internalGetVolumeAttributes().getMap().size();
    }
    /**
     * <pre>
     * Attributes of the volume to be used on a node. This field is
     * OPTIONAL and MUST match the attributes of the Volume identified
     * by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */

    public boolean containsVolumeAttributes(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetVolumeAttributes().getMap().containsKey(key);
    }
    /**
     * Use {@link #getVolumeAttributesMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getVolumeAttributes() {
      return getVolumeAttributesMap();
    }
    /**
     * <pre>
     * Attributes of the volume to be used on a node. This field is
     * OPTIONAL and MUST match the attributes of the Volume identified
     * by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getVolumeAttributesMap() {
      return internalGetVolumeAttributes().getMap();
    }
    /**
     * <pre>
     * Attributes of the volume to be used on a node. This field is
     * OPTIONAL and MUST match the attributes of the Volume identified
     * by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */

    public java.lang.String getVolumeAttributesOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeAttributes().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Attributes of the volume to be used on a node. This field is
     * OPTIONAL and MUST match the attributes of the Volume identified
     * by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */

    public java.lang.String getVolumeAttributesOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeAttributes().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      if (!getNodeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, nodeId_);
      }
      if (volumeCapability_ != null) {
        output.writeMessage(3, getVolumeCapability());
      }
      if (readonly_ != false) {
        output.writeBool(4, readonly_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetControllerPublishSecrets(),
          ControllerPublishSecretsDefaultEntryHolder.defaultEntry,
          5);
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetVolumeAttributes(),
          VolumeAttributesDefaultEntryHolder.defaultEntry,
          6);
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      if (!getNodeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, nodeId_);
      }
      if (volumeCapability_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getVolumeCapability());
      }
      if (readonly_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, readonly_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetControllerPublishSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        controllerPublishSecrets__ = ControllerPublishSecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(5, controllerPublishSecrets__);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetVolumeAttributes().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        volumeAttributes__ = VolumeAttributesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(6, volumeAttributes__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.ControllerPublishVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.ControllerPublishVolumeRequest other = (csi.v0.Csi.ControllerPublishVolumeRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && getNodeId()
          .equals(other.getNodeId());
      result = result && (hasVolumeCapability() == other.hasVolumeCapability());
      if (hasVolumeCapability()) {
        result = result && getVolumeCapability()
            .equals(other.getVolumeCapability());
      }
      result = result && (getReadonly()
          == other.getReadonly());
      result = result && internalGetControllerPublishSecrets().equals(
          other.internalGetControllerPublishSecrets());
      result = result && internalGetVolumeAttributes().equals(
          other.internalGetVolumeAttributes());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      hash = (37 * hash) + NODE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getNodeId().hashCode();
      if (hasVolumeCapability()) {
        hash = (37 * hash) + VOLUME_CAPABILITY_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeCapability().hashCode();
      }
      hash = (37 * hash) + READONLY_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getReadonly());
      if (!internalGetControllerPublishSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + CONTROLLER_PUBLISH_SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetControllerPublishSecrets().hashCode();
      }
      if (!internalGetVolumeAttributes().getMap().isEmpty()) {
        hash = (37 * hash) + VOLUME_ATTRIBUTES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetVolumeAttributes().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.ControllerPublishVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerPublishVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerPublishVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerPublishVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerPublishVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerPublishVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerPublishVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerPublishVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerPublishVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerPublishVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerPublishVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerPublishVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.ControllerPublishVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.ControllerPublishVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.ControllerPublishVolumeRequest)
        csi.v0.Csi.ControllerPublishVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerPublishVolumeRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 5:
            return internalGetControllerPublishSecrets();
          case 6:
            return internalGetVolumeAttributes();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 5:
            return internalGetMutableControllerPublishSecrets();
          case 6:
            return internalGetMutableVolumeAttributes();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerPublishVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ControllerPublishVolumeRequest.class, csi.v0.Csi.ControllerPublishVolumeRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.ControllerPublishVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        nodeId_ = "";

        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = null;
        } else {
          volumeCapability_ = null;
          volumeCapabilityBuilder_ = null;
        }
        readonly_ = false;

        internalGetMutableControllerPublishSecrets().clear();
        internalGetMutableVolumeAttributes().clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerPublishVolumeRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerPublishVolumeRequest getDefaultInstanceForType() {
        return csi.v0.Csi.ControllerPublishVolumeRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerPublishVolumeRequest build() {
        csi.v0.Csi.ControllerPublishVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerPublishVolumeRequest buildPartial() {
        csi.v0.Csi.ControllerPublishVolumeRequest result = new csi.v0.Csi.ControllerPublishVolumeRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.volumeId_ = volumeId_;
        result.nodeId_ = nodeId_;
        if (volumeCapabilityBuilder_ == null) {
          result.volumeCapability_ = volumeCapability_;
        } else {
          result.volumeCapability_ = volumeCapabilityBuilder_.build();
        }
        result.readonly_ = readonly_;
        result.controllerPublishSecrets_ = internalGetControllerPublishSecrets();
        result.controllerPublishSecrets_.makeImmutable();
        result.volumeAttributes_ = internalGetVolumeAttributes();
        result.volumeAttributes_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.ControllerPublishVolumeRequest) {
          return mergeFrom((csi.v0.Csi.ControllerPublishVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.ControllerPublishVolumeRequest other) {
        if (other == csi.v0.Csi.ControllerPublishVolumeRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        if (!other.getNodeId().isEmpty()) {
          nodeId_ = other.nodeId_;
          onChanged();
        }
        if (other.hasVolumeCapability()) {
          mergeVolumeCapability(other.getVolumeCapability());
        }
        if (other.getReadonly() != false) {
          setReadonly(other.getReadonly());
        }
        internalGetMutableControllerPublishSecrets().mergeFrom(
            other.internalGetControllerPublishSecrets());
        internalGetMutableVolumeAttributes().mergeFrom(
            other.internalGetVolumeAttributes());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.ControllerPublishVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.ControllerPublishVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume to be used on a node.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to be used on a node.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to be used on a node.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to be used on a node.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to be used on a node.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object nodeId_ = "";
      /**
       * <pre>
       * The ID of the node. This field is REQUIRED. The CO SHALL set this
       * field to match the node ID returned by `NodeGetInfo`.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public java.lang.String getNodeId() {
        java.lang.Object ref = nodeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          nodeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the node. This field is REQUIRED. The CO SHALL set this
       * field to match the node ID returned by `NodeGetInfo`.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public com.google.protobuf.ByteString
          getNodeIdBytes() {
        java.lang.Object ref = nodeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nodeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the node. This field is REQUIRED. The CO SHALL set this
       * field to match the node ID returned by `NodeGetInfo`.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public Builder setNodeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        nodeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the node. This field is REQUIRED. The CO SHALL set this
       * field to match the node ID returned by `NodeGetInfo`.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public Builder clearNodeId() {
        
        nodeId_ = getDefaultInstance().getNodeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the node. This field is REQUIRED. The CO SHALL set this
       * field to match the node ID returned by `NodeGetInfo`.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public Builder setNodeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        nodeId_ = value;
        onChanged();
        return this;
      }

      private csi.v0.Csi.VolumeCapability volumeCapability_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder> volumeCapabilityBuilder_;
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 3;</code>
       */
      public boolean hasVolumeCapability() {
        return volumeCapabilityBuilder_ != null || volumeCapability_ != null;
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 3;</code>
       */
      public csi.v0.Csi.VolumeCapability getVolumeCapability() {
        if (volumeCapabilityBuilder_ == null) {
          return volumeCapability_ == null ? csi.v0.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
        } else {
          return volumeCapabilityBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 3;</code>
       */
      public Builder setVolumeCapability(csi.v0.Csi.VolumeCapability value) {
        if (volumeCapabilityBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          volumeCapability_ = value;
          onChanged();
        } else {
          volumeCapabilityBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 3;</code>
       */
      public Builder setVolumeCapability(
          csi.v0.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = builderForValue.build();
          onChanged();
        } else {
          volumeCapabilityBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 3;</code>
       */
      public Builder mergeVolumeCapability(csi.v0.Csi.VolumeCapability value) {
        if (volumeCapabilityBuilder_ == null) {
          if (volumeCapability_ != null) {
            volumeCapability_ =
              csi.v0.Csi.VolumeCapability.newBuilder(volumeCapability_).mergeFrom(value).buildPartial();
          } else {
            volumeCapability_ = value;
          }
          onChanged();
        } else {
          volumeCapabilityBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 3;</code>
       */
      public Builder clearVolumeCapability() {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = null;
          onChanged();
        } else {
          volumeCapability_ = null;
          volumeCapabilityBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 3;</code>
       */
      public csi.v0.Csi.VolumeCapability.Builder getVolumeCapabilityBuilder() {
        
        onChanged();
        return getVolumeCapabilityFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 3;</code>
       */
      public csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder() {
        if (volumeCapabilityBuilder_ != null) {
          return volumeCapabilityBuilder_.getMessageOrBuilder();
        } else {
          return volumeCapability_ == null ?
              csi.v0.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
        }
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder> 
          getVolumeCapabilityFieldBuilder() {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapabilityBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder>(
                  getVolumeCapability(),
                  getParentForChildren(),
                  isClean());
          volumeCapability_ = null;
        }
        return volumeCapabilityBuilder_;
      }

      private boolean readonly_ ;
      /**
       * <pre>
       * Whether to publish the volume in readonly mode. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>bool readonly = 4;</code>
       */
      public boolean getReadonly() {
        return readonly_;
      }
      /**
       * <pre>
       * Whether to publish the volume in readonly mode. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>bool readonly = 4;</code>
       */
      public Builder setReadonly(boolean value) {
        
        readonly_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to publish the volume in readonly mode. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>bool readonly = 4;</code>
       */
      public Builder clearReadonly() {
        
        readonly_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> controllerPublishSecrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetControllerPublishSecrets() {
        if (controllerPublishSecrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ControllerPublishSecretsDefaultEntryHolder.defaultEntry);
        }
        return controllerPublishSecrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableControllerPublishSecrets() {
        onChanged();;
        if (controllerPublishSecrets_ == null) {
          controllerPublishSecrets_ = com.google.protobuf.MapField.newMapField(
              ControllerPublishSecretsDefaultEntryHolder.defaultEntry);
        }
        if (!controllerPublishSecrets_.isMutable()) {
          controllerPublishSecrets_ = controllerPublishSecrets_.copy();
        }
        return controllerPublishSecrets_;
      }

      public int getControllerPublishSecretsCount() {
        return internalGetControllerPublishSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller publish volume
       * request. This field is OPTIONAL. Refer to the
       * `Secrets Requirements` section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_publish_secrets = 5;</code>
       */

      public boolean containsControllerPublishSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetControllerPublishSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getControllerPublishSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getControllerPublishSecrets() {
        return getControllerPublishSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller publish volume
       * request. This field is OPTIONAL. Refer to the
       * `Secrets Requirements` section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_publish_secrets = 5;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getControllerPublishSecretsMap() {
        return internalGetControllerPublishSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller publish volume
       * request. This field is OPTIONAL. Refer to the
       * `Secrets Requirements` section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_publish_secrets = 5;</code>
       */

      public java.lang.String getControllerPublishSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetControllerPublishSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller publish volume
       * request. This field is OPTIONAL. Refer to the
       * `Secrets Requirements` section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_publish_secrets = 5;</code>
       */

      public java.lang.String getControllerPublishSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetControllerPublishSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearControllerPublishSecrets() {
        internalGetMutableControllerPublishSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller publish volume
       * request. This field is OPTIONAL. Refer to the
       * `Secrets Requirements` section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_publish_secrets = 5;</code>
       */

      public Builder removeControllerPublishSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableControllerPublishSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableControllerPublishSecrets() {
        return internalGetMutableControllerPublishSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller publish volume
       * request. This field is OPTIONAL. Refer to the
       * `Secrets Requirements` section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_publish_secrets = 5;</code>
       */
      public Builder putControllerPublishSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableControllerPublishSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller publish volume
       * request. This field is OPTIONAL. Refer to the
       * `Secrets Requirements` section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_publish_secrets = 5;</code>
       */

      public Builder putAllControllerPublishSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableControllerPublishSecrets().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> volumeAttributes_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetVolumeAttributes() {
        if (volumeAttributes_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              VolumeAttributesDefaultEntryHolder.defaultEntry);
        }
        return volumeAttributes_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableVolumeAttributes() {
        onChanged();;
        if (volumeAttributes_ == null) {
          volumeAttributes_ = com.google.protobuf.MapField.newMapField(
              VolumeAttributesDefaultEntryHolder.defaultEntry);
        }
        if (!volumeAttributes_.isMutable()) {
          volumeAttributes_ = volumeAttributes_.copy();
        }
        return volumeAttributes_;
      }

      public int getVolumeAttributesCount() {
        return internalGetVolumeAttributes().getMap().size();
      }
      /**
       * <pre>
       * Attributes of the volume to be used on a node. This field is
       * OPTIONAL and MUST match the attributes of the Volume identified
       * by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
       */

      public boolean containsVolumeAttributes(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetVolumeAttributes().getMap().containsKey(key);
      }
      /**
       * Use {@link #getVolumeAttributesMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getVolumeAttributes() {
        return getVolumeAttributesMap();
      }
      /**
       * <pre>
       * Attributes of the volume to be used on a node. This field is
       * OPTIONAL and MUST match the attributes of the Volume identified
       * by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getVolumeAttributesMap() {
        return internalGetVolumeAttributes().getMap();
      }
      /**
       * <pre>
       * Attributes of the volume to be used on a node. This field is
       * OPTIONAL and MUST match the attributes of the Volume identified
       * by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
       */

      public java.lang.String getVolumeAttributesOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeAttributes().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Attributes of the volume to be used on a node. This field is
       * OPTIONAL and MUST match the attributes of the Volume identified
       * by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
       */

      public java.lang.String getVolumeAttributesOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeAttributes().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearVolumeAttributes() {
        internalGetMutableVolumeAttributes().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Attributes of the volume to be used on a node. This field is
       * OPTIONAL and MUST match the attributes of the Volume identified
       * by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
       */

      public Builder removeVolumeAttributes(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeAttributes().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableVolumeAttributes() {
        return internalGetMutableVolumeAttributes().getMutableMap();
      }
      /**
       * <pre>
       * Attributes of the volume to be used on a node. This field is
       * OPTIONAL and MUST match the attributes of the Volume identified
       * by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
       */
      public Builder putVolumeAttributes(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeAttributes().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Attributes of the volume to be used on a node. This field is
       * OPTIONAL and MUST match the attributes of the Volume identified
       * by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
       */

      public Builder putAllVolumeAttributes(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableVolumeAttributes().getMutableMap()
            .putAll(values);
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.ControllerPublishVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.ControllerPublishVolumeRequest)
    private static final csi.v0.Csi.ControllerPublishVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.ControllerPublishVolumeRequest();
    }

    public static csi.v0.Csi.ControllerPublishVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerPublishVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<ControllerPublishVolumeRequest>() {
      @java.lang.Override
      public ControllerPublishVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ControllerPublishVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ControllerPublishVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerPublishVolumeRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.ControllerPublishVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerPublishVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.ControllerPublishVolumeResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The SP specific information that will be passed to the Plugin in
     * the subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * for the given volume.
     * This information is opaque to the CO. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 1;</code>
     */
    int getPublishInfoCount();
    /**
     * <pre>
     * The SP specific information that will be passed to the Plugin in
     * the subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * for the given volume.
     * This information is opaque to the CO. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 1;</code>
     */
    boolean containsPublishInfo(
        java.lang.String key);
    /**
     * Use {@link #getPublishInfoMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getPublishInfo();
    /**
     * <pre>
     * The SP specific information that will be passed to the Plugin in
     * the subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * for the given volume.
     * This information is opaque to the CO. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 1;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getPublishInfoMap();
    /**
     * <pre>
     * The SP specific information that will be passed to the Plugin in
     * the subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * for the given volume.
     * This information is opaque to the CO. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 1;</code>
     */

    java.lang.String getPublishInfoOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * The SP specific information that will be passed to the Plugin in
     * the subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * for the given volume.
     * This information is opaque to the CO. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 1;</code>
     */

    java.lang.String getPublishInfoOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v0.ControllerPublishVolumeResponse}
   */
  public  static final class ControllerPublishVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.ControllerPublishVolumeResponse)
      ControllerPublishVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ControllerPublishVolumeResponse.newBuilder() to construct.
    private ControllerPublishVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ControllerPublishVolumeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ControllerPublishVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                publishInfo_ = com.google.protobuf.MapField.newMapField(
                    PublishInfoDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000001;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              publishInfo__ = input.readMessage(
                  PublishInfoDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              publishInfo_.getMutableMap().put(
                  publishInfo__.getKey(), publishInfo__.getValue());
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_ControllerPublishVolumeResponse_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 1:
          return internalGetPublishInfo();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_ControllerPublishVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.ControllerPublishVolumeResponse.class, csi.v0.Csi.ControllerPublishVolumeResponse.Builder.class);
    }

    public static final int PUBLISH_INFO_FIELD_NUMBER = 1;
    private static final class PublishInfoDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_ControllerPublishVolumeResponse_PublishInfoEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> publishInfo_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetPublishInfo() {
      if (publishInfo_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            PublishInfoDefaultEntryHolder.defaultEntry);
      }
      return publishInfo_;
    }

    public int getPublishInfoCount() {
      return internalGetPublishInfo().getMap().size();
    }
    /**
     * <pre>
     * The SP specific information that will be passed to the Plugin in
     * the subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * for the given volume.
     * This information is opaque to the CO. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 1;</code>
     */

    public boolean containsPublishInfo(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetPublishInfo().getMap().containsKey(key);
    }
    /**
     * Use {@link #getPublishInfoMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getPublishInfo() {
      return getPublishInfoMap();
    }
    /**
     * <pre>
     * The SP specific information that will be passed to the Plugin in
     * the subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * for the given volume.
     * This information is opaque to the CO. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 1;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getPublishInfoMap() {
      return internalGetPublishInfo().getMap();
    }
    /**
     * <pre>
     * The SP specific information that will be passed to the Plugin in
     * the subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * for the given volume.
     * This information is opaque to the CO. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 1;</code>
     */

    public java.lang.String getPublishInfoOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetPublishInfo().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * The SP specific information that will be passed to the Plugin in
     * the subsequent `NodeStageVolume` or `NodePublishVolume` calls
     * for the given volume.
     * This information is opaque to the CO. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 1;</code>
     */

    public java.lang.String getPublishInfoOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetPublishInfo().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetPublishInfo(),
          PublishInfoDefaultEntryHolder.defaultEntry,
          1);
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetPublishInfo().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        publishInfo__ = PublishInfoDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, publishInfo__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.ControllerPublishVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.ControllerPublishVolumeResponse other = (csi.v0.Csi.ControllerPublishVolumeResponse) obj;

      boolean result = true;
      result = result && internalGetPublishInfo().equals(
          other.internalGetPublishInfo());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (!internalGetPublishInfo().getMap().isEmpty()) {
        hash = (37 * hash) + PUBLISH_INFO_FIELD_NUMBER;
        hash = (53 * hash) + internalGetPublishInfo().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.ControllerPublishVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerPublishVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerPublishVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerPublishVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerPublishVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerPublishVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerPublishVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerPublishVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerPublishVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerPublishVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerPublishVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerPublishVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.ControllerPublishVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.ControllerPublishVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.ControllerPublishVolumeResponse)
        csi.v0.Csi.ControllerPublishVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerPublishVolumeResponse_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetPublishInfo();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetMutablePublishInfo();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerPublishVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ControllerPublishVolumeResponse.class, csi.v0.Csi.ControllerPublishVolumeResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.ControllerPublishVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        internalGetMutablePublishInfo().clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerPublishVolumeResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerPublishVolumeResponse getDefaultInstanceForType() {
        return csi.v0.Csi.ControllerPublishVolumeResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerPublishVolumeResponse build() {
        csi.v0.Csi.ControllerPublishVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerPublishVolumeResponse buildPartial() {
        csi.v0.Csi.ControllerPublishVolumeResponse result = new csi.v0.Csi.ControllerPublishVolumeResponse(this);
        int from_bitField0_ = bitField0_;
        result.publishInfo_ = internalGetPublishInfo();
        result.publishInfo_.makeImmutable();
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.ControllerPublishVolumeResponse) {
          return mergeFrom((csi.v0.Csi.ControllerPublishVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.ControllerPublishVolumeResponse other) {
        if (other == csi.v0.Csi.ControllerPublishVolumeResponse.getDefaultInstance()) return this;
        internalGetMutablePublishInfo().mergeFrom(
            other.internalGetPublishInfo());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.ControllerPublishVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.ControllerPublishVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> publishInfo_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetPublishInfo() {
        if (publishInfo_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              PublishInfoDefaultEntryHolder.defaultEntry);
        }
        return publishInfo_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutablePublishInfo() {
        onChanged();;
        if (publishInfo_ == null) {
          publishInfo_ = com.google.protobuf.MapField.newMapField(
              PublishInfoDefaultEntryHolder.defaultEntry);
        }
        if (!publishInfo_.isMutable()) {
          publishInfo_ = publishInfo_.copy();
        }
        return publishInfo_;
      }

      public int getPublishInfoCount() {
        return internalGetPublishInfo().getMap().size();
      }
      /**
       * <pre>
       * The SP specific information that will be passed to the Plugin in
       * the subsequent `NodeStageVolume` or `NodePublishVolume` calls
       * for the given volume.
       * This information is opaque to the CO. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 1;</code>
       */

      public boolean containsPublishInfo(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetPublishInfo().getMap().containsKey(key);
      }
      /**
       * Use {@link #getPublishInfoMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getPublishInfo() {
        return getPublishInfoMap();
      }
      /**
       * <pre>
       * The SP specific information that will be passed to the Plugin in
       * the subsequent `NodeStageVolume` or `NodePublishVolume` calls
       * for the given volume.
       * This information is opaque to the CO. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 1;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getPublishInfoMap() {
        return internalGetPublishInfo().getMap();
      }
      /**
       * <pre>
       * The SP specific information that will be passed to the Plugin in
       * the subsequent `NodeStageVolume` or `NodePublishVolume` calls
       * for the given volume.
       * This information is opaque to the CO. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 1;</code>
       */

      public java.lang.String getPublishInfoOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetPublishInfo().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * The SP specific information that will be passed to the Plugin in
       * the subsequent `NodeStageVolume` or `NodePublishVolume` calls
       * for the given volume.
       * This information is opaque to the CO. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 1;</code>
       */

      public java.lang.String getPublishInfoOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetPublishInfo().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearPublishInfo() {
        internalGetMutablePublishInfo().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * The SP specific information that will be passed to the Plugin in
       * the subsequent `NodeStageVolume` or `NodePublishVolume` calls
       * for the given volume.
       * This information is opaque to the CO. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 1;</code>
       */

      public Builder removePublishInfo(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutablePublishInfo().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutablePublishInfo() {
        return internalGetMutablePublishInfo().getMutableMap();
      }
      /**
       * <pre>
       * The SP specific information that will be passed to the Plugin in
       * the subsequent `NodeStageVolume` or `NodePublishVolume` calls
       * for the given volume.
       * This information is opaque to the CO. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 1;</code>
       */
      public Builder putPublishInfo(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutablePublishInfo().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * The SP specific information that will be passed to the Plugin in
       * the subsequent `NodeStageVolume` or `NodePublishVolume` calls
       * for the given volume.
       * This information is opaque to the CO. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 1;</code>
       */

      public Builder putAllPublishInfo(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutablePublishInfo().getMutableMap()
            .putAll(values);
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.ControllerPublishVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.ControllerPublishVolumeResponse)
    private static final csi.v0.Csi.ControllerPublishVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.ControllerPublishVolumeResponse();
    }

    public static csi.v0.Csi.ControllerPublishVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerPublishVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<ControllerPublishVolumeResponse>() {
      @java.lang.Override
      public ControllerPublishVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ControllerPublishVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ControllerPublishVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerPublishVolumeResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.ControllerPublishVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerUnpublishVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.ControllerUnpublishVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
     * field to match the node ID returned by `NodeGetInfo` or leave it
     * unset. If the value is set, the SP MUST unpublish the volume from
     * the specified node. If the value is unset, the SP MUST unpublish
     * the volume from all nodes it is published to.
     * </pre>
     *
     * <code>string node_id = 2;</code>
     */
    java.lang.String getNodeId();
    /**
     * <pre>
     * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
     * field to match the node ID returned by `NodeGetInfo` or leave it
     * unset. If the value is set, the SP MUST unpublish the volume from
     * the specified node. If the value is unset, the SP MUST unpublish
     * the volume from all nodes it is published to.
     * </pre>
     *
     * <code>string node_id = 2;</code>
     */
    com.google.protobuf.ByteString
        getNodeIdBytes();

    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_unpublish_secrets = 3;</code>
     */
    int getControllerUnpublishSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_unpublish_secrets = 3;</code>
     */
    boolean containsControllerUnpublishSecrets(
        java.lang.String key);
    /**
     * Use {@link #getControllerUnpublishSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getControllerUnpublishSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_unpublish_secrets = 3;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getControllerUnpublishSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_unpublish_secrets = 3;</code>
     */

    java.lang.String getControllerUnpublishSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_unpublish_secrets = 3;</code>
     */

    java.lang.String getControllerUnpublishSecretsOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v0.ControllerUnpublishVolumeRequest}
   */
  public  static final class ControllerUnpublishVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.ControllerUnpublishVolumeRequest)
      ControllerUnpublishVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ControllerUnpublishVolumeRequest.newBuilder() to construct.
    private ControllerUnpublishVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ControllerUnpublishVolumeRequest() {
      volumeId_ = "";
      nodeId_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ControllerUnpublishVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              nodeId_ = s;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                controllerUnpublishSecrets_ = com.google.protobuf.MapField.newMapField(
                    ControllerUnpublishSecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000004;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              controllerUnpublishSecrets__ = input.readMessage(
                  ControllerUnpublishSecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              controllerUnpublishSecrets_.getMutableMap().put(
                  controllerUnpublishSecrets__.getKey(), controllerUnpublishSecrets__.getValue());
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_ControllerUnpublishVolumeRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 3:
          return internalGetControllerUnpublishSecrets();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_ControllerUnpublishVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.ControllerUnpublishVolumeRequest.class, csi.v0.Csi.ControllerUnpublishVolumeRequest.Builder.class);
    }

    private int bitField0_;
    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NODE_ID_FIELD_NUMBER = 2;
    private volatile java.lang.Object nodeId_;
    /**
     * <pre>
     * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
     * field to match the node ID returned by `NodeGetInfo` or leave it
     * unset. If the value is set, the SP MUST unpublish the volume from
     * the specified node. If the value is unset, the SP MUST unpublish
     * the volume from all nodes it is published to.
     * </pre>
     *
     * <code>string node_id = 2;</code>
     */
    public java.lang.String getNodeId() {
      java.lang.Object ref = nodeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        nodeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
     * field to match the node ID returned by `NodeGetInfo` or leave it
     * unset. If the value is set, the SP MUST unpublish the volume from
     * the specified node. If the value is unset, the SP MUST unpublish
     * the volume from all nodes it is published to.
     * </pre>
     *
     * <code>string node_id = 2;</code>
     */
    public com.google.protobuf.ByteString
        getNodeIdBytes() {
      java.lang.Object ref = nodeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nodeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CONTROLLER_UNPUBLISH_SECRETS_FIELD_NUMBER = 3;
    private static final class ControllerUnpublishSecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_ControllerUnpublishVolumeRequest_ControllerUnpublishSecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> controllerUnpublishSecrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetControllerUnpublishSecrets() {
      if (controllerUnpublishSecrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ControllerUnpublishSecretsDefaultEntryHolder.defaultEntry);
      }
      return controllerUnpublishSecrets_;
    }

    public int getControllerUnpublishSecretsCount() {
      return internalGetControllerUnpublishSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_unpublish_secrets = 3;</code>
     */

    public boolean containsControllerUnpublishSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetControllerUnpublishSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getControllerUnpublishSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getControllerUnpublishSecrets() {
      return getControllerUnpublishSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_unpublish_secrets = 3;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getControllerUnpublishSecretsMap() {
      return internalGetControllerUnpublishSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_unpublish_secrets = 3;</code>
     */

    public java.lang.String getControllerUnpublishSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetControllerUnpublishSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete controller unpublish volume
     * request. This SHOULD be the same secrets passed to the
     * ControllerPublishVolume call for the specified volume.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; controller_unpublish_secrets = 3;</code>
     */

    public java.lang.String getControllerUnpublishSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetControllerUnpublishSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      if (!getNodeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, nodeId_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetControllerUnpublishSecrets(),
          ControllerUnpublishSecretsDefaultEntryHolder.defaultEntry,
          3);
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      if (!getNodeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, nodeId_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetControllerUnpublishSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        controllerUnpublishSecrets__ = ControllerUnpublishSecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(3, controllerUnpublishSecrets__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.ControllerUnpublishVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.ControllerUnpublishVolumeRequest other = (csi.v0.Csi.ControllerUnpublishVolumeRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && getNodeId()
          .equals(other.getNodeId());
      result = result && internalGetControllerUnpublishSecrets().equals(
          other.internalGetControllerUnpublishSecrets());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      hash = (37 * hash) + NODE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getNodeId().hashCode();
      if (!internalGetControllerUnpublishSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + CONTROLLER_UNPUBLISH_SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetControllerUnpublishSecrets().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.ControllerUnpublishVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.ControllerUnpublishVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.ControllerUnpublishVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.ControllerUnpublishVolumeRequest)
        csi.v0.Csi.ControllerUnpublishVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerUnpublishVolumeRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetControllerUnpublishSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetMutableControllerUnpublishSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerUnpublishVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ControllerUnpublishVolumeRequest.class, csi.v0.Csi.ControllerUnpublishVolumeRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.ControllerUnpublishVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        nodeId_ = "";

        internalGetMutableControllerUnpublishSecrets().clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerUnpublishVolumeRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerUnpublishVolumeRequest getDefaultInstanceForType() {
        return csi.v0.Csi.ControllerUnpublishVolumeRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerUnpublishVolumeRequest build() {
        csi.v0.Csi.ControllerUnpublishVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerUnpublishVolumeRequest buildPartial() {
        csi.v0.Csi.ControllerUnpublishVolumeRequest result = new csi.v0.Csi.ControllerUnpublishVolumeRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.volumeId_ = volumeId_;
        result.nodeId_ = nodeId_;
        result.controllerUnpublishSecrets_ = internalGetControllerUnpublishSecrets();
        result.controllerUnpublishSecrets_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.ControllerUnpublishVolumeRequest) {
          return mergeFrom((csi.v0.Csi.ControllerUnpublishVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.ControllerUnpublishVolumeRequest other) {
        if (other == csi.v0.Csi.ControllerUnpublishVolumeRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        if (!other.getNodeId().isEmpty()) {
          nodeId_ = other.nodeId_;
          onChanged();
        }
        internalGetMutableControllerUnpublishSecrets().mergeFrom(
            other.internalGetControllerUnpublishSecrets());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.ControllerUnpublishVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.ControllerUnpublishVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object nodeId_ = "";
      /**
       * <pre>
       * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
       * field to match the node ID returned by `NodeGetInfo` or leave it
       * unset. If the value is set, the SP MUST unpublish the volume from
       * the specified node. If the value is unset, the SP MUST unpublish
       * the volume from all nodes it is published to.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public java.lang.String getNodeId() {
        java.lang.Object ref = nodeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          nodeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
       * field to match the node ID returned by `NodeGetInfo` or leave it
       * unset. If the value is set, the SP MUST unpublish the volume from
       * the specified node. If the value is unset, the SP MUST unpublish
       * the volume from all nodes it is published to.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public com.google.protobuf.ByteString
          getNodeIdBytes() {
        java.lang.Object ref = nodeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nodeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
       * field to match the node ID returned by `NodeGetInfo` or leave it
       * unset. If the value is set, the SP MUST unpublish the volume from
       * the specified node. If the value is unset, the SP MUST unpublish
       * the volume from all nodes it is published to.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public Builder setNodeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        nodeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
       * field to match the node ID returned by `NodeGetInfo` or leave it
       * unset. If the value is set, the SP MUST unpublish the volume from
       * the specified node. If the value is unset, the SP MUST unpublish
       * the volume from all nodes it is published to.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public Builder clearNodeId() {
        
        nodeId_ = getDefaultInstance().getNodeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the node. This field is OPTIONAL. The CO SHOULD set this
       * field to match the node ID returned by `NodeGetInfo` or leave it
       * unset. If the value is set, the SP MUST unpublish the volume from
       * the specified node. If the value is unset, the SP MUST unpublish
       * the volume from all nodes it is published to.
       * </pre>
       *
       * <code>string node_id = 2;</code>
       */
      public Builder setNodeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        nodeId_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> controllerUnpublishSecrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetControllerUnpublishSecrets() {
        if (controllerUnpublishSecrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ControllerUnpublishSecretsDefaultEntryHolder.defaultEntry);
        }
        return controllerUnpublishSecrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableControllerUnpublishSecrets() {
        onChanged();;
        if (controllerUnpublishSecrets_ == null) {
          controllerUnpublishSecrets_ = com.google.protobuf.MapField.newMapField(
              ControllerUnpublishSecretsDefaultEntryHolder.defaultEntry);
        }
        if (!controllerUnpublishSecrets_.isMutable()) {
          controllerUnpublishSecrets_ = controllerUnpublishSecrets_.copy();
        }
        return controllerUnpublishSecrets_;
      }

      public int getControllerUnpublishSecretsCount() {
        return internalGetControllerUnpublishSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller unpublish volume
       * request. This SHOULD be the same secrets passed to the
       * ControllerPublishVolume call for the specified volume.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_unpublish_secrets = 3;</code>
       */

      public boolean containsControllerUnpublishSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetControllerUnpublishSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getControllerUnpublishSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getControllerUnpublishSecrets() {
        return getControllerUnpublishSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller unpublish volume
       * request. This SHOULD be the same secrets passed to the
       * ControllerPublishVolume call for the specified volume.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_unpublish_secrets = 3;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getControllerUnpublishSecretsMap() {
        return internalGetControllerUnpublishSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller unpublish volume
       * request. This SHOULD be the same secrets passed to the
       * ControllerPublishVolume call for the specified volume.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_unpublish_secrets = 3;</code>
       */

      public java.lang.String getControllerUnpublishSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetControllerUnpublishSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller unpublish volume
       * request. This SHOULD be the same secrets passed to the
       * ControllerPublishVolume call for the specified volume.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_unpublish_secrets = 3;</code>
       */

      public java.lang.String getControllerUnpublishSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetControllerUnpublishSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearControllerUnpublishSecrets() {
        internalGetMutableControllerUnpublishSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller unpublish volume
       * request. This SHOULD be the same secrets passed to the
       * ControllerPublishVolume call for the specified volume.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_unpublish_secrets = 3;</code>
       */

      public Builder removeControllerUnpublishSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableControllerUnpublishSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableControllerUnpublishSecrets() {
        return internalGetMutableControllerUnpublishSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller unpublish volume
       * request. This SHOULD be the same secrets passed to the
       * ControllerPublishVolume call for the specified volume.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_unpublish_secrets = 3;</code>
       */
      public Builder putControllerUnpublishSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableControllerUnpublishSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete controller unpublish volume
       * request. This SHOULD be the same secrets passed to the
       * ControllerPublishVolume call for the specified volume.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; controller_unpublish_secrets = 3;</code>
       */

      public Builder putAllControllerUnpublishSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableControllerUnpublishSecrets().getMutableMap()
            .putAll(values);
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.ControllerUnpublishVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.ControllerUnpublishVolumeRequest)
    private static final csi.v0.Csi.ControllerUnpublishVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.ControllerUnpublishVolumeRequest();
    }

    public static csi.v0.Csi.ControllerUnpublishVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerUnpublishVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<ControllerUnpublishVolumeRequest>() {
      @java.lang.Override
      public ControllerUnpublishVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ControllerUnpublishVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ControllerUnpublishVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerUnpublishVolumeRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.ControllerUnpublishVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerUnpublishVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.ControllerUnpublishVolumeResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v0.ControllerUnpublishVolumeResponse}
   */
  public  static final class ControllerUnpublishVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.ControllerUnpublishVolumeResponse)
      ControllerUnpublishVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ControllerUnpublishVolumeResponse.newBuilder() to construct.
    private ControllerUnpublishVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ControllerUnpublishVolumeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ControllerUnpublishVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_ControllerUnpublishVolumeResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_ControllerUnpublishVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.ControllerUnpublishVolumeResponse.class, csi.v0.Csi.ControllerUnpublishVolumeResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.ControllerUnpublishVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.ControllerUnpublishVolumeResponse other = (csi.v0.Csi.ControllerUnpublishVolumeResponse) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.ControllerUnpublishVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerUnpublishVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.ControllerUnpublishVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v0.ControllerUnpublishVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.ControllerUnpublishVolumeResponse)
        csi.v0.Csi.ControllerUnpublishVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerUnpublishVolumeResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerUnpublishVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ControllerUnpublishVolumeResponse.class, csi.v0.Csi.ControllerUnpublishVolumeResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.ControllerUnpublishVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerUnpublishVolumeResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerUnpublishVolumeResponse getDefaultInstanceForType() {
        return csi.v0.Csi.ControllerUnpublishVolumeResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerUnpublishVolumeResponse build() {
        csi.v0.Csi.ControllerUnpublishVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerUnpublishVolumeResponse buildPartial() {
        csi.v0.Csi.ControllerUnpublishVolumeResponse result = new csi.v0.Csi.ControllerUnpublishVolumeResponse(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.ControllerUnpublishVolumeResponse) {
          return mergeFrom((csi.v0.Csi.ControllerUnpublishVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.ControllerUnpublishVolumeResponse other) {
        if (other == csi.v0.Csi.ControllerUnpublishVolumeResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.ControllerUnpublishVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.ControllerUnpublishVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.ControllerUnpublishVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.ControllerUnpublishVolumeResponse)
    private static final csi.v0.Csi.ControllerUnpublishVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.ControllerUnpublishVolumeResponse();
    }

    public static csi.v0.Csi.ControllerUnpublishVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerUnpublishVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<ControllerUnpublishVolumeResponse>() {
      @java.lang.Override
      public ControllerUnpublishVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ControllerUnpublishVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ControllerUnpublishVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerUnpublishVolumeResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.ControllerUnpublishVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidateVolumeCapabilitiesRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.ValidateVolumeCapabilitiesRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume to check. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume to check. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "supported" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
     */
    java.util.List<csi.v0.Csi.VolumeCapability> 
        getVolumeCapabilitiesList();
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "supported" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
     */
    csi.v0.Csi.VolumeCapability getVolumeCapabilities(int index);
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "supported" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
     */
    int getVolumeCapabilitiesCount();
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "supported" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
     */
    java.util.List<? extends csi.v0.Csi.VolumeCapabilityOrBuilder> 
        getVolumeCapabilitiesOrBuilderList();
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "supported" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
     */
    csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
        int index);

    /**
     * <pre>
     * Attributes of the volume to check. This field is OPTIONAL and MUST
     * match the attributes of the Volume identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 3;</code>
     */
    int getVolumeAttributesCount();
    /**
     * <pre>
     * Attributes of the volume to check. This field is OPTIONAL and MUST
     * match the attributes of the Volume identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 3;</code>
     */
    boolean containsVolumeAttributes(
        java.lang.String key);
    /**
     * Use {@link #getVolumeAttributesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeAttributes();
    /**
     * <pre>
     * Attributes of the volume to check. This field is OPTIONAL and MUST
     * match the attributes of the Volume identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 3;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeAttributesMap();
    /**
     * <pre>
     * Attributes of the volume to check. This field is OPTIONAL and MUST
     * match the attributes of the Volume identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 3;</code>
     */

    java.lang.String getVolumeAttributesOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Attributes of the volume to check. This field is OPTIONAL and MUST
     * match the attributes of the Volume identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 3;</code>
     */

    java.lang.String getVolumeAttributesOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the caller believes
     * the volume is accessible from.
     * A caller MAY specify multiple topologies to indicate they believe
     * the volume to be accessible from multiple locations.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
     */
    java.util.List<csi.v0.Csi.Topology> 
        getAccessibleTopologyList();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the caller believes
     * the volume is accessible from.
     * A caller MAY specify multiple topologies to indicate they believe
     * the volume to be accessible from multiple locations.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
     */
    csi.v0.Csi.Topology getAccessibleTopology(int index);
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the caller believes
     * the volume is accessible from.
     * A caller MAY specify multiple topologies to indicate they believe
     * the volume to be accessible from multiple locations.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
     */
    int getAccessibleTopologyCount();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the caller believes
     * the volume is accessible from.
     * A caller MAY specify multiple topologies to indicate they believe
     * the volume to be accessible from multiple locations.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
     */
    java.util.List<? extends csi.v0.Csi.TopologyOrBuilder> 
        getAccessibleTopologyOrBuilderList();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the caller believes
     * the volume is accessible from.
     * A caller MAY specify multiple topologies to indicate they believe
     * the volume to be accessible from multiple locations.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
     */
    csi.v0.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code csi.v0.ValidateVolumeCapabilitiesRequest}
   */
  public  static final class ValidateVolumeCapabilitiesRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.ValidateVolumeCapabilitiesRequest)
      ValidateVolumeCapabilitiesRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidateVolumeCapabilitiesRequest.newBuilder() to construct.
    private ValidateVolumeCapabilitiesRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidateVolumeCapabilitiesRequest() {
      volumeId_ = "";
      volumeCapabilities_ = java.util.Collections.emptyList();
      accessibleTopology_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidateVolumeCapabilitiesRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                volumeCapabilities_ = new java.util.ArrayList<csi.v0.Csi.VolumeCapability>();
                mutable_bitField0_ |= 0x00000002;
              }
              volumeCapabilities_.add(
                  input.readMessage(csi.v0.Csi.VolumeCapability.parser(), extensionRegistry));
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                volumeAttributes_ = com.google.protobuf.MapField.newMapField(
                    VolumeAttributesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000004;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              volumeAttributes__ = input.readMessage(
                  VolumeAttributesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              volumeAttributes_.getMutableMap().put(
                  volumeAttributes__.getKey(), volumeAttributes__.getValue());
              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                accessibleTopology_ = new java.util.ArrayList<csi.v0.Csi.Topology>();
                mutable_bitField0_ |= 0x00000008;
              }
              accessibleTopology_.add(
                  input.readMessage(csi.v0.Csi.Topology.parser(), extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          volumeCapabilities_ = java.util.Collections.unmodifiableList(volumeCapabilities_);
        }
        if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
          accessibleTopology_ = java.util.Collections.unmodifiableList(accessibleTopology_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 3:
          return internalGetVolumeAttributes();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.ValidateVolumeCapabilitiesRequest.class, csi.v0.Csi.ValidateVolumeCapabilitiesRequest.Builder.class);
    }

    private int bitField0_;
    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume to check. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume to check. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VOLUME_CAPABILITIES_FIELD_NUMBER = 2;
    private java.util.List<csi.v0.Csi.VolumeCapability> volumeCapabilities_;
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "supported" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
     */
    public java.util.List<csi.v0.Csi.VolumeCapability> getVolumeCapabilitiesList() {
      return volumeCapabilities_;
    }
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "supported" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
     */
    public java.util.List<? extends csi.v0.Csi.VolumeCapabilityOrBuilder> 
        getVolumeCapabilitiesOrBuilderList() {
      return volumeCapabilities_;
    }
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "supported" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
     */
    public int getVolumeCapabilitiesCount() {
      return volumeCapabilities_.size();
    }
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "supported" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
     */
    public csi.v0.Csi.VolumeCapability getVolumeCapabilities(int index) {
      return volumeCapabilities_.get(index);
    }
    /**
     * <pre>
     * The capabilities that the CO wants to check for the volume. This
     * call SHALL return "supported" only if all the volume capabilities
     * specified below are supported. This field is REQUIRED.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
     */
    public csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
        int index) {
      return volumeCapabilities_.get(index);
    }

    public static final int VOLUME_ATTRIBUTES_FIELD_NUMBER = 3;
    private static final class VolumeAttributesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_VolumeAttributesEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> volumeAttributes_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetVolumeAttributes() {
      if (volumeAttributes_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            VolumeAttributesDefaultEntryHolder.defaultEntry);
      }
      return volumeAttributes_;
    }

    public int getVolumeAttributesCount() {
      return internalGetVolumeAttributes().getMap().size();
    }
    /**
     * <pre>
     * Attributes of the volume to check. This field is OPTIONAL and MUST
     * match the attributes of the Volume identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 3;</code>
     */

    public boolean containsVolumeAttributes(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetVolumeAttributes().getMap().containsKey(key);
    }
    /**
     * Use {@link #getVolumeAttributesMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getVolumeAttributes() {
      return getVolumeAttributesMap();
    }
    /**
     * <pre>
     * Attributes of the volume to check. This field is OPTIONAL and MUST
     * match the attributes of the Volume identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 3;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getVolumeAttributesMap() {
      return internalGetVolumeAttributes().getMap();
    }
    /**
     * <pre>
     * Attributes of the volume to check. This field is OPTIONAL and MUST
     * match the attributes of the Volume identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 3;</code>
     */

    public java.lang.String getVolumeAttributesOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeAttributes().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Attributes of the volume to check. This field is OPTIONAL and MUST
     * match the attributes of the Volume identified by `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 3;</code>
     */

    public java.lang.String getVolumeAttributesOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeAttributes().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int ACCESSIBLE_TOPOLOGY_FIELD_NUMBER = 4;
    private java.util.List<csi.v0.Csi.Topology> accessibleTopology_;
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the caller believes
     * the volume is accessible from.
     * A caller MAY specify multiple topologies to indicate they believe
     * the volume to be accessible from multiple locations.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
     */
    public java.util.List<csi.v0.Csi.Topology> getAccessibleTopologyList() {
      return accessibleTopology_;
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the caller believes
     * the volume is accessible from.
     * A caller MAY specify multiple topologies to indicate they believe
     * the volume to be accessible from multiple locations.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
     */
    public java.util.List<? extends csi.v0.Csi.TopologyOrBuilder> 
        getAccessibleTopologyOrBuilderList() {
      return accessibleTopology_;
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the caller believes
     * the volume is accessible from.
     * A caller MAY specify multiple topologies to indicate they believe
     * the volume to be accessible from multiple locations.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
     */
    public int getAccessibleTopologyCount() {
      return accessibleTopology_.size();
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the caller believes
     * the volume is accessible from.
     * A caller MAY specify multiple topologies to indicate they believe
     * the volume to be accessible from multiple locations.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
     */
    public csi.v0.Csi.Topology getAccessibleTopology(int index) {
      return accessibleTopology_.get(index);
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the caller believes
     * the volume is accessible from.
     * A caller MAY specify multiple topologies to indicate they believe
     * the volume to be accessible from multiple locations.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
     */
    public csi.v0.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder(
        int index) {
      return accessibleTopology_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      for (int i = 0; i < volumeCapabilities_.size(); i++) {
        output.writeMessage(2, volumeCapabilities_.get(i));
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetVolumeAttributes(),
          VolumeAttributesDefaultEntryHolder.defaultEntry,
          3);
      for (int i = 0; i < accessibleTopology_.size(); i++) {
        output.writeMessage(4, accessibleTopology_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      for (int i = 0; i < volumeCapabilities_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, volumeCapabilities_.get(i));
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetVolumeAttributes().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        volumeAttributes__ = VolumeAttributesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(3, volumeAttributes__);
      }
      for (int i = 0; i < accessibleTopology_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, accessibleTopology_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.ValidateVolumeCapabilitiesRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.ValidateVolumeCapabilitiesRequest other = (csi.v0.Csi.ValidateVolumeCapabilitiesRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && getVolumeCapabilitiesList()
          .equals(other.getVolumeCapabilitiesList());
      result = result && internalGetVolumeAttributes().equals(
          other.internalGetVolumeAttributes());
      result = result && getAccessibleTopologyList()
          .equals(other.getAccessibleTopologyList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      if (getVolumeCapabilitiesCount() > 0) {
        hash = (37 * hash) + VOLUME_CAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeCapabilitiesList().hashCode();
      }
      if (!internalGetVolumeAttributes().getMap().isEmpty()) {
        hash = (37 * hash) + VOLUME_ATTRIBUTES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetVolumeAttributes().hashCode();
      }
      if (getAccessibleTopologyCount() > 0) {
        hash = (37 * hash) + ACCESSIBLE_TOPOLOGY_FIELD_NUMBER;
        hash = (53 * hash) + getAccessibleTopologyList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.ValidateVolumeCapabilitiesRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.ValidateVolumeCapabilitiesRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.ValidateVolumeCapabilitiesRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.ValidateVolumeCapabilitiesRequest)
        csi.v0.Csi.ValidateVolumeCapabilitiesRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetVolumeAttributes();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetMutableVolumeAttributes();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ValidateVolumeCapabilitiesRequest.class, csi.v0.Csi.ValidateVolumeCapabilitiesRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.ValidateVolumeCapabilitiesRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getVolumeCapabilitiesFieldBuilder();
          getAccessibleTopologyFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          volumeCapabilitiesBuilder_.clear();
        }
        internalGetMutableVolumeAttributes().clear();
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
        } else {
          accessibleTopologyBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.ValidateVolumeCapabilitiesRequest getDefaultInstanceForType() {
        return csi.v0.Csi.ValidateVolumeCapabilitiesRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.ValidateVolumeCapabilitiesRequest build() {
        csi.v0.Csi.ValidateVolumeCapabilitiesRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.ValidateVolumeCapabilitiesRequest buildPartial() {
        csi.v0.Csi.ValidateVolumeCapabilitiesRequest result = new csi.v0.Csi.ValidateVolumeCapabilitiesRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.volumeId_ = volumeId_;
        if (volumeCapabilitiesBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            volumeCapabilities_ = java.util.Collections.unmodifiableList(volumeCapabilities_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.volumeCapabilities_ = volumeCapabilities_;
        } else {
          result.volumeCapabilities_ = volumeCapabilitiesBuilder_.build();
        }
        result.volumeAttributes_ = internalGetVolumeAttributes();
        result.volumeAttributes_.makeImmutable();
        if (accessibleTopologyBuilder_ == null) {
          if (((bitField0_ & 0x00000008) == 0x00000008)) {
            accessibleTopology_ = java.util.Collections.unmodifiableList(accessibleTopology_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.accessibleTopology_ = accessibleTopology_;
        } else {
          result.accessibleTopology_ = accessibleTopologyBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.ValidateVolumeCapabilitiesRequest) {
          return mergeFrom((csi.v0.Csi.ValidateVolumeCapabilitiesRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.ValidateVolumeCapabilitiesRequest other) {
        if (other == csi.v0.Csi.ValidateVolumeCapabilitiesRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        if (volumeCapabilitiesBuilder_ == null) {
          if (!other.volumeCapabilities_.isEmpty()) {
            if (volumeCapabilities_.isEmpty()) {
              volumeCapabilities_ = other.volumeCapabilities_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureVolumeCapabilitiesIsMutable();
              volumeCapabilities_.addAll(other.volumeCapabilities_);
            }
            onChanged();
          }
        } else {
          if (!other.volumeCapabilities_.isEmpty()) {
            if (volumeCapabilitiesBuilder_.isEmpty()) {
              volumeCapabilitiesBuilder_.dispose();
              volumeCapabilitiesBuilder_ = null;
              volumeCapabilities_ = other.volumeCapabilities_;
              bitField0_ = (bitField0_ & ~0x00000002);
              volumeCapabilitiesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getVolumeCapabilitiesFieldBuilder() : null;
            } else {
              volumeCapabilitiesBuilder_.addAllMessages(other.volumeCapabilities_);
            }
          }
        }
        internalGetMutableVolumeAttributes().mergeFrom(
            other.internalGetVolumeAttributes());
        if (accessibleTopologyBuilder_ == null) {
          if (!other.accessibleTopology_.isEmpty()) {
            if (accessibleTopology_.isEmpty()) {
              accessibleTopology_ = other.accessibleTopology_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureAccessibleTopologyIsMutable();
              accessibleTopology_.addAll(other.accessibleTopology_);
            }
            onChanged();
          }
        } else {
          if (!other.accessibleTopology_.isEmpty()) {
            if (accessibleTopologyBuilder_.isEmpty()) {
              accessibleTopologyBuilder_.dispose();
              accessibleTopologyBuilder_ = null;
              accessibleTopology_ = other.accessibleTopology_;
              bitField0_ = (bitField0_ & ~0x00000008);
              accessibleTopologyBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getAccessibleTopologyFieldBuilder() : null;
            } else {
              accessibleTopologyBuilder_.addAllMessages(other.accessibleTopology_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.ValidateVolumeCapabilitiesRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.ValidateVolumeCapabilitiesRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume to check. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to check. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to check. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to check. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to check. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private java.util.List<csi.v0.Csi.VolumeCapability> volumeCapabilities_ =
        java.util.Collections.emptyList();
      private void ensureVolumeCapabilitiesIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          volumeCapabilities_ = new java.util.ArrayList<csi.v0.Csi.VolumeCapability>(volumeCapabilities_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder> volumeCapabilitiesBuilder_;

      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public java.util.List<csi.v0.Csi.VolumeCapability> getVolumeCapabilitiesList() {
        if (volumeCapabilitiesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(volumeCapabilities_);
        } else {
          return volumeCapabilitiesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public int getVolumeCapabilitiesCount() {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.size();
        } else {
          return volumeCapabilitiesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public csi.v0.Csi.VolumeCapability getVolumeCapabilities(int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.get(index);
        } else {
          return volumeCapabilitiesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public Builder setVolumeCapabilities(
          int index, csi.v0.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.set(index, value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public Builder setVolumeCapabilities(
          int index, csi.v0.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.set(index, builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public Builder addVolumeCapabilities(csi.v0.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public Builder addVolumeCapabilities(
          int index, csi.v0.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(index, value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public Builder addVolumeCapabilities(
          csi.v0.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public Builder addVolumeCapabilities(
          int index, csi.v0.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(index, builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public Builder addAllVolumeCapabilities(
          java.lang.Iterable<? extends csi.v0.Csi.VolumeCapability> values) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, volumeCapabilities_);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public Builder clearVolumeCapabilities() {
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public Builder removeVolumeCapabilities(int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.remove(index);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public csi.v0.Csi.VolumeCapability.Builder getVolumeCapabilitiesBuilder(
          int index) {
        return getVolumeCapabilitiesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
          int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.get(index);  } else {
          return volumeCapabilitiesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public java.util.List<? extends csi.v0.Csi.VolumeCapabilityOrBuilder> 
           getVolumeCapabilitiesOrBuilderList() {
        if (volumeCapabilitiesBuilder_ != null) {
          return volumeCapabilitiesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(volumeCapabilities_);
        }
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public csi.v0.Csi.VolumeCapability.Builder addVolumeCapabilitiesBuilder() {
        return getVolumeCapabilitiesFieldBuilder().addBuilder(
            csi.v0.Csi.VolumeCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public csi.v0.Csi.VolumeCapability.Builder addVolumeCapabilitiesBuilder(
          int index) {
        return getVolumeCapabilitiesFieldBuilder().addBuilder(
            index, csi.v0.Csi.VolumeCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * The capabilities that the CO wants to check for the volume. This
       * call SHALL return "supported" only if all the volume capabilities
       * specified below are supported. This field is REQUIRED.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 2;</code>
       */
      public java.util.List<csi.v0.Csi.VolumeCapability.Builder> 
           getVolumeCapabilitiesBuilderList() {
        return getVolumeCapabilitiesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder> 
          getVolumeCapabilitiesFieldBuilder() {
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilitiesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder>(
                  volumeCapabilities_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          volumeCapabilities_ = null;
        }
        return volumeCapabilitiesBuilder_;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> volumeAttributes_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetVolumeAttributes() {
        if (volumeAttributes_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              VolumeAttributesDefaultEntryHolder.defaultEntry);
        }
        return volumeAttributes_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableVolumeAttributes() {
        onChanged();;
        if (volumeAttributes_ == null) {
          volumeAttributes_ = com.google.protobuf.MapField.newMapField(
              VolumeAttributesDefaultEntryHolder.defaultEntry);
        }
        if (!volumeAttributes_.isMutable()) {
          volumeAttributes_ = volumeAttributes_.copy();
        }
        return volumeAttributes_;
      }

      public int getVolumeAttributesCount() {
        return internalGetVolumeAttributes().getMap().size();
      }
      /**
       * <pre>
       * Attributes of the volume to check. This field is OPTIONAL and MUST
       * match the attributes of the Volume identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 3;</code>
       */

      public boolean containsVolumeAttributes(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetVolumeAttributes().getMap().containsKey(key);
      }
      /**
       * Use {@link #getVolumeAttributesMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getVolumeAttributes() {
        return getVolumeAttributesMap();
      }
      /**
       * <pre>
       * Attributes of the volume to check. This field is OPTIONAL and MUST
       * match the attributes of the Volume identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 3;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getVolumeAttributesMap() {
        return internalGetVolumeAttributes().getMap();
      }
      /**
       * <pre>
       * Attributes of the volume to check. This field is OPTIONAL and MUST
       * match the attributes of the Volume identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 3;</code>
       */

      public java.lang.String getVolumeAttributesOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeAttributes().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Attributes of the volume to check. This field is OPTIONAL and MUST
       * match the attributes of the Volume identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 3;</code>
       */

      public java.lang.String getVolumeAttributesOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeAttributes().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearVolumeAttributes() {
        internalGetMutableVolumeAttributes().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Attributes of the volume to check. This field is OPTIONAL and MUST
       * match the attributes of the Volume identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 3;</code>
       */

      public Builder removeVolumeAttributes(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeAttributes().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableVolumeAttributes() {
        return internalGetMutableVolumeAttributes().getMutableMap();
      }
      /**
       * <pre>
       * Attributes of the volume to check. This field is OPTIONAL and MUST
       * match the attributes of the Volume identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 3;</code>
       */
      public Builder putVolumeAttributes(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeAttributes().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Attributes of the volume to check. This field is OPTIONAL and MUST
       * match the attributes of the Volume identified by `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 3;</code>
       */

      public Builder putAllVolumeAttributes(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableVolumeAttributes().getMutableMap()
            .putAll(values);
        return this;
      }

      private java.util.List<csi.v0.Csi.Topology> accessibleTopology_ =
        java.util.Collections.emptyList();
      private void ensureAccessibleTopologyIsMutable() {
        if (!((bitField0_ & 0x00000008) == 0x00000008)) {
          accessibleTopology_ = new java.util.ArrayList<csi.v0.Csi.Topology>(accessibleTopology_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder> accessibleTopologyBuilder_;

      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public java.util.List<csi.v0.Csi.Topology> getAccessibleTopologyList() {
        if (accessibleTopologyBuilder_ == null) {
          return java.util.Collections.unmodifiableList(accessibleTopology_);
        } else {
          return accessibleTopologyBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public int getAccessibleTopologyCount() {
        if (accessibleTopologyBuilder_ == null) {
          return accessibleTopology_.size();
        } else {
          return accessibleTopologyBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public csi.v0.Csi.Topology getAccessibleTopology(int index) {
        if (accessibleTopologyBuilder_ == null) {
          return accessibleTopology_.get(index);
        } else {
          return accessibleTopologyBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public Builder setAccessibleTopology(
          int index, csi.v0.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.set(index, value);
          onChanged();
        } else {
          accessibleTopologyBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public Builder setAccessibleTopology(
          int index, csi.v0.Csi.Topology.Builder builderForValue) {
        if (accessibleTopologyBuilder_ == null) {
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.set(index, builderForValue.build());
          onChanged();
        } else {
          accessibleTopologyBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public Builder addAccessibleTopology(csi.v0.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.add(value);
          onChanged();
        } else {
          accessibleTopologyBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public Builder addAccessibleTopology(
          int index, csi.v0.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.add(index, value);
          onChanged();
        } else {
          accessibleTopologyBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public Builder addAccessibleTopology(
          csi.v0.Csi.Topology.Builder builderForValue) {
        if (accessibleTopologyBuilder_ == null) {
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.add(builderForValue.build());
          onChanged();
        } else {
          accessibleTopologyBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public Builder addAccessibleTopology(
          int index, csi.v0.Csi.Topology.Builder builderForValue) {
        if (accessibleTopologyBuilder_ == null) {
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.add(index, builderForValue.build());
          onChanged();
        } else {
          accessibleTopologyBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public Builder addAllAccessibleTopology(
          java.lang.Iterable<? extends csi.v0.Csi.Topology> values) {
        if (accessibleTopologyBuilder_ == null) {
          ensureAccessibleTopologyIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, accessibleTopology_);
          onChanged();
        } else {
          accessibleTopologyBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public Builder clearAccessibleTopology() {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          accessibleTopologyBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public Builder removeAccessibleTopology(int index) {
        if (accessibleTopologyBuilder_ == null) {
          ensureAccessibleTopologyIsMutable();
          accessibleTopology_.remove(index);
          onChanged();
        } else {
          accessibleTopologyBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public csi.v0.Csi.Topology.Builder getAccessibleTopologyBuilder(
          int index) {
        return getAccessibleTopologyFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public csi.v0.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder(
          int index) {
        if (accessibleTopologyBuilder_ == null) {
          return accessibleTopology_.get(index);  } else {
          return accessibleTopologyBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public java.util.List<? extends csi.v0.Csi.TopologyOrBuilder> 
           getAccessibleTopologyOrBuilderList() {
        if (accessibleTopologyBuilder_ != null) {
          return accessibleTopologyBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(accessibleTopology_);
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public csi.v0.Csi.Topology.Builder addAccessibleTopologyBuilder() {
        return getAccessibleTopologyFieldBuilder().addBuilder(
            csi.v0.Csi.Topology.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public csi.v0.Csi.Topology.Builder addAccessibleTopologyBuilder(
          int index) {
        return getAccessibleTopologyFieldBuilder().addBuilder(
            index, csi.v0.Csi.Topology.getDefaultInstance());
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the caller believes
       * the volume is accessible from.
       * A caller MAY specify multiple topologies to indicate they believe
       * the volume to be accessible from multiple locations.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>repeated .csi.v0.Topology accessible_topology = 4;</code>
       */
      public java.util.List<csi.v0.Csi.Topology.Builder> 
           getAccessibleTopologyBuilderList() {
        return getAccessibleTopologyFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder> 
          getAccessibleTopologyFieldBuilder() {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopologyBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder>(
                  accessibleTopology_,
                  ((bitField0_ & 0x00000008) == 0x00000008),
                  getParentForChildren(),
                  isClean());
          accessibleTopology_ = null;
        }
        return accessibleTopologyBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.ValidateVolumeCapabilitiesRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.ValidateVolumeCapabilitiesRequest)
    private static final csi.v0.Csi.ValidateVolumeCapabilitiesRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.ValidateVolumeCapabilitiesRequest();
    }

    public static csi.v0.Csi.ValidateVolumeCapabilitiesRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ValidateVolumeCapabilitiesRequest>
        PARSER = new com.google.protobuf.AbstractParser<ValidateVolumeCapabilitiesRequest>() {
      @java.lang.Override
      public ValidateVolumeCapabilitiesRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidateVolumeCapabilitiesRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidateVolumeCapabilitiesRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidateVolumeCapabilitiesRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.ValidateVolumeCapabilitiesRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ValidateVolumeCapabilitiesResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.ValidateVolumeCapabilitiesResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * True if the Plugin supports the specified capabilities for the
     * given volume. This field is REQUIRED.
     * </pre>
     *
     * <code>bool supported = 1;</code>
     */
    boolean getSupported();

    /**
     * <pre>
     * Message to the CO if `supported` above is false. This field is
     * OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string message = 2;</code>
     */
    java.lang.String getMessage();
    /**
     * <pre>
     * Message to the CO if `supported` above is false. This field is
     * OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string message = 2;</code>
     */
    com.google.protobuf.ByteString
        getMessageBytes();
  }
  /**
   * Protobuf type {@code csi.v0.ValidateVolumeCapabilitiesResponse}
   */
  public  static final class ValidateVolumeCapabilitiesResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.ValidateVolumeCapabilitiesResponse)
      ValidateVolumeCapabilitiesResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ValidateVolumeCapabilitiesResponse.newBuilder() to construct.
    private ValidateVolumeCapabilitiesResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ValidateVolumeCapabilitiesResponse() {
      supported_ = false;
      message_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ValidateVolumeCapabilitiesResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {

              supported_ = input.readBool();
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              message_ = s;
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_ValidateVolumeCapabilitiesResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_ValidateVolumeCapabilitiesResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.ValidateVolumeCapabilitiesResponse.class, csi.v0.Csi.ValidateVolumeCapabilitiesResponse.Builder.class);
    }

    public static final int SUPPORTED_FIELD_NUMBER = 1;
    private boolean supported_;
    /**
     * <pre>
     * True if the Plugin supports the specified capabilities for the
     * given volume. This field is REQUIRED.
     * </pre>
     *
     * <code>bool supported = 1;</code>
     */
    public boolean getSupported() {
      return supported_;
    }

    public static final int MESSAGE_FIELD_NUMBER = 2;
    private volatile java.lang.Object message_;
    /**
     * <pre>
     * Message to the CO if `supported` above is false. This field is
     * OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string message = 2;</code>
     */
    public java.lang.String getMessage() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        message_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Message to the CO if `supported` above is false. This field is
     * OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string message = 2;</code>
     */
    public com.google.protobuf.ByteString
        getMessageBytes() {
      java.lang.Object ref = message_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        message_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (supported_ != false) {
        output.writeBool(1, supported_);
      }
      if (!getMessageBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, message_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (supported_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, supported_);
      }
      if (!getMessageBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, message_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.ValidateVolumeCapabilitiesResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.ValidateVolumeCapabilitiesResponse other = (csi.v0.Csi.ValidateVolumeCapabilitiesResponse) obj;

      boolean result = true;
      result = result && (getSupported()
          == other.getSupported());
      result = result && getMessage()
          .equals(other.getMessage());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SUPPORTED_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getSupported());
      hash = (37 * hash) + MESSAGE_FIELD_NUMBER;
      hash = (53 * hash) + getMessage().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.ValidateVolumeCapabilitiesResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ValidateVolumeCapabilitiesResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.ValidateVolumeCapabilitiesResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.ValidateVolumeCapabilitiesResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.ValidateVolumeCapabilitiesResponse)
        csi.v0.Csi.ValidateVolumeCapabilitiesResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ValidateVolumeCapabilitiesResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ValidateVolumeCapabilitiesResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ValidateVolumeCapabilitiesResponse.class, csi.v0.Csi.ValidateVolumeCapabilitiesResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.ValidateVolumeCapabilitiesResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        supported_ = false;

        message_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_ValidateVolumeCapabilitiesResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.ValidateVolumeCapabilitiesResponse getDefaultInstanceForType() {
        return csi.v0.Csi.ValidateVolumeCapabilitiesResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.ValidateVolumeCapabilitiesResponse build() {
        csi.v0.Csi.ValidateVolumeCapabilitiesResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.ValidateVolumeCapabilitiesResponse buildPartial() {
        csi.v0.Csi.ValidateVolumeCapabilitiesResponse result = new csi.v0.Csi.ValidateVolumeCapabilitiesResponse(this);
        result.supported_ = supported_;
        result.message_ = message_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.ValidateVolumeCapabilitiesResponse) {
          return mergeFrom((csi.v0.Csi.ValidateVolumeCapabilitiesResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.ValidateVolumeCapabilitiesResponse other) {
        if (other == csi.v0.Csi.ValidateVolumeCapabilitiesResponse.getDefaultInstance()) return this;
        if (other.getSupported() != false) {
          setSupported(other.getSupported());
        }
        if (!other.getMessage().isEmpty()) {
          message_ = other.message_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.ValidateVolumeCapabilitiesResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.ValidateVolumeCapabilitiesResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private boolean supported_ ;
      /**
       * <pre>
       * True if the Plugin supports the specified capabilities for the
       * given volume. This field is REQUIRED.
       * </pre>
       *
       * <code>bool supported = 1;</code>
       */
      public boolean getSupported() {
        return supported_;
      }
      /**
       * <pre>
       * True if the Plugin supports the specified capabilities for the
       * given volume. This field is REQUIRED.
       * </pre>
       *
       * <code>bool supported = 1;</code>
       */
      public Builder setSupported(boolean value) {
        
        supported_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * True if the Plugin supports the specified capabilities for the
       * given volume. This field is REQUIRED.
       * </pre>
       *
       * <code>bool supported = 1;</code>
       */
      public Builder clearSupported() {
        
        supported_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object message_ = "";
      /**
       * <pre>
       * Message to the CO if `supported` above is false. This field is
       * OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string message = 2;</code>
       */
      public java.lang.String getMessage() {
        java.lang.Object ref = message_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          message_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Message to the CO if `supported` above is false. This field is
       * OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string message = 2;</code>
       */
      public com.google.protobuf.ByteString
          getMessageBytes() {
        java.lang.Object ref = message_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          message_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Message to the CO if `supported` above is false. This field is
       * OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string message = 2;</code>
       */
      public Builder setMessage(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        message_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Message to the CO if `supported` above is false. This field is
       * OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string message = 2;</code>
       */
      public Builder clearMessage() {
        
        message_ = getDefaultInstance().getMessage();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Message to the CO if `supported` above is false. This field is
       * OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string message = 2;</code>
       */
      public Builder setMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        message_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.ValidateVolumeCapabilitiesResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.ValidateVolumeCapabilitiesResponse)
    private static final csi.v0.Csi.ValidateVolumeCapabilitiesResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.ValidateVolumeCapabilitiesResponse();
    }

    public static csi.v0.Csi.ValidateVolumeCapabilitiesResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ValidateVolumeCapabilitiesResponse>
        PARSER = new com.google.protobuf.AbstractParser<ValidateVolumeCapabilitiesResponse>() {
      @java.lang.Override
      public ValidateVolumeCapabilitiesResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ValidateVolumeCapabilitiesResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ValidateVolumeCapabilitiesResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ValidateVolumeCapabilitiesResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.ValidateVolumeCapabilitiesResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ListVolumesRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.ListVolumesRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * If specified (non-zero value), the Plugin MUST NOT return more
     * entries than this number in the response. If the actual number of
     * entries is more than this number, the Plugin MUST set `next_token`
     * in the response which can be used to get the next page of entries
     * in the subsequent `ListVolumes` call. This field is OPTIONAL. If
     * not specified (zero value), it means there is no restriction on the
     * number of entries that can be returned.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int32 max_entries = 1;</code>
     */
    int getMaxEntries();

    /**
     * <pre>
     * A token to specify where to start paginating. Set this field to
     * `next_token` returned by a previous `ListVolumes` call to get the
     * next page of entries. This field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string starting_token = 2;</code>
     */
    java.lang.String getStartingToken();
    /**
     * <pre>
     * A token to specify where to start paginating. Set this field to
     * `next_token` returned by a previous `ListVolumes` call to get the
     * next page of entries. This field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string starting_token = 2;</code>
     */
    com.google.protobuf.ByteString
        getStartingTokenBytes();
  }
  /**
   * Protobuf type {@code csi.v0.ListVolumesRequest}
   */
  public  static final class ListVolumesRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.ListVolumesRequest)
      ListVolumesRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ListVolumesRequest.newBuilder() to construct.
    private ListVolumesRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ListVolumesRequest() {
      maxEntries_ = 0;
      startingToken_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ListVolumesRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {

              maxEntries_ = input.readInt32();
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              startingToken_ = s;
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_ListVolumesRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_ListVolumesRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.ListVolumesRequest.class, csi.v0.Csi.ListVolumesRequest.Builder.class);
    }

    public static final int MAX_ENTRIES_FIELD_NUMBER = 1;
    private int maxEntries_;
    /**
     * <pre>
     * If specified (non-zero value), the Plugin MUST NOT return more
     * entries than this number in the response. If the actual number of
     * entries is more than this number, the Plugin MUST set `next_token`
     * in the response which can be used to get the next page of entries
     * in the subsequent `ListVolumes` call. This field is OPTIONAL. If
     * not specified (zero value), it means there is no restriction on the
     * number of entries that can be returned.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int32 max_entries = 1;</code>
     */
    public int getMaxEntries() {
      return maxEntries_;
    }

    public static final int STARTING_TOKEN_FIELD_NUMBER = 2;
    private volatile java.lang.Object startingToken_;
    /**
     * <pre>
     * A token to specify where to start paginating. Set this field to
     * `next_token` returned by a previous `ListVolumes` call to get the
     * next page of entries. This field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string starting_token = 2;</code>
     */
    public java.lang.String getStartingToken() {
      java.lang.Object ref = startingToken_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        startingToken_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A token to specify where to start paginating. Set this field to
     * `next_token` returned by a previous `ListVolumes` call to get the
     * next page of entries. This field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string starting_token = 2;</code>
     */
    public com.google.protobuf.ByteString
        getStartingTokenBytes() {
      java.lang.Object ref = startingToken_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        startingToken_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (maxEntries_ != 0) {
        output.writeInt32(1, maxEntries_);
      }
      if (!getStartingTokenBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, startingToken_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (maxEntries_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, maxEntries_);
      }
      if (!getStartingTokenBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, startingToken_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.ListVolumesRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.ListVolumesRequest other = (csi.v0.Csi.ListVolumesRequest) obj;

      boolean result = true;
      result = result && (getMaxEntries()
          == other.getMaxEntries());
      result = result && getStartingToken()
          .equals(other.getStartingToken());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + MAX_ENTRIES_FIELD_NUMBER;
      hash = (53 * hash) + getMaxEntries();
      hash = (37 * hash) + STARTING_TOKEN_FIELD_NUMBER;
      hash = (53 * hash) + getStartingToken().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.ListVolumesRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ListVolumesRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ListVolumesRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ListVolumesRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ListVolumesRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ListVolumesRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ListVolumesRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ListVolumesRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ListVolumesRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ListVolumesRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ListVolumesRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ListVolumesRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.ListVolumesRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.ListVolumesRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.ListVolumesRequest)
        csi.v0.Csi.ListVolumesRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ListVolumesRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ListVolumesRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ListVolumesRequest.class, csi.v0.Csi.ListVolumesRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.ListVolumesRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        maxEntries_ = 0;

        startingToken_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_ListVolumesRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.ListVolumesRequest getDefaultInstanceForType() {
        return csi.v0.Csi.ListVolumesRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.ListVolumesRequest build() {
        csi.v0.Csi.ListVolumesRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.ListVolumesRequest buildPartial() {
        csi.v0.Csi.ListVolumesRequest result = new csi.v0.Csi.ListVolumesRequest(this);
        result.maxEntries_ = maxEntries_;
        result.startingToken_ = startingToken_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.ListVolumesRequest) {
          return mergeFrom((csi.v0.Csi.ListVolumesRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.ListVolumesRequest other) {
        if (other == csi.v0.Csi.ListVolumesRequest.getDefaultInstance()) return this;
        if (other.getMaxEntries() != 0) {
          setMaxEntries(other.getMaxEntries());
        }
        if (!other.getStartingToken().isEmpty()) {
          startingToken_ = other.startingToken_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.ListVolumesRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.ListVolumesRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int maxEntries_ ;
      /**
       * <pre>
       * If specified (non-zero value), the Plugin MUST NOT return more
       * entries than this number in the response. If the actual number of
       * entries is more than this number, the Plugin MUST set `next_token`
       * in the response which can be used to get the next page of entries
       * in the subsequent `ListVolumes` call. This field is OPTIONAL. If
       * not specified (zero value), it means there is no restriction on the
       * number of entries that can be returned.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int32 max_entries = 1;</code>
       */
      public int getMaxEntries() {
        return maxEntries_;
      }
      /**
       * <pre>
       * If specified (non-zero value), the Plugin MUST NOT return more
       * entries than this number in the response. If the actual number of
       * entries is more than this number, the Plugin MUST set `next_token`
       * in the response which can be used to get the next page of entries
       * in the subsequent `ListVolumes` call. This field is OPTIONAL. If
       * not specified (zero value), it means there is no restriction on the
       * number of entries that can be returned.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int32 max_entries = 1;</code>
       */
      public Builder setMaxEntries(int value) {
        
        maxEntries_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified (non-zero value), the Plugin MUST NOT return more
       * entries than this number in the response. If the actual number of
       * entries is more than this number, the Plugin MUST set `next_token`
       * in the response which can be used to get the next page of entries
       * in the subsequent `ListVolumes` call. This field is OPTIONAL. If
       * not specified (zero value), it means there is no restriction on the
       * number of entries that can be returned.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int32 max_entries = 1;</code>
       */
      public Builder clearMaxEntries() {
        
        maxEntries_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object startingToken_ = "";
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListVolumes` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public java.lang.String getStartingToken() {
        java.lang.Object ref = startingToken_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          startingToken_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListVolumes` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public com.google.protobuf.ByteString
          getStartingTokenBytes() {
        java.lang.Object ref = startingToken_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          startingToken_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListVolumes` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public Builder setStartingToken(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        startingToken_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListVolumes` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public Builder clearStartingToken() {
        
        startingToken_ = getDefaultInstance().getStartingToken();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListVolumes` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public Builder setStartingTokenBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        startingToken_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.ListVolumesRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.ListVolumesRequest)
    private static final csi.v0.Csi.ListVolumesRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.ListVolumesRequest();
    }

    public static csi.v0.Csi.ListVolumesRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ListVolumesRequest>
        PARSER = new com.google.protobuf.AbstractParser<ListVolumesRequest>() {
      @java.lang.Override
      public ListVolumesRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ListVolumesRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ListVolumesRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ListVolumesRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.ListVolumesRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ListVolumesResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.ListVolumesResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
     */
    java.util.List<csi.v0.Csi.ListVolumesResponse.Entry> 
        getEntriesList();
    /**
     * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
     */
    csi.v0.Csi.ListVolumesResponse.Entry getEntries(int index);
    /**
     * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
     */
    int getEntriesCount();
    /**
     * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
     */
    java.util.List<? extends csi.v0.Csi.ListVolumesResponse.EntryOrBuilder> 
        getEntriesOrBuilderList();
    /**
     * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
     */
    csi.v0.Csi.ListVolumesResponse.EntryOrBuilder getEntriesOrBuilder(
        int index);

    /**
     * <pre>
     * This token allows you to get the next page of entries for
     * `ListVolumes` request. If the number of entries is larger than
     * `max_entries`, use the `next_token` as a value for the
     * `starting_token` field in the next `ListVolumes` request. This
     * field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string next_token = 2;</code>
     */
    java.lang.String getNextToken();
    /**
     * <pre>
     * This token allows you to get the next page of entries for
     * `ListVolumes` request. If the number of entries is larger than
     * `max_entries`, use the `next_token` as a value for the
     * `starting_token` field in the next `ListVolumes` request. This
     * field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string next_token = 2;</code>
     */
    com.google.protobuf.ByteString
        getNextTokenBytes();
  }
  /**
   * Protobuf type {@code csi.v0.ListVolumesResponse}
   */
  public  static final class ListVolumesResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.ListVolumesResponse)
      ListVolumesResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ListVolumesResponse.newBuilder() to construct.
    private ListVolumesResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ListVolumesResponse() {
      entries_ = java.util.Collections.emptyList();
      nextToken_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ListVolumesResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                entries_ = new java.util.ArrayList<csi.v0.Csi.ListVolumesResponse.Entry>();
                mutable_bitField0_ |= 0x00000001;
              }
              entries_.add(
                  input.readMessage(csi.v0.Csi.ListVolumesResponse.Entry.parser(), extensionRegistry));
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              nextToken_ = s;
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          entries_ = java.util.Collections.unmodifiableList(entries_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_ListVolumesResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_ListVolumesResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.ListVolumesResponse.class, csi.v0.Csi.ListVolumesResponse.Builder.class);
    }

    public interface EntryOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v0.ListVolumesResponse.Entry)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>.csi.v0.Volume volume = 1;</code>
       */
      boolean hasVolume();
      /**
       * <code>.csi.v0.Volume volume = 1;</code>
       */
      csi.v0.Csi.Volume getVolume();
      /**
       * <code>.csi.v0.Volume volume = 1;</code>
       */
      csi.v0.Csi.VolumeOrBuilder getVolumeOrBuilder();
    }
    /**
     * Protobuf type {@code csi.v0.ListVolumesResponse.Entry}
     */
    public  static final class Entry extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v0.ListVolumesResponse.Entry)
        EntryOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Entry.newBuilder() to construct.
      private Entry(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Entry() {
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private Entry(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                csi.v0.Csi.Volume.Builder subBuilder = null;
                if (volume_ != null) {
                  subBuilder = volume_.toBuilder();
                }
                volume_ = input.readMessage(csi.v0.Csi.Volume.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(volume_);
                  volume_ = subBuilder.buildPartial();
                }

                break;
              }
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ListVolumesResponse_Entry_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ListVolumesResponse_Entry_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ListVolumesResponse.Entry.class, csi.v0.Csi.ListVolumesResponse.Entry.Builder.class);
      }

      public static final int VOLUME_FIELD_NUMBER = 1;
      private csi.v0.Csi.Volume volume_;
      /**
       * <code>.csi.v0.Volume volume = 1;</code>
       */
      public boolean hasVolume() {
        return volume_ != null;
      }
      /**
       * <code>.csi.v0.Volume volume = 1;</code>
       */
      public csi.v0.Csi.Volume getVolume() {
        return volume_ == null ? csi.v0.Csi.Volume.getDefaultInstance() : volume_;
      }
      /**
       * <code>.csi.v0.Volume volume = 1;</code>
       */
      public csi.v0.Csi.VolumeOrBuilder getVolumeOrBuilder() {
        return getVolume();
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (volume_ != null) {
          output.writeMessage(1, getVolume());
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (volume_ != null) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, getVolume());
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v0.Csi.ListVolumesResponse.Entry)) {
          return super.equals(obj);
        }
        csi.v0.Csi.ListVolumesResponse.Entry other = (csi.v0.Csi.ListVolumesResponse.Entry) obj;

        boolean result = true;
        result = result && (hasVolume() == other.hasVolume());
        if (hasVolume()) {
          result = result && getVolume()
              .equals(other.getVolume());
        }
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasVolume()) {
          hash = (37 * hash) + VOLUME_FIELD_NUMBER;
          hash = (53 * hash) + getVolume().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v0.Csi.ListVolumesResponse.Entry parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.ListVolumesResponse.Entry parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.ListVolumesResponse.Entry parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.ListVolumesResponse.Entry parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.ListVolumesResponse.Entry parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.ListVolumesResponse.Entry parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.ListVolumesResponse.Entry parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.ListVolumesResponse.Entry parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.ListVolumesResponse.Entry parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.ListVolumesResponse.Entry parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.ListVolumesResponse.Entry parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.ListVolumesResponse.Entry parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v0.Csi.ListVolumesResponse.Entry prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code csi.v0.ListVolumesResponse.Entry}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v0.ListVolumesResponse.Entry)
          csi.v0.Csi.ListVolumesResponse.EntryOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v0.Csi.internal_static_csi_v0_ListVolumesResponse_Entry_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v0.Csi.internal_static_csi_v0_ListVolumesResponse_Entry_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v0.Csi.ListVolumesResponse.Entry.class, csi.v0.Csi.ListVolumesResponse.Entry.Builder.class);
        }

        // Construct using csi.v0.Csi.ListVolumesResponse.Entry.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          if (volumeBuilder_ == null) {
            volume_ = null;
          } else {
            volume_ = null;
            volumeBuilder_ = null;
          }
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v0.Csi.internal_static_csi_v0_ListVolumesResponse_Entry_descriptor;
        }

        @java.lang.Override
        public csi.v0.Csi.ListVolumesResponse.Entry getDefaultInstanceForType() {
          return csi.v0.Csi.ListVolumesResponse.Entry.getDefaultInstance();
        }

        @java.lang.Override
        public csi.v0.Csi.ListVolumesResponse.Entry build() {
          csi.v0.Csi.ListVolumesResponse.Entry result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public csi.v0.Csi.ListVolumesResponse.Entry buildPartial() {
          csi.v0.Csi.ListVolumesResponse.Entry result = new csi.v0.Csi.ListVolumesResponse.Entry(this);
          if (volumeBuilder_ == null) {
            result.volume_ = volume_;
          } else {
            result.volume_ = volumeBuilder_.build();
          }
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return (Builder) super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v0.Csi.ListVolumesResponse.Entry) {
            return mergeFrom((csi.v0.Csi.ListVolumesResponse.Entry)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v0.Csi.ListVolumesResponse.Entry other) {
          if (other == csi.v0.Csi.ListVolumesResponse.Entry.getDefaultInstance()) return this;
          if (other.hasVolume()) {
            mergeVolume(other.getVolume());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v0.Csi.ListVolumesResponse.Entry parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v0.Csi.ListVolumesResponse.Entry) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private csi.v0.Csi.Volume volume_ = null;
        private com.google.protobuf.SingleFieldBuilderV3<
            csi.v0.Csi.Volume, csi.v0.Csi.Volume.Builder, csi.v0.Csi.VolumeOrBuilder> volumeBuilder_;
        /**
         * <code>.csi.v0.Volume volume = 1;</code>
         */
        public boolean hasVolume() {
          return volumeBuilder_ != null || volume_ != null;
        }
        /**
         * <code>.csi.v0.Volume volume = 1;</code>
         */
        public csi.v0.Csi.Volume getVolume() {
          if (volumeBuilder_ == null) {
            return volume_ == null ? csi.v0.Csi.Volume.getDefaultInstance() : volume_;
          } else {
            return volumeBuilder_.getMessage();
          }
        }
        /**
         * <code>.csi.v0.Volume volume = 1;</code>
         */
        public Builder setVolume(csi.v0.Csi.Volume value) {
          if (volumeBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            volume_ = value;
            onChanged();
          } else {
            volumeBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <code>.csi.v0.Volume volume = 1;</code>
         */
        public Builder setVolume(
            csi.v0.Csi.Volume.Builder builderForValue) {
          if (volumeBuilder_ == null) {
            volume_ = builderForValue.build();
            onChanged();
          } else {
            volumeBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <code>.csi.v0.Volume volume = 1;</code>
         */
        public Builder mergeVolume(csi.v0.Csi.Volume value) {
          if (volumeBuilder_ == null) {
            if (volume_ != null) {
              volume_ =
                csi.v0.Csi.Volume.newBuilder(volume_).mergeFrom(value).buildPartial();
            } else {
              volume_ = value;
            }
            onChanged();
          } else {
            volumeBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <code>.csi.v0.Volume volume = 1;</code>
         */
        public Builder clearVolume() {
          if (volumeBuilder_ == null) {
            volume_ = null;
            onChanged();
          } else {
            volume_ = null;
            volumeBuilder_ = null;
          }

          return this;
        }
        /**
         * <code>.csi.v0.Volume volume = 1;</code>
         */
        public csi.v0.Csi.Volume.Builder getVolumeBuilder() {
          
          onChanged();
          return getVolumeFieldBuilder().getBuilder();
        }
        /**
         * <code>.csi.v0.Volume volume = 1;</code>
         */
        public csi.v0.Csi.VolumeOrBuilder getVolumeOrBuilder() {
          if (volumeBuilder_ != null) {
            return volumeBuilder_.getMessageOrBuilder();
          } else {
            return volume_ == null ?
                csi.v0.Csi.Volume.getDefaultInstance() : volume_;
          }
        }
        /**
         * <code>.csi.v0.Volume volume = 1;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            csi.v0.Csi.Volume, csi.v0.Csi.Volume.Builder, csi.v0.Csi.VolumeOrBuilder> 
            getVolumeFieldBuilder() {
          if (volumeBuilder_ == null) {
            volumeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                csi.v0.Csi.Volume, csi.v0.Csi.Volume.Builder, csi.v0.Csi.VolumeOrBuilder>(
                    getVolume(),
                    getParentForChildren(),
                    isClean());
            volume_ = null;
          }
          return volumeBuilder_;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v0.ListVolumesResponse.Entry)
      }

      // @@protoc_insertion_point(class_scope:csi.v0.ListVolumesResponse.Entry)
      private static final csi.v0.Csi.ListVolumesResponse.Entry DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v0.Csi.ListVolumesResponse.Entry();
      }

      public static csi.v0.Csi.ListVolumesResponse.Entry getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Entry>
          PARSER = new com.google.protobuf.AbstractParser<Entry>() {
        @java.lang.Override
        public Entry parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new Entry(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<Entry> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Entry> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public csi.v0.Csi.ListVolumesResponse.Entry getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int ENTRIES_FIELD_NUMBER = 1;
    private java.util.List<csi.v0.Csi.ListVolumesResponse.Entry> entries_;
    /**
     * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
     */
    public java.util.List<csi.v0.Csi.ListVolumesResponse.Entry> getEntriesList() {
      return entries_;
    }
    /**
     * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
     */
    public java.util.List<? extends csi.v0.Csi.ListVolumesResponse.EntryOrBuilder> 
        getEntriesOrBuilderList() {
      return entries_;
    }
    /**
     * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
     */
    public int getEntriesCount() {
      return entries_.size();
    }
    /**
     * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
     */
    public csi.v0.Csi.ListVolumesResponse.Entry getEntries(int index) {
      return entries_.get(index);
    }
    /**
     * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
     */
    public csi.v0.Csi.ListVolumesResponse.EntryOrBuilder getEntriesOrBuilder(
        int index) {
      return entries_.get(index);
    }

    public static final int NEXT_TOKEN_FIELD_NUMBER = 2;
    private volatile java.lang.Object nextToken_;
    /**
     * <pre>
     * This token allows you to get the next page of entries for
     * `ListVolumes` request. If the number of entries is larger than
     * `max_entries`, use the `next_token` as a value for the
     * `starting_token` field in the next `ListVolumes` request. This
     * field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string next_token = 2;</code>
     */
    public java.lang.String getNextToken() {
      java.lang.Object ref = nextToken_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        nextToken_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * This token allows you to get the next page of entries for
     * `ListVolumes` request. If the number of entries is larger than
     * `max_entries`, use the `next_token` as a value for the
     * `starting_token` field in the next `ListVolumes` request. This
     * field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string next_token = 2;</code>
     */
    public com.google.protobuf.ByteString
        getNextTokenBytes() {
      java.lang.Object ref = nextToken_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nextToken_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < entries_.size(); i++) {
        output.writeMessage(1, entries_.get(i));
      }
      if (!getNextTokenBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, nextToken_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < entries_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, entries_.get(i));
      }
      if (!getNextTokenBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, nextToken_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.ListVolumesResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.ListVolumesResponse other = (csi.v0.Csi.ListVolumesResponse) obj;

      boolean result = true;
      result = result && getEntriesList()
          .equals(other.getEntriesList());
      result = result && getNextToken()
          .equals(other.getNextToken());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getEntriesCount() > 0) {
        hash = (37 * hash) + ENTRIES_FIELD_NUMBER;
        hash = (53 * hash) + getEntriesList().hashCode();
      }
      hash = (37 * hash) + NEXT_TOKEN_FIELD_NUMBER;
      hash = (53 * hash) + getNextToken().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.ListVolumesResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ListVolumesResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ListVolumesResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ListVolumesResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ListVolumesResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ListVolumesResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ListVolumesResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ListVolumesResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ListVolumesResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ListVolumesResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ListVolumesResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ListVolumesResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.ListVolumesResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.ListVolumesResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.ListVolumesResponse)
        csi.v0.Csi.ListVolumesResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ListVolumesResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ListVolumesResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ListVolumesResponse.class, csi.v0.Csi.ListVolumesResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.ListVolumesResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getEntriesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (entriesBuilder_ == null) {
          entries_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          entriesBuilder_.clear();
        }
        nextToken_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_ListVolumesResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.ListVolumesResponse getDefaultInstanceForType() {
        return csi.v0.Csi.ListVolumesResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.ListVolumesResponse build() {
        csi.v0.Csi.ListVolumesResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.ListVolumesResponse buildPartial() {
        csi.v0.Csi.ListVolumesResponse result = new csi.v0.Csi.ListVolumesResponse(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (entriesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            entries_ = java.util.Collections.unmodifiableList(entries_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.entries_ = entries_;
        } else {
          result.entries_ = entriesBuilder_.build();
        }
        result.nextToken_ = nextToken_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.ListVolumesResponse) {
          return mergeFrom((csi.v0.Csi.ListVolumesResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.ListVolumesResponse other) {
        if (other == csi.v0.Csi.ListVolumesResponse.getDefaultInstance()) return this;
        if (entriesBuilder_ == null) {
          if (!other.entries_.isEmpty()) {
            if (entries_.isEmpty()) {
              entries_ = other.entries_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureEntriesIsMutable();
              entries_.addAll(other.entries_);
            }
            onChanged();
          }
        } else {
          if (!other.entries_.isEmpty()) {
            if (entriesBuilder_.isEmpty()) {
              entriesBuilder_.dispose();
              entriesBuilder_ = null;
              entries_ = other.entries_;
              bitField0_ = (bitField0_ & ~0x00000001);
              entriesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getEntriesFieldBuilder() : null;
            } else {
              entriesBuilder_.addAllMessages(other.entries_);
            }
          }
        }
        if (!other.getNextToken().isEmpty()) {
          nextToken_ = other.nextToken_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.ListVolumesResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.ListVolumesResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<csi.v0.Csi.ListVolumesResponse.Entry> entries_ =
        java.util.Collections.emptyList();
      private void ensureEntriesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          entries_ = new java.util.ArrayList<csi.v0.Csi.ListVolumesResponse.Entry>(entries_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.ListVolumesResponse.Entry, csi.v0.Csi.ListVolumesResponse.Entry.Builder, csi.v0.Csi.ListVolumesResponse.EntryOrBuilder> entriesBuilder_;

      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public java.util.List<csi.v0.Csi.ListVolumesResponse.Entry> getEntriesList() {
        if (entriesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(entries_);
        } else {
          return entriesBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public int getEntriesCount() {
        if (entriesBuilder_ == null) {
          return entries_.size();
        } else {
          return entriesBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public csi.v0.Csi.ListVolumesResponse.Entry getEntries(int index) {
        if (entriesBuilder_ == null) {
          return entries_.get(index);
        } else {
          return entriesBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder setEntries(
          int index, csi.v0.Csi.ListVolumesResponse.Entry value) {
        if (entriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEntriesIsMutable();
          entries_.set(index, value);
          onChanged();
        } else {
          entriesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder setEntries(
          int index, csi.v0.Csi.ListVolumesResponse.Entry.Builder builderForValue) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          entries_.set(index, builderForValue.build());
          onChanged();
        } else {
          entriesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder addEntries(csi.v0.Csi.ListVolumesResponse.Entry value) {
        if (entriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEntriesIsMutable();
          entries_.add(value);
          onChanged();
        } else {
          entriesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder addEntries(
          int index, csi.v0.Csi.ListVolumesResponse.Entry value) {
        if (entriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEntriesIsMutable();
          entries_.add(index, value);
          onChanged();
        } else {
          entriesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder addEntries(
          csi.v0.Csi.ListVolumesResponse.Entry.Builder builderForValue) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          entries_.add(builderForValue.build());
          onChanged();
        } else {
          entriesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder addEntries(
          int index, csi.v0.Csi.ListVolumesResponse.Entry.Builder builderForValue) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          entries_.add(index, builderForValue.build());
          onChanged();
        } else {
          entriesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder addAllEntries(
          java.lang.Iterable<? extends csi.v0.Csi.ListVolumesResponse.Entry> values) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, entries_);
          onChanged();
        } else {
          entriesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder clearEntries() {
        if (entriesBuilder_ == null) {
          entries_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          entriesBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public Builder removeEntries(int index) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          entries_.remove(index);
          onChanged();
        } else {
          entriesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public csi.v0.Csi.ListVolumesResponse.Entry.Builder getEntriesBuilder(
          int index) {
        return getEntriesFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public csi.v0.Csi.ListVolumesResponse.EntryOrBuilder getEntriesOrBuilder(
          int index) {
        if (entriesBuilder_ == null) {
          return entries_.get(index);  } else {
          return entriesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public java.util.List<? extends csi.v0.Csi.ListVolumesResponse.EntryOrBuilder> 
           getEntriesOrBuilderList() {
        if (entriesBuilder_ != null) {
          return entriesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(entries_);
        }
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public csi.v0.Csi.ListVolumesResponse.Entry.Builder addEntriesBuilder() {
        return getEntriesFieldBuilder().addBuilder(
            csi.v0.Csi.ListVolumesResponse.Entry.getDefaultInstance());
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public csi.v0.Csi.ListVolumesResponse.Entry.Builder addEntriesBuilder(
          int index) {
        return getEntriesFieldBuilder().addBuilder(
            index, csi.v0.Csi.ListVolumesResponse.Entry.getDefaultInstance());
      }
      /**
       * <code>repeated .csi.v0.ListVolumesResponse.Entry entries = 1;</code>
       */
      public java.util.List<csi.v0.Csi.ListVolumesResponse.Entry.Builder> 
           getEntriesBuilderList() {
        return getEntriesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.ListVolumesResponse.Entry, csi.v0.Csi.ListVolumesResponse.Entry.Builder, csi.v0.Csi.ListVolumesResponse.EntryOrBuilder> 
          getEntriesFieldBuilder() {
        if (entriesBuilder_ == null) {
          entriesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v0.Csi.ListVolumesResponse.Entry, csi.v0.Csi.ListVolumesResponse.Entry.Builder, csi.v0.Csi.ListVolumesResponse.EntryOrBuilder>(
                  entries_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          entries_ = null;
        }
        return entriesBuilder_;
      }

      private java.lang.Object nextToken_ = "";
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListVolumes` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListVolumes` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public java.lang.String getNextToken() {
        java.lang.Object ref = nextToken_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          nextToken_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListVolumes` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListVolumes` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public com.google.protobuf.ByteString
          getNextTokenBytes() {
        java.lang.Object ref = nextToken_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nextToken_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListVolumes` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListVolumes` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public Builder setNextToken(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        nextToken_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListVolumes` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListVolumes` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public Builder clearNextToken() {
        
        nextToken_ = getDefaultInstance().getNextToken();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListVolumes` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListVolumes` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public Builder setNextTokenBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        nextToken_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.ListVolumesResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.ListVolumesResponse)
    private static final csi.v0.Csi.ListVolumesResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.ListVolumesResponse();
    }

    public static csi.v0.Csi.ListVolumesResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ListVolumesResponse>
        PARSER = new com.google.protobuf.AbstractParser<ListVolumesResponse>() {
      @java.lang.Override
      public ListVolumesResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ListVolumesResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ListVolumesResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ListVolumesResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.ListVolumesResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GetCapacityRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.GetCapacityRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
     */
    java.util.List<csi.v0.Csi.VolumeCapability> 
        getVolumeCapabilitiesList();
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
     */
    csi.v0.Csi.VolumeCapability getVolumeCapabilities(int index);
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
     */
    int getVolumeCapabilitiesCount();
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
     */
    java.util.List<? extends csi.v0.Csi.VolumeCapabilityOrBuilder> 
        getVolumeCapabilitiesOrBuilderList();
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
     */
    csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
        int index);

    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */
    int getParametersCount();
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */
    boolean containsParameters(
        java.lang.String key);
    /**
     * Use {@link #getParametersMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getParameters();
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getParametersMap();
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */

    java.lang.String getParametersOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */

    java.lang.String getParametersOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that in the specified
     * `accessible_topology`. This is the same as the
     * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>.csi.v0.Topology accessible_topology = 3;</code>
     */
    boolean hasAccessibleTopology();
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that in the specified
     * `accessible_topology`. This is the same as the
     * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>.csi.v0.Topology accessible_topology = 3;</code>
     */
    csi.v0.Csi.Topology getAccessibleTopology();
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that in the specified
     * `accessible_topology`. This is the same as the
     * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>.csi.v0.Topology accessible_topology = 3;</code>
     */
    csi.v0.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder();
  }
  /**
   * Protobuf type {@code csi.v0.GetCapacityRequest}
   */
  public  static final class GetCapacityRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.GetCapacityRequest)
      GetCapacityRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GetCapacityRequest.newBuilder() to construct.
    private GetCapacityRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GetCapacityRequest() {
      volumeCapabilities_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private GetCapacityRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                volumeCapabilities_ = new java.util.ArrayList<csi.v0.Csi.VolumeCapability>();
                mutable_bitField0_ |= 0x00000001;
              }
              volumeCapabilities_.add(
                  input.readMessage(csi.v0.Csi.VolumeCapability.parser(), extensionRegistry));
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                parameters_ = com.google.protobuf.MapField.newMapField(
                    ParametersDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000002;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              parameters__ = input.readMessage(
                  ParametersDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              parameters_.getMutableMap().put(
                  parameters__.getKey(), parameters__.getValue());
              break;
            }
            case 26: {
              csi.v0.Csi.Topology.Builder subBuilder = null;
              if (accessibleTopology_ != null) {
                subBuilder = accessibleTopology_.toBuilder();
              }
              accessibleTopology_ = input.readMessage(csi.v0.Csi.Topology.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(accessibleTopology_);
                accessibleTopology_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          volumeCapabilities_ = java.util.Collections.unmodifiableList(volumeCapabilities_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_GetCapacityRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetParameters();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_GetCapacityRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.GetCapacityRequest.class, csi.v0.Csi.GetCapacityRequest.Builder.class);
    }

    private int bitField0_;
    public static final int VOLUME_CAPABILITIES_FIELD_NUMBER = 1;
    private java.util.List<csi.v0.Csi.VolumeCapability> volumeCapabilities_;
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
     */
    public java.util.List<csi.v0.Csi.VolumeCapability> getVolumeCapabilitiesList() {
      return volumeCapabilities_;
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
     */
    public java.util.List<? extends csi.v0.Csi.VolumeCapabilityOrBuilder> 
        getVolumeCapabilitiesOrBuilderList() {
      return volumeCapabilities_;
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
     */
    public int getVolumeCapabilitiesCount() {
      return volumeCapabilities_.size();
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
     */
    public csi.v0.Csi.VolumeCapability getVolumeCapabilities(int index) {
      return volumeCapabilities_.get(index);
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that satisfy ALL of the
     * specified `volume_capabilities`. These are the same
     * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
     */
    public csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
        int index) {
      return volumeCapabilities_.get(index);
    }

    public static final int PARAMETERS_FIELD_NUMBER = 2;
    private static final class ParametersDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_GetCapacityRequest_ParametersEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> parameters_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetParameters() {
      if (parameters_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ParametersDefaultEntryHolder.defaultEntry);
      }
      return parameters_;
    }

    public int getParametersCount() {
      return internalGetParameters().getMap().size();
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */

    public boolean containsParameters(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetParameters().getMap().containsKey(key);
    }
    /**
     * Use {@link #getParametersMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getParameters() {
      return getParametersMap();
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
      return internalGetParameters().getMap();
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */

    public java.lang.String getParametersOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetParameters().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes with the given Plugin
     * specific `parameters`. These are the same `parameters` the CO will
     * use in `CreateVolumeRequest`. This field is OPTIONAL.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 2;</code>
     */

    public java.lang.String getParametersOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetParameters().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int ACCESSIBLE_TOPOLOGY_FIELD_NUMBER = 3;
    private csi.v0.Csi.Topology accessibleTopology_;
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that in the specified
     * `accessible_topology`. This is the same as the
     * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>.csi.v0.Topology accessible_topology = 3;</code>
     */
    public boolean hasAccessibleTopology() {
      return accessibleTopology_ != null;
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that in the specified
     * `accessible_topology`. This is the same as the
     * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>.csi.v0.Topology accessible_topology = 3;</code>
     */
    public csi.v0.Csi.Topology getAccessibleTopology() {
      return accessibleTopology_ == null ? csi.v0.Csi.Topology.getDefaultInstance() : accessibleTopology_;
    }
    /**
     * <pre>
     * If specified, the Plugin SHALL report the capacity of the storage
     * that can be used to provision volumes that in the specified
     * `accessible_topology`. This is the same as the
     * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
     * This field is OPTIONAL. This field SHALL NOT be set unless the
     * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
     * </pre>
     *
     * <code>.csi.v0.Topology accessible_topology = 3;</code>
     */
    public csi.v0.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder() {
      return getAccessibleTopology();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < volumeCapabilities_.size(); i++) {
        output.writeMessage(1, volumeCapabilities_.get(i));
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetParameters(),
          ParametersDefaultEntryHolder.defaultEntry,
          2);
      if (accessibleTopology_ != null) {
        output.writeMessage(3, getAccessibleTopology());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < volumeCapabilities_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, volumeCapabilities_.get(i));
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetParameters().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        parameters__ = ParametersDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, parameters__);
      }
      if (accessibleTopology_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getAccessibleTopology());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.GetCapacityRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.GetCapacityRequest other = (csi.v0.Csi.GetCapacityRequest) obj;

      boolean result = true;
      result = result && getVolumeCapabilitiesList()
          .equals(other.getVolumeCapabilitiesList());
      result = result && internalGetParameters().equals(
          other.internalGetParameters());
      result = result && (hasAccessibleTopology() == other.hasAccessibleTopology());
      if (hasAccessibleTopology()) {
        result = result && getAccessibleTopology()
            .equals(other.getAccessibleTopology());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getVolumeCapabilitiesCount() > 0) {
        hash = (37 * hash) + VOLUME_CAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeCapabilitiesList().hashCode();
      }
      if (!internalGetParameters().getMap().isEmpty()) {
        hash = (37 * hash) + PARAMETERS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetParameters().hashCode();
      }
      if (hasAccessibleTopology()) {
        hash = (37 * hash) + ACCESSIBLE_TOPOLOGY_FIELD_NUMBER;
        hash = (53 * hash) + getAccessibleTopology().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.GetCapacityRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetCapacityRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetCapacityRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetCapacityRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetCapacityRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetCapacityRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetCapacityRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetCapacityRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.GetCapacityRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetCapacityRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.GetCapacityRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetCapacityRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.GetCapacityRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.GetCapacityRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.GetCapacityRequest)
        csi.v0.Csi.GetCapacityRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_GetCapacityRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetParameters();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutableParameters();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_GetCapacityRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.GetCapacityRequest.class, csi.v0.Csi.GetCapacityRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.GetCapacityRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getVolumeCapabilitiesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          volumeCapabilitiesBuilder_.clear();
        }
        internalGetMutableParameters().clear();
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = null;
        } else {
          accessibleTopology_ = null;
          accessibleTopologyBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_GetCapacityRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.GetCapacityRequest getDefaultInstanceForType() {
        return csi.v0.Csi.GetCapacityRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.GetCapacityRequest build() {
        csi.v0.Csi.GetCapacityRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.GetCapacityRequest buildPartial() {
        csi.v0.Csi.GetCapacityRequest result = new csi.v0.Csi.GetCapacityRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (volumeCapabilitiesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            volumeCapabilities_ = java.util.Collections.unmodifiableList(volumeCapabilities_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.volumeCapabilities_ = volumeCapabilities_;
        } else {
          result.volumeCapabilities_ = volumeCapabilitiesBuilder_.build();
        }
        result.parameters_ = internalGetParameters();
        result.parameters_.makeImmutable();
        if (accessibleTopologyBuilder_ == null) {
          result.accessibleTopology_ = accessibleTopology_;
        } else {
          result.accessibleTopology_ = accessibleTopologyBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.GetCapacityRequest) {
          return mergeFrom((csi.v0.Csi.GetCapacityRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.GetCapacityRequest other) {
        if (other == csi.v0.Csi.GetCapacityRequest.getDefaultInstance()) return this;
        if (volumeCapabilitiesBuilder_ == null) {
          if (!other.volumeCapabilities_.isEmpty()) {
            if (volumeCapabilities_.isEmpty()) {
              volumeCapabilities_ = other.volumeCapabilities_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureVolumeCapabilitiesIsMutable();
              volumeCapabilities_.addAll(other.volumeCapabilities_);
            }
            onChanged();
          }
        } else {
          if (!other.volumeCapabilities_.isEmpty()) {
            if (volumeCapabilitiesBuilder_.isEmpty()) {
              volumeCapabilitiesBuilder_.dispose();
              volumeCapabilitiesBuilder_ = null;
              volumeCapabilities_ = other.volumeCapabilities_;
              bitField0_ = (bitField0_ & ~0x00000001);
              volumeCapabilitiesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getVolumeCapabilitiesFieldBuilder() : null;
            } else {
              volumeCapabilitiesBuilder_.addAllMessages(other.volumeCapabilities_);
            }
          }
        }
        internalGetMutableParameters().mergeFrom(
            other.internalGetParameters());
        if (other.hasAccessibleTopology()) {
          mergeAccessibleTopology(other.getAccessibleTopology());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.GetCapacityRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.GetCapacityRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<csi.v0.Csi.VolumeCapability> volumeCapabilities_ =
        java.util.Collections.emptyList();
      private void ensureVolumeCapabilitiesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          volumeCapabilities_ = new java.util.ArrayList<csi.v0.Csi.VolumeCapability>(volumeCapabilities_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder> volumeCapabilitiesBuilder_;

      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public java.util.List<csi.v0.Csi.VolumeCapability> getVolumeCapabilitiesList() {
        if (volumeCapabilitiesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(volumeCapabilities_);
        } else {
          return volumeCapabilitiesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public int getVolumeCapabilitiesCount() {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.size();
        } else {
          return volumeCapabilitiesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public csi.v0.Csi.VolumeCapability getVolumeCapabilities(int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.get(index);
        } else {
          return volumeCapabilitiesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder setVolumeCapabilities(
          int index, csi.v0.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.set(index, value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder setVolumeCapabilities(
          int index, csi.v0.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.set(index, builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder addVolumeCapabilities(csi.v0.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder addVolumeCapabilities(
          int index, csi.v0.Csi.VolumeCapability value) {
        if (volumeCapabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(index, value);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder addVolumeCapabilities(
          csi.v0.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder addVolumeCapabilities(
          int index, csi.v0.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.add(index, builderForValue.build());
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder addAllVolumeCapabilities(
          java.lang.Iterable<? extends csi.v0.Csi.VolumeCapability> values) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, volumeCapabilities_);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder clearVolumeCapabilities() {
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public Builder removeVolumeCapabilities(int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          ensureVolumeCapabilitiesIsMutable();
          volumeCapabilities_.remove(index);
          onChanged();
        } else {
          volumeCapabilitiesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public csi.v0.Csi.VolumeCapability.Builder getVolumeCapabilitiesBuilder(
          int index) {
        return getVolumeCapabilitiesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilitiesOrBuilder(
          int index) {
        if (volumeCapabilitiesBuilder_ == null) {
          return volumeCapabilities_.get(index);  } else {
          return volumeCapabilitiesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public java.util.List<? extends csi.v0.Csi.VolumeCapabilityOrBuilder> 
           getVolumeCapabilitiesOrBuilderList() {
        if (volumeCapabilitiesBuilder_ != null) {
          return volumeCapabilitiesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(volumeCapabilities_);
        }
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public csi.v0.Csi.VolumeCapability.Builder addVolumeCapabilitiesBuilder() {
        return getVolumeCapabilitiesFieldBuilder().addBuilder(
            csi.v0.Csi.VolumeCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public csi.v0.Csi.VolumeCapability.Builder addVolumeCapabilitiesBuilder(
          int index) {
        return getVolumeCapabilitiesFieldBuilder().addBuilder(
            index, csi.v0.Csi.VolumeCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that satisfy ALL of the
       * specified `volume_capabilities`. These are the same
       * `volume_capabilities` the CO will use in `CreateVolumeRequest`.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.VolumeCapability volume_capabilities = 1;</code>
       */
      public java.util.List<csi.v0.Csi.VolumeCapability.Builder> 
           getVolumeCapabilitiesBuilderList() {
        return getVolumeCapabilitiesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder> 
          getVolumeCapabilitiesFieldBuilder() {
        if (volumeCapabilitiesBuilder_ == null) {
          volumeCapabilitiesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder>(
                  volumeCapabilities_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          volumeCapabilities_ = null;
        }
        return volumeCapabilitiesBuilder_;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> parameters_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetParameters() {
        if (parameters_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        return parameters_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableParameters() {
        onChanged();;
        if (parameters_ == null) {
          parameters_ = com.google.protobuf.MapField.newMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        if (!parameters_.isMutable()) {
          parameters_ = parameters_.copy();
        }
        return parameters_;
      }

      public int getParametersCount() {
        return internalGetParameters().getMap().size();
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes with the given Plugin
       * specific `parameters`. These are the same `parameters` the CO will
       * use in `CreateVolumeRequest`. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 2;</code>
       */

      public boolean containsParameters(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetParameters().getMap().containsKey(key);
      }
      /**
       * Use {@link #getParametersMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getParameters() {
        return getParametersMap();
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes with the given Plugin
       * specific `parameters`. These are the same `parameters` the CO will
       * use in `CreateVolumeRequest`. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 2;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
        return internalGetParameters().getMap();
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes with the given Plugin
       * specific `parameters`. These are the same `parameters` the CO will
       * use in `CreateVolumeRequest`. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 2;</code>
       */

      public java.lang.String getParametersOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes with the given Plugin
       * specific `parameters`. These are the same `parameters` the CO will
       * use in `CreateVolumeRequest`. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 2;</code>
       */

      public java.lang.String getParametersOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearParameters() {
        internalGetMutableParameters().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes with the given Plugin
       * specific `parameters`. These are the same `parameters` the CO will
       * use in `CreateVolumeRequest`. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 2;</code>
       */

      public Builder removeParameters(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableParameters().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableParameters() {
        return internalGetMutableParameters().getMutableMap();
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes with the given Plugin
       * specific `parameters`. These are the same `parameters` the CO will
       * use in `CreateVolumeRequest`. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 2;</code>
       */
      public Builder putParameters(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableParameters().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes with the given Plugin
       * specific `parameters`. These are the same `parameters` the CO will
       * use in `CreateVolumeRequest`. This field is OPTIONAL.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 2;</code>
       */

      public Builder putAllParameters(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableParameters().getMutableMap()
            .putAll(values);
        return this;
      }

      private csi.v0.Csi.Topology accessibleTopology_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder> accessibleTopologyBuilder_;
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      public boolean hasAccessibleTopology() {
        return accessibleTopologyBuilder_ != null || accessibleTopology_ != null;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      public csi.v0.Csi.Topology getAccessibleTopology() {
        if (accessibleTopologyBuilder_ == null) {
          return accessibleTopology_ == null ? csi.v0.Csi.Topology.getDefaultInstance() : accessibleTopology_;
        } else {
          return accessibleTopologyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      public Builder setAccessibleTopology(csi.v0.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          accessibleTopology_ = value;
          onChanged();
        } else {
          accessibleTopologyBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      public Builder setAccessibleTopology(
          csi.v0.Csi.Topology.Builder builderForValue) {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = builderForValue.build();
          onChanged();
        } else {
          accessibleTopologyBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      public Builder mergeAccessibleTopology(csi.v0.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (accessibleTopology_ != null) {
            accessibleTopology_ =
              csi.v0.Csi.Topology.newBuilder(accessibleTopology_).mergeFrom(value).buildPartial();
          } else {
            accessibleTopology_ = value;
          }
          onChanged();
        } else {
          accessibleTopologyBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      public Builder clearAccessibleTopology() {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = null;
          onChanged();
        } else {
          accessibleTopology_ = null;
          accessibleTopologyBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      public csi.v0.Csi.Topology.Builder getAccessibleTopologyBuilder() {
        
        onChanged();
        return getAccessibleTopologyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      public csi.v0.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder() {
        if (accessibleTopologyBuilder_ != null) {
          return accessibleTopologyBuilder_.getMessageOrBuilder();
        } else {
          return accessibleTopology_ == null ?
              csi.v0.Csi.Topology.getDefaultInstance() : accessibleTopology_;
        }
      }
      /**
       * <pre>
       * If specified, the Plugin SHALL report the capacity of the storage
       * that can be used to provision volumes that in the specified
       * `accessible_topology`. This is the same as the
       * `accessible_topology` the CO returns in a `CreateVolumeResponse`.
       * This field is OPTIONAL. This field SHALL NOT be set unless the
       * plugin advertises the ACCESSIBILITY_CONSTRAINTS capability.
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder> 
          getAccessibleTopologyFieldBuilder() {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopologyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder>(
                  getAccessibleTopology(),
                  getParentForChildren(),
                  isClean());
          accessibleTopology_ = null;
        }
        return accessibleTopologyBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.GetCapacityRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.GetCapacityRequest)
    private static final csi.v0.Csi.GetCapacityRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.GetCapacityRequest();
    }

    public static csi.v0.Csi.GetCapacityRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GetCapacityRequest>
        PARSER = new com.google.protobuf.AbstractParser<GetCapacityRequest>() {
      @java.lang.Override
      public GetCapacityRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new GetCapacityRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<GetCapacityRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GetCapacityRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.GetCapacityRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface GetCapacityResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.GetCapacityResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The available capacity, in bytes, of the storage that can be used
     * to provision volumes. If `volume_capabilities` or `parameters` is
     * specified in the request, the Plugin SHALL take those into
     * consideration when calculating the available capacity of the
     * storage. This field is REQUIRED.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 available_capacity = 1;</code>
     */
    long getAvailableCapacity();
  }
  /**
   * Protobuf type {@code csi.v0.GetCapacityResponse}
   */
  public  static final class GetCapacityResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.GetCapacityResponse)
      GetCapacityResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use GetCapacityResponse.newBuilder() to construct.
    private GetCapacityResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private GetCapacityResponse() {
      availableCapacity_ = 0L;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private GetCapacityResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {

              availableCapacity_ = input.readInt64();
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_GetCapacityResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_GetCapacityResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.GetCapacityResponse.class, csi.v0.Csi.GetCapacityResponse.Builder.class);
    }

    public static final int AVAILABLE_CAPACITY_FIELD_NUMBER = 1;
    private long availableCapacity_;
    /**
     * <pre>
     * The available capacity, in bytes, of the storage that can be used
     * to provision volumes. If `volume_capabilities` or `parameters` is
     * specified in the request, the Plugin SHALL take those into
     * consideration when calculating the available capacity of the
     * storage. This field is REQUIRED.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int64 available_capacity = 1;</code>
     */
    public long getAvailableCapacity() {
      return availableCapacity_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (availableCapacity_ != 0L) {
        output.writeInt64(1, availableCapacity_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (availableCapacity_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, availableCapacity_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.GetCapacityResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.GetCapacityResponse other = (csi.v0.Csi.GetCapacityResponse) obj;

      boolean result = true;
      result = result && (getAvailableCapacity()
          == other.getAvailableCapacity());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + AVAILABLE_CAPACITY_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getAvailableCapacity());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.GetCapacityResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetCapacityResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetCapacityResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetCapacityResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetCapacityResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.GetCapacityResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.GetCapacityResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetCapacityResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.GetCapacityResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetCapacityResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.GetCapacityResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.GetCapacityResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.GetCapacityResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.GetCapacityResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.GetCapacityResponse)
        csi.v0.Csi.GetCapacityResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_GetCapacityResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_GetCapacityResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.GetCapacityResponse.class, csi.v0.Csi.GetCapacityResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.GetCapacityResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        availableCapacity_ = 0L;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_GetCapacityResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.GetCapacityResponse getDefaultInstanceForType() {
        return csi.v0.Csi.GetCapacityResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.GetCapacityResponse build() {
        csi.v0.Csi.GetCapacityResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.GetCapacityResponse buildPartial() {
        csi.v0.Csi.GetCapacityResponse result = new csi.v0.Csi.GetCapacityResponse(this);
        result.availableCapacity_ = availableCapacity_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.GetCapacityResponse) {
          return mergeFrom((csi.v0.Csi.GetCapacityResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.GetCapacityResponse other) {
        if (other == csi.v0.Csi.GetCapacityResponse.getDefaultInstance()) return this;
        if (other.getAvailableCapacity() != 0L) {
          setAvailableCapacity(other.getAvailableCapacity());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.GetCapacityResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.GetCapacityResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private long availableCapacity_ ;
      /**
       * <pre>
       * The available capacity, in bytes, of the storage that can be used
       * to provision volumes. If `volume_capabilities` or `parameters` is
       * specified in the request, the Plugin SHALL take those into
       * consideration when calculating the available capacity of the
       * storage. This field is REQUIRED.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 available_capacity = 1;</code>
       */
      public long getAvailableCapacity() {
        return availableCapacity_;
      }
      /**
       * <pre>
       * The available capacity, in bytes, of the storage that can be used
       * to provision volumes. If `volume_capabilities` or `parameters` is
       * specified in the request, the Plugin SHALL take those into
       * consideration when calculating the available capacity of the
       * storage. This field is REQUIRED.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 available_capacity = 1;</code>
       */
      public Builder setAvailableCapacity(long value) {
        
        availableCapacity_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The available capacity, in bytes, of the storage that can be used
       * to provision volumes. If `volume_capabilities` or `parameters` is
       * specified in the request, the Plugin SHALL take those into
       * consideration when calculating the available capacity of the
       * storage. This field is REQUIRED.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int64 available_capacity = 1;</code>
       */
      public Builder clearAvailableCapacity() {
        
        availableCapacity_ = 0L;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.GetCapacityResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.GetCapacityResponse)
    private static final csi.v0.Csi.GetCapacityResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.GetCapacityResponse();
    }

    public static csi.v0.Csi.GetCapacityResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<GetCapacityResponse>
        PARSER = new com.google.protobuf.AbstractParser<GetCapacityResponse>() {
      @java.lang.Override
      public GetCapacityResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new GetCapacityResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<GetCapacityResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<GetCapacityResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.GetCapacityResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerGetCapabilitiesRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.ControllerGetCapabilitiesRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v0.ControllerGetCapabilitiesRequest}
   */
  public  static final class ControllerGetCapabilitiesRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.ControllerGetCapabilitiesRequest)
      ControllerGetCapabilitiesRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ControllerGetCapabilitiesRequest.newBuilder() to construct.
    private ControllerGetCapabilitiesRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ControllerGetCapabilitiesRequest() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ControllerGetCapabilitiesRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_ControllerGetCapabilitiesRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_ControllerGetCapabilitiesRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.ControllerGetCapabilitiesRequest.class, csi.v0.Csi.ControllerGetCapabilitiesRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.ControllerGetCapabilitiesRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.ControllerGetCapabilitiesRequest other = (csi.v0.Csi.ControllerGetCapabilitiesRequest) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.ControllerGetCapabilitiesRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.ControllerGetCapabilitiesRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v0.ControllerGetCapabilitiesRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.ControllerGetCapabilitiesRequest)
        csi.v0.Csi.ControllerGetCapabilitiesRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerGetCapabilitiesRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerGetCapabilitiesRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ControllerGetCapabilitiesRequest.class, csi.v0.Csi.ControllerGetCapabilitiesRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.ControllerGetCapabilitiesRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerGetCapabilitiesRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerGetCapabilitiesRequest getDefaultInstanceForType() {
        return csi.v0.Csi.ControllerGetCapabilitiesRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerGetCapabilitiesRequest build() {
        csi.v0.Csi.ControllerGetCapabilitiesRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerGetCapabilitiesRequest buildPartial() {
        csi.v0.Csi.ControllerGetCapabilitiesRequest result = new csi.v0.Csi.ControllerGetCapabilitiesRequest(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.ControllerGetCapabilitiesRequest) {
          return mergeFrom((csi.v0.Csi.ControllerGetCapabilitiesRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.ControllerGetCapabilitiesRequest other) {
        if (other == csi.v0.Csi.ControllerGetCapabilitiesRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.ControllerGetCapabilitiesRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.ControllerGetCapabilitiesRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.ControllerGetCapabilitiesRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.ControllerGetCapabilitiesRequest)
    private static final csi.v0.Csi.ControllerGetCapabilitiesRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.ControllerGetCapabilitiesRequest();
    }

    public static csi.v0.Csi.ControllerGetCapabilitiesRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerGetCapabilitiesRequest>
        PARSER = new com.google.protobuf.AbstractParser<ControllerGetCapabilitiesRequest>() {
      @java.lang.Override
      public ControllerGetCapabilitiesRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ControllerGetCapabilitiesRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ControllerGetCapabilitiesRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerGetCapabilitiesRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.ControllerGetCapabilitiesRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerGetCapabilitiesResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.ControllerGetCapabilitiesResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
     */
    java.util.List<csi.v0.Csi.ControllerServiceCapability> 
        getCapabilitiesList();
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
     */
    csi.v0.Csi.ControllerServiceCapability getCapabilities(int index);
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
     */
    int getCapabilitiesCount();
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
     */
    java.util.List<? extends csi.v0.Csi.ControllerServiceCapabilityOrBuilder> 
        getCapabilitiesOrBuilderList();
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
     */
    csi.v0.Csi.ControllerServiceCapabilityOrBuilder getCapabilitiesOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code csi.v0.ControllerGetCapabilitiesResponse}
   */
  public  static final class ControllerGetCapabilitiesResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.ControllerGetCapabilitiesResponse)
      ControllerGetCapabilitiesResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ControllerGetCapabilitiesResponse.newBuilder() to construct.
    private ControllerGetCapabilitiesResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ControllerGetCapabilitiesResponse() {
      capabilities_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ControllerGetCapabilitiesResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 18: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                capabilities_ = new java.util.ArrayList<csi.v0.Csi.ControllerServiceCapability>();
                mutable_bitField0_ |= 0x00000001;
              }
              capabilities_.add(
                  input.readMessage(csi.v0.Csi.ControllerServiceCapability.parser(), extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          capabilities_ = java.util.Collections.unmodifiableList(capabilities_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_ControllerGetCapabilitiesResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_ControllerGetCapabilitiesResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.ControllerGetCapabilitiesResponse.class, csi.v0.Csi.ControllerGetCapabilitiesResponse.Builder.class);
    }

    public static final int CAPABILITIES_FIELD_NUMBER = 2;
    private java.util.List<csi.v0.Csi.ControllerServiceCapability> capabilities_;
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
     */
    public java.util.List<csi.v0.Csi.ControllerServiceCapability> getCapabilitiesList() {
      return capabilities_;
    }
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
     */
    public java.util.List<? extends csi.v0.Csi.ControllerServiceCapabilityOrBuilder> 
        getCapabilitiesOrBuilderList() {
      return capabilities_;
    }
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
     */
    public int getCapabilitiesCount() {
      return capabilities_.size();
    }
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
     */
    public csi.v0.Csi.ControllerServiceCapability getCapabilities(int index) {
      return capabilities_.get(index);
    }
    /**
     * <pre>
     * All the capabilities that the controller service supports. This
     * field is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
     */
    public csi.v0.Csi.ControllerServiceCapabilityOrBuilder getCapabilitiesOrBuilder(
        int index) {
      return capabilities_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < capabilities_.size(); i++) {
        output.writeMessage(2, capabilities_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < capabilities_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, capabilities_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.ControllerGetCapabilitiesResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.ControllerGetCapabilitiesResponse other = (csi.v0.Csi.ControllerGetCapabilitiesResponse) obj;

      boolean result = true;
      result = result && getCapabilitiesList()
          .equals(other.getCapabilitiesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getCapabilitiesCount() > 0) {
        hash = (37 * hash) + CAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getCapabilitiesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.ControllerGetCapabilitiesResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerGetCapabilitiesResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.ControllerGetCapabilitiesResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.ControllerGetCapabilitiesResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.ControllerGetCapabilitiesResponse)
        csi.v0.Csi.ControllerGetCapabilitiesResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerGetCapabilitiesResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerGetCapabilitiesResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ControllerGetCapabilitiesResponse.class, csi.v0.Csi.ControllerGetCapabilitiesResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.ControllerGetCapabilitiesResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getCapabilitiesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (capabilitiesBuilder_ == null) {
          capabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          capabilitiesBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerGetCapabilitiesResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerGetCapabilitiesResponse getDefaultInstanceForType() {
        return csi.v0.Csi.ControllerGetCapabilitiesResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerGetCapabilitiesResponse build() {
        csi.v0.Csi.ControllerGetCapabilitiesResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerGetCapabilitiesResponse buildPartial() {
        csi.v0.Csi.ControllerGetCapabilitiesResponse result = new csi.v0.Csi.ControllerGetCapabilitiesResponse(this);
        int from_bitField0_ = bitField0_;
        if (capabilitiesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            capabilities_ = java.util.Collections.unmodifiableList(capabilities_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.capabilities_ = capabilities_;
        } else {
          result.capabilities_ = capabilitiesBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.ControllerGetCapabilitiesResponse) {
          return mergeFrom((csi.v0.Csi.ControllerGetCapabilitiesResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.ControllerGetCapabilitiesResponse other) {
        if (other == csi.v0.Csi.ControllerGetCapabilitiesResponse.getDefaultInstance()) return this;
        if (capabilitiesBuilder_ == null) {
          if (!other.capabilities_.isEmpty()) {
            if (capabilities_.isEmpty()) {
              capabilities_ = other.capabilities_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureCapabilitiesIsMutable();
              capabilities_.addAll(other.capabilities_);
            }
            onChanged();
          }
        } else {
          if (!other.capabilities_.isEmpty()) {
            if (capabilitiesBuilder_.isEmpty()) {
              capabilitiesBuilder_.dispose();
              capabilitiesBuilder_ = null;
              capabilities_ = other.capabilities_;
              bitField0_ = (bitField0_ & ~0x00000001);
              capabilitiesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getCapabilitiesFieldBuilder() : null;
            } else {
              capabilitiesBuilder_.addAllMessages(other.capabilities_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.ControllerGetCapabilitiesResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.ControllerGetCapabilitiesResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<csi.v0.Csi.ControllerServiceCapability> capabilities_ =
        java.util.Collections.emptyList();
      private void ensureCapabilitiesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          capabilities_ = new java.util.ArrayList<csi.v0.Csi.ControllerServiceCapability>(capabilities_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.ControllerServiceCapability, csi.v0.Csi.ControllerServiceCapability.Builder, csi.v0.Csi.ControllerServiceCapabilityOrBuilder> capabilitiesBuilder_;

      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public java.util.List<csi.v0.Csi.ControllerServiceCapability> getCapabilitiesList() {
        if (capabilitiesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(capabilities_);
        } else {
          return capabilitiesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public int getCapabilitiesCount() {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.size();
        } else {
          return capabilitiesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public csi.v0.Csi.ControllerServiceCapability getCapabilities(int index) {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.get(index);
        } else {
          return capabilitiesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public Builder setCapabilities(
          int index, csi.v0.Csi.ControllerServiceCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.set(index, value);
          onChanged();
        } else {
          capabilitiesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public Builder setCapabilities(
          int index, csi.v0.Csi.ControllerServiceCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.set(index, builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public Builder addCapabilities(csi.v0.Csi.ControllerServiceCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.add(value);
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public Builder addCapabilities(
          int index, csi.v0.Csi.ControllerServiceCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.add(index, value);
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public Builder addCapabilities(
          csi.v0.Csi.ControllerServiceCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.add(builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public Builder addCapabilities(
          int index, csi.v0.Csi.ControllerServiceCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.add(index, builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public Builder addAllCapabilities(
          java.lang.Iterable<? extends csi.v0.Csi.ControllerServiceCapability> values) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, capabilities_);
          onChanged();
        } else {
          capabilitiesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public Builder clearCapabilities() {
        if (capabilitiesBuilder_ == null) {
          capabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          capabilitiesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public Builder removeCapabilities(int index) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.remove(index);
          onChanged();
        } else {
          capabilitiesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public csi.v0.Csi.ControllerServiceCapability.Builder getCapabilitiesBuilder(
          int index) {
        return getCapabilitiesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public csi.v0.Csi.ControllerServiceCapabilityOrBuilder getCapabilitiesOrBuilder(
          int index) {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.get(index);  } else {
          return capabilitiesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public java.util.List<? extends csi.v0.Csi.ControllerServiceCapabilityOrBuilder> 
           getCapabilitiesOrBuilderList() {
        if (capabilitiesBuilder_ != null) {
          return capabilitiesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(capabilities_);
        }
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public csi.v0.Csi.ControllerServiceCapability.Builder addCapabilitiesBuilder() {
        return getCapabilitiesFieldBuilder().addBuilder(
            csi.v0.Csi.ControllerServiceCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public csi.v0.Csi.ControllerServiceCapability.Builder addCapabilitiesBuilder(
          int index) {
        return getCapabilitiesFieldBuilder().addBuilder(
            index, csi.v0.Csi.ControllerServiceCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * All the capabilities that the controller service supports. This
       * field is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.ControllerServiceCapability capabilities = 2;</code>
       */
      public java.util.List<csi.v0.Csi.ControllerServiceCapability.Builder> 
           getCapabilitiesBuilderList() {
        return getCapabilitiesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.ControllerServiceCapability, csi.v0.Csi.ControllerServiceCapability.Builder, csi.v0.Csi.ControllerServiceCapabilityOrBuilder> 
          getCapabilitiesFieldBuilder() {
        if (capabilitiesBuilder_ == null) {
          capabilitiesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v0.Csi.ControllerServiceCapability, csi.v0.Csi.ControllerServiceCapability.Builder, csi.v0.Csi.ControllerServiceCapabilityOrBuilder>(
                  capabilities_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          capabilities_ = null;
        }
        return capabilitiesBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.ControllerGetCapabilitiesResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.ControllerGetCapabilitiesResponse)
    private static final csi.v0.Csi.ControllerGetCapabilitiesResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.ControllerGetCapabilitiesResponse();
    }

    public static csi.v0.Csi.ControllerGetCapabilitiesResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerGetCapabilitiesResponse>
        PARSER = new com.google.protobuf.AbstractParser<ControllerGetCapabilitiesResponse>() {
      @java.lang.Override
      public ControllerGetCapabilitiesResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ControllerGetCapabilitiesResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ControllerGetCapabilitiesResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerGetCapabilitiesResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.ControllerGetCapabilitiesResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ControllerServiceCapabilityOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.ControllerServiceCapability)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v0.ControllerServiceCapability.RPC rpc = 1;</code>
     */
    boolean hasRpc();
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v0.ControllerServiceCapability.RPC rpc = 1;</code>
     */
    csi.v0.Csi.ControllerServiceCapability.RPC getRpc();
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v0.ControllerServiceCapability.RPC rpc = 1;</code>
     */
    csi.v0.Csi.ControllerServiceCapability.RPCOrBuilder getRpcOrBuilder();

    public csi.v0.Csi.ControllerServiceCapability.TypeCase getTypeCase();
  }
  /**
   * <pre>
   * Specifies a capability of the controller service.
   * </pre>
   *
   * Protobuf type {@code csi.v0.ControllerServiceCapability}
   */
  public  static final class ControllerServiceCapability extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.ControllerServiceCapability)
      ControllerServiceCapabilityOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ControllerServiceCapability.newBuilder() to construct.
    private ControllerServiceCapability(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ControllerServiceCapability() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ControllerServiceCapability(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              csi.v0.Csi.ControllerServiceCapability.RPC.Builder subBuilder = null;
              if (typeCase_ == 1) {
                subBuilder = ((csi.v0.Csi.ControllerServiceCapability.RPC) type_).toBuilder();
              }
              type_ =
                  input.readMessage(csi.v0.Csi.ControllerServiceCapability.RPC.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((csi.v0.Csi.ControllerServiceCapability.RPC) type_);
                type_ = subBuilder.buildPartial();
              }
              typeCase_ = 1;
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_ControllerServiceCapability_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_ControllerServiceCapability_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.ControllerServiceCapability.class, csi.v0.Csi.ControllerServiceCapability.Builder.class);
    }

    public interface RPCOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v0.ControllerServiceCapability.RPC)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>.csi.v0.ControllerServiceCapability.RPC.Type type = 1;</code>
       */
      int getTypeValue();
      /**
       * <code>.csi.v0.ControllerServiceCapability.RPC.Type type = 1;</code>
       */
      csi.v0.Csi.ControllerServiceCapability.RPC.Type getType();
    }
    /**
     * Protobuf type {@code csi.v0.ControllerServiceCapability.RPC}
     */
    public  static final class RPC extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v0.ControllerServiceCapability.RPC)
        RPCOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use RPC.newBuilder() to construct.
      private RPC(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private RPC() {
        type_ = 0;
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private RPC(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int rawValue = input.readEnum();

                type_ = rawValue;
                break;
              }
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerServiceCapability_RPC_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerServiceCapability_RPC_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ControllerServiceCapability.RPC.class, csi.v0.Csi.ControllerServiceCapability.RPC.Builder.class);
      }

      /**
       * Protobuf enum {@code csi.v0.ControllerServiceCapability.RPC.Type}
       */
      public enum Type
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <code>UNKNOWN = 0;</code>
         */
        UNKNOWN(0),
        /**
         * <code>CREATE_DELETE_VOLUME = 1;</code>
         */
        CREATE_DELETE_VOLUME(1),
        /**
         * <code>PUBLISH_UNPUBLISH_VOLUME = 2;</code>
         */
        PUBLISH_UNPUBLISH_VOLUME(2),
        /**
         * <code>LIST_VOLUMES = 3;</code>
         */
        LIST_VOLUMES(3),
        /**
         * <code>GET_CAPACITY = 4;</code>
         */
        GET_CAPACITY(4),
        /**
         * <pre>
         * Currently the only way to consume a snapshot is to create
         * a volume from it. Therefore plugins supporting
         * CREATE_DELETE_SNAPSHOT MUST support creating volume from
         * snapshot.
         * </pre>
         *
         * <code>CREATE_DELETE_SNAPSHOT = 5;</code>
         */
        CREATE_DELETE_SNAPSHOT(5),
        /**
         * <pre>
         * LIST_SNAPSHOTS is NOT REQUIRED. For plugins that need to upload
         * a snapshot after it is being cut, LIST_SNAPSHOTS COULD be used
         * with the snapshot_id as the filter to query whether the
         * uploading process is complete or not.
         * </pre>
         *
         * <code>LIST_SNAPSHOTS = 6;</code>
         */
        LIST_SNAPSHOTS(6),
        UNRECOGNIZED(-1),
        ;

        /**
         * <code>UNKNOWN = 0;</code>
         */
        public static final int UNKNOWN_VALUE = 0;
        /**
         * <code>CREATE_DELETE_VOLUME = 1;</code>
         */
        public static final int CREATE_DELETE_VOLUME_VALUE = 1;
        /**
         * <code>PUBLISH_UNPUBLISH_VOLUME = 2;</code>
         */
        public static final int PUBLISH_UNPUBLISH_VOLUME_VALUE = 2;
        /**
         * <code>LIST_VOLUMES = 3;</code>
         */
        public static final int LIST_VOLUMES_VALUE = 3;
        /**
         * <code>GET_CAPACITY = 4;</code>
         */
        public static final int GET_CAPACITY_VALUE = 4;
        /**
         * <pre>
         * Currently the only way to consume a snapshot is to create
         * a volume from it. Therefore plugins supporting
         * CREATE_DELETE_SNAPSHOT MUST support creating volume from
         * snapshot.
         * </pre>
         *
         * <code>CREATE_DELETE_SNAPSHOT = 5;</code>
         */
        public static final int CREATE_DELETE_SNAPSHOT_VALUE = 5;
        /**
         * <pre>
         * LIST_SNAPSHOTS is NOT REQUIRED. For plugins that need to upload
         * a snapshot after it is being cut, LIST_SNAPSHOTS COULD be used
         * with the snapshot_id as the filter to query whether the
         * uploading process is complete or not.
         * </pre>
         *
         * <code>LIST_SNAPSHOTS = 6;</code>
         */
        public static final int LIST_SNAPSHOTS_VALUE = 6;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static Type valueOf(int value) {
          return forNumber(value);
        }

        public static Type forNumber(int value) {
          switch (value) {
            case 0: return UNKNOWN;
            case 1: return CREATE_DELETE_VOLUME;
            case 2: return PUBLISH_UNPUBLISH_VOLUME;
            case 3: return LIST_VOLUMES;
            case 4: return GET_CAPACITY;
            case 5: return CREATE_DELETE_SNAPSHOT;
            case 6: return LIST_SNAPSHOTS;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<Type>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            Type> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Type>() {
                public Type findValueByNumber(int number) {
                  return Type.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return csi.v0.Csi.ControllerServiceCapability.RPC.getDescriptor().getEnumTypes().get(0);
        }

        private static final Type[] VALUES = values();

        public static Type valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private Type(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:csi.v0.ControllerServiceCapability.RPC.Type)
      }

      public static final int TYPE_FIELD_NUMBER = 1;
      private int type_;
      /**
       * <code>.csi.v0.ControllerServiceCapability.RPC.Type type = 1;</code>
       */
      public int getTypeValue() {
        return type_;
      }
      /**
       * <code>.csi.v0.ControllerServiceCapability.RPC.Type type = 1;</code>
       */
      public csi.v0.Csi.ControllerServiceCapability.RPC.Type getType() {
        @SuppressWarnings("deprecation")
        csi.v0.Csi.ControllerServiceCapability.RPC.Type result = csi.v0.Csi.ControllerServiceCapability.RPC.Type.valueOf(type_);
        return result == null ? csi.v0.Csi.ControllerServiceCapability.RPC.Type.UNRECOGNIZED : result;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (type_ != csi.v0.Csi.ControllerServiceCapability.RPC.Type.UNKNOWN.getNumber()) {
          output.writeEnum(1, type_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (type_ != csi.v0.Csi.ControllerServiceCapability.RPC.Type.UNKNOWN.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(1, type_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v0.Csi.ControllerServiceCapability.RPC)) {
          return super.equals(obj);
        }
        csi.v0.Csi.ControllerServiceCapability.RPC other = (csi.v0.Csi.ControllerServiceCapability.RPC) obj;

        boolean result = true;
        result = result && type_ == other.type_;
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v0.Csi.ControllerServiceCapability.RPC parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.ControllerServiceCapability.RPC parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.ControllerServiceCapability.RPC parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.ControllerServiceCapability.RPC parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.ControllerServiceCapability.RPC parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.ControllerServiceCapability.RPC parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.ControllerServiceCapability.RPC parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.ControllerServiceCapability.RPC parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.ControllerServiceCapability.RPC parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.ControllerServiceCapability.RPC parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.ControllerServiceCapability.RPC parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.ControllerServiceCapability.RPC parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v0.Csi.ControllerServiceCapability.RPC prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code csi.v0.ControllerServiceCapability.RPC}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v0.ControllerServiceCapability.RPC)
          csi.v0.Csi.ControllerServiceCapability.RPCOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v0.Csi.internal_static_csi_v0_ControllerServiceCapability_RPC_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v0.Csi.internal_static_csi_v0_ControllerServiceCapability_RPC_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v0.Csi.ControllerServiceCapability.RPC.class, csi.v0.Csi.ControllerServiceCapability.RPC.Builder.class);
        }

        // Construct using csi.v0.Csi.ControllerServiceCapability.RPC.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          type_ = 0;

          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v0.Csi.internal_static_csi_v0_ControllerServiceCapability_RPC_descriptor;
        }

        @java.lang.Override
        public csi.v0.Csi.ControllerServiceCapability.RPC getDefaultInstanceForType() {
          return csi.v0.Csi.ControllerServiceCapability.RPC.getDefaultInstance();
        }

        @java.lang.Override
        public csi.v0.Csi.ControllerServiceCapability.RPC build() {
          csi.v0.Csi.ControllerServiceCapability.RPC result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public csi.v0.Csi.ControllerServiceCapability.RPC buildPartial() {
          csi.v0.Csi.ControllerServiceCapability.RPC result = new csi.v0.Csi.ControllerServiceCapability.RPC(this);
          result.type_ = type_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return (Builder) super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v0.Csi.ControllerServiceCapability.RPC) {
            return mergeFrom((csi.v0.Csi.ControllerServiceCapability.RPC)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v0.Csi.ControllerServiceCapability.RPC other) {
          if (other == csi.v0.Csi.ControllerServiceCapability.RPC.getDefaultInstance()) return this;
          if (other.type_ != 0) {
            setTypeValue(other.getTypeValue());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v0.Csi.ControllerServiceCapability.RPC parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v0.Csi.ControllerServiceCapability.RPC) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private int type_ = 0;
        /**
         * <code>.csi.v0.ControllerServiceCapability.RPC.Type type = 1;</code>
         */
        public int getTypeValue() {
          return type_;
        }
        /**
         * <code>.csi.v0.ControllerServiceCapability.RPC.Type type = 1;</code>
         */
        public Builder setTypeValue(int value) {
          type_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>.csi.v0.ControllerServiceCapability.RPC.Type type = 1;</code>
         */
        public csi.v0.Csi.ControllerServiceCapability.RPC.Type getType() {
          @SuppressWarnings("deprecation")
          csi.v0.Csi.ControllerServiceCapability.RPC.Type result = csi.v0.Csi.ControllerServiceCapability.RPC.Type.valueOf(type_);
          return result == null ? csi.v0.Csi.ControllerServiceCapability.RPC.Type.UNRECOGNIZED : result;
        }
        /**
         * <code>.csi.v0.ControllerServiceCapability.RPC.Type type = 1;</code>
         */
        public Builder setType(csi.v0.Csi.ControllerServiceCapability.RPC.Type value) {
          if (value == null) {
            throw new NullPointerException();
          }
          
          type_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <code>.csi.v0.ControllerServiceCapability.RPC.Type type = 1;</code>
         */
        public Builder clearType() {
          
          type_ = 0;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v0.ControllerServiceCapability.RPC)
      }

      // @@protoc_insertion_point(class_scope:csi.v0.ControllerServiceCapability.RPC)
      private static final csi.v0.Csi.ControllerServiceCapability.RPC DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v0.Csi.ControllerServiceCapability.RPC();
      }

      public static csi.v0.Csi.ControllerServiceCapability.RPC getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<RPC>
          PARSER = new com.google.protobuf.AbstractParser<RPC>() {
        @java.lang.Override
        public RPC parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new RPC(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<RPC> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<RPC> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerServiceCapability.RPC getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int typeCase_ = 0;
    private java.lang.Object type_;
    public enum TypeCase
        implements com.google.protobuf.Internal.EnumLite {
      RPC(1),
      TYPE_NOT_SET(0);
      private final int value;
      private TypeCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TypeCase valueOf(int value) {
        return forNumber(value);
      }

      public static TypeCase forNumber(int value) {
        switch (value) {
          case 1: return RPC;
          case 0: return TYPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public TypeCase
    getTypeCase() {
      return TypeCase.forNumber(
          typeCase_);
    }

    public static final int RPC_FIELD_NUMBER = 1;
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v0.ControllerServiceCapability.RPC rpc = 1;</code>
     */
    public boolean hasRpc() {
      return typeCase_ == 1;
    }
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v0.ControllerServiceCapability.RPC rpc = 1;</code>
     */
    public csi.v0.Csi.ControllerServiceCapability.RPC getRpc() {
      if (typeCase_ == 1) {
         return (csi.v0.Csi.ControllerServiceCapability.RPC) type_;
      }
      return csi.v0.Csi.ControllerServiceCapability.RPC.getDefaultInstance();
    }
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v0.ControllerServiceCapability.RPC rpc = 1;</code>
     */
    public csi.v0.Csi.ControllerServiceCapability.RPCOrBuilder getRpcOrBuilder() {
      if (typeCase_ == 1) {
         return (csi.v0.Csi.ControllerServiceCapability.RPC) type_;
      }
      return csi.v0.Csi.ControllerServiceCapability.RPC.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (typeCase_ == 1) {
        output.writeMessage(1, (csi.v0.Csi.ControllerServiceCapability.RPC) type_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (typeCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, (csi.v0.Csi.ControllerServiceCapability.RPC) type_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.ControllerServiceCapability)) {
        return super.equals(obj);
      }
      csi.v0.Csi.ControllerServiceCapability other = (csi.v0.Csi.ControllerServiceCapability) obj;

      boolean result = true;
      result = result && getTypeCase().equals(
          other.getTypeCase());
      if (!result) return false;
      switch (typeCase_) {
        case 1:
          result = result && getRpc()
              .equals(other.getRpc());
          break;
        case 0:
        default:
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      switch (typeCase_) {
        case 1:
          hash = (37 * hash) + RPC_FIELD_NUMBER;
          hash = (53 * hash) + getRpc().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.ControllerServiceCapability parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerServiceCapability parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerServiceCapability parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerServiceCapability parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerServiceCapability parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ControllerServiceCapability parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerServiceCapability parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerServiceCapability parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerServiceCapability parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerServiceCapability parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ControllerServiceCapability parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ControllerServiceCapability parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.ControllerServiceCapability prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specifies a capability of the controller service.
     * </pre>
     *
     * Protobuf type {@code csi.v0.ControllerServiceCapability}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.ControllerServiceCapability)
        csi.v0.Csi.ControllerServiceCapabilityOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerServiceCapability_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerServiceCapability_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ControllerServiceCapability.class, csi.v0.Csi.ControllerServiceCapability.Builder.class);
      }

      // Construct using csi.v0.Csi.ControllerServiceCapability.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        typeCase_ = 0;
        type_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_ControllerServiceCapability_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerServiceCapability getDefaultInstanceForType() {
        return csi.v0.Csi.ControllerServiceCapability.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerServiceCapability build() {
        csi.v0.Csi.ControllerServiceCapability result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.ControllerServiceCapability buildPartial() {
        csi.v0.Csi.ControllerServiceCapability result = new csi.v0.Csi.ControllerServiceCapability(this);
        if (typeCase_ == 1) {
          if (rpcBuilder_ == null) {
            result.type_ = type_;
          } else {
            result.type_ = rpcBuilder_.build();
          }
        }
        result.typeCase_ = typeCase_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.ControllerServiceCapability) {
          return mergeFrom((csi.v0.Csi.ControllerServiceCapability)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.ControllerServiceCapability other) {
        if (other == csi.v0.Csi.ControllerServiceCapability.getDefaultInstance()) return this;
        switch (other.getTypeCase()) {
          case RPC: {
            mergeRpc(other.getRpc());
            break;
          }
          case TYPE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.ControllerServiceCapability parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.ControllerServiceCapability) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int typeCase_ = 0;
      private java.lang.Object type_;
      public TypeCase
          getTypeCase() {
        return TypeCase.forNumber(
            typeCase_);
      }

      public Builder clearType() {
        typeCase_ = 0;
        type_ = null;
        onChanged();
        return this;
      }


      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.ControllerServiceCapability.RPC, csi.v0.Csi.ControllerServiceCapability.RPC.Builder, csi.v0.Csi.ControllerServiceCapability.RPCOrBuilder> rpcBuilder_;
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      public boolean hasRpc() {
        return typeCase_ == 1;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      public csi.v0.Csi.ControllerServiceCapability.RPC getRpc() {
        if (rpcBuilder_ == null) {
          if (typeCase_ == 1) {
            return (csi.v0.Csi.ControllerServiceCapability.RPC) type_;
          }
          return csi.v0.Csi.ControllerServiceCapability.RPC.getDefaultInstance();
        } else {
          if (typeCase_ == 1) {
            return rpcBuilder_.getMessage();
          }
          return csi.v0.Csi.ControllerServiceCapability.RPC.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      public Builder setRpc(csi.v0.Csi.ControllerServiceCapability.RPC value) {
        if (rpcBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          type_ = value;
          onChanged();
        } else {
          rpcBuilder_.setMessage(value);
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      public Builder setRpc(
          csi.v0.Csi.ControllerServiceCapability.RPC.Builder builderForValue) {
        if (rpcBuilder_ == null) {
          type_ = builderForValue.build();
          onChanged();
        } else {
          rpcBuilder_.setMessage(builderForValue.build());
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      public Builder mergeRpc(csi.v0.Csi.ControllerServiceCapability.RPC value) {
        if (rpcBuilder_ == null) {
          if (typeCase_ == 1 &&
              type_ != csi.v0.Csi.ControllerServiceCapability.RPC.getDefaultInstance()) {
            type_ = csi.v0.Csi.ControllerServiceCapability.RPC.newBuilder((csi.v0.Csi.ControllerServiceCapability.RPC) type_)
                .mergeFrom(value).buildPartial();
          } else {
            type_ = value;
          }
          onChanged();
        } else {
          if (typeCase_ == 1) {
            rpcBuilder_.mergeFrom(value);
          }
          rpcBuilder_.setMessage(value);
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      public Builder clearRpc() {
        if (rpcBuilder_ == null) {
          if (typeCase_ == 1) {
            typeCase_ = 0;
            type_ = null;
            onChanged();
          }
        } else {
          if (typeCase_ == 1) {
            typeCase_ = 0;
            type_ = null;
          }
          rpcBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      public csi.v0.Csi.ControllerServiceCapability.RPC.Builder getRpcBuilder() {
        return getRpcFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      public csi.v0.Csi.ControllerServiceCapability.RPCOrBuilder getRpcOrBuilder() {
        if ((typeCase_ == 1) && (rpcBuilder_ != null)) {
          return rpcBuilder_.getMessageOrBuilder();
        } else {
          if (typeCase_ == 1) {
            return (csi.v0.Csi.ControllerServiceCapability.RPC) type_;
          }
          return csi.v0.Csi.ControllerServiceCapability.RPC.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.ControllerServiceCapability.RPC rpc = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.ControllerServiceCapability.RPC, csi.v0.Csi.ControllerServiceCapability.RPC.Builder, csi.v0.Csi.ControllerServiceCapability.RPCOrBuilder> 
          getRpcFieldBuilder() {
        if (rpcBuilder_ == null) {
          if (!(typeCase_ == 1)) {
            type_ = csi.v0.Csi.ControllerServiceCapability.RPC.getDefaultInstance();
          }
          rpcBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.ControllerServiceCapability.RPC, csi.v0.Csi.ControllerServiceCapability.RPC.Builder, csi.v0.Csi.ControllerServiceCapability.RPCOrBuilder>(
                  (csi.v0.Csi.ControllerServiceCapability.RPC) type_,
                  getParentForChildren(),
                  isClean());
          type_ = null;
        }
        typeCase_ = 1;
        onChanged();;
        return rpcBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.ControllerServiceCapability)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.ControllerServiceCapability)
    private static final csi.v0.Csi.ControllerServiceCapability DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.ControllerServiceCapability();
    }

    public static csi.v0.Csi.ControllerServiceCapability getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ControllerServiceCapability>
        PARSER = new com.google.protobuf.AbstractParser<ControllerServiceCapability>() {
      @java.lang.Override
      public ControllerServiceCapability parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ControllerServiceCapability(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ControllerServiceCapability> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ControllerServiceCapability> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.ControllerServiceCapability getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CreateSnapshotRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.CreateSnapshotRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the source volume to be snapshotted.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string source_volume_id = 1;</code>
     */
    java.lang.String getSourceVolumeId();
    /**
     * <pre>
     * The ID of the source volume to be snapshotted.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string source_volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getSourceVolumeIdBytes();

    /**
     * <pre>
     * The suggested name for the snapshot. This field is REQUIRED for
     * idempotency.
     * </pre>
     *
     * <code>string name = 2;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * The suggested name for the snapshot. This field is REQUIRED for
     * idempotency.
     * </pre>
     *
     * <code>string name = 2;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; create_snapshot_secrets = 3;</code>
     */
    int getCreateSnapshotSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; create_snapshot_secrets = 3;</code>
     */
    boolean containsCreateSnapshotSecrets(
        java.lang.String key);
    /**
     * Use {@link #getCreateSnapshotSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getCreateSnapshotSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; create_snapshot_secrets = 3;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getCreateSnapshotSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; create_snapshot_secrets = 3;</code>
     */

    java.lang.String getCreateSnapshotSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; create_snapshot_secrets = 3;</code>
     */

    java.lang.String getCreateSnapshotSecretsOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */
    int getParametersCount();
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */
    boolean containsParameters(
        java.lang.String key);
    /**
     * Use {@link #getParametersMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getParameters();
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getParametersMap();
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    java.lang.String getParametersOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    java.lang.String getParametersOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v0.CreateSnapshotRequest}
   */
  public  static final class CreateSnapshotRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.CreateSnapshotRequest)
      CreateSnapshotRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CreateSnapshotRequest.newBuilder() to construct.
    private CreateSnapshotRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CreateSnapshotRequest() {
      sourceVolumeId_ = "";
      name_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CreateSnapshotRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              sourceVolumeId_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                createSnapshotSecrets_ = com.google.protobuf.MapField.newMapField(
                    CreateSnapshotSecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000004;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              createSnapshotSecrets__ = input.readMessage(
                  CreateSnapshotSecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              createSnapshotSecrets_.getMutableMap().put(
                  createSnapshotSecrets__.getKey(), createSnapshotSecrets__.getValue());
              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                parameters_ = com.google.protobuf.MapField.newMapField(
                    ParametersDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000008;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              parameters__ = input.readMessage(
                  ParametersDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              parameters_.getMutableMap().put(
                  parameters__.getKey(), parameters__.getValue());
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_CreateSnapshotRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 3:
          return internalGetCreateSnapshotSecrets();
        case 4:
          return internalGetParameters();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_CreateSnapshotRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.CreateSnapshotRequest.class, csi.v0.Csi.CreateSnapshotRequest.Builder.class);
    }

    private int bitField0_;
    public static final int SOURCE_VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object sourceVolumeId_;
    /**
     * <pre>
     * The ID of the source volume to be snapshotted.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string source_volume_id = 1;</code>
     */
    public java.lang.String getSourceVolumeId() {
      java.lang.Object ref = sourceVolumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        sourceVolumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the source volume to be snapshotted.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string source_volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getSourceVolumeIdBytes() {
      java.lang.Object ref = sourceVolumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        sourceVolumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAME_FIELD_NUMBER = 2;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * The suggested name for the snapshot. This field is REQUIRED for
     * idempotency.
     * </pre>
     *
     * <code>string name = 2;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The suggested name for the snapshot. This field is REQUIRED for
     * idempotency.
     * </pre>
     *
     * <code>string name = 2;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CREATE_SNAPSHOT_SECRETS_FIELD_NUMBER = 3;
    private static final class CreateSnapshotSecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_CreateSnapshotRequest_CreateSnapshotSecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> createSnapshotSecrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetCreateSnapshotSecrets() {
      if (createSnapshotSecrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            CreateSnapshotSecretsDefaultEntryHolder.defaultEntry);
      }
      return createSnapshotSecrets_;
    }

    public int getCreateSnapshotSecretsCount() {
      return internalGetCreateSnapshotSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; create_snapshot_secrets = 3;</code>
     */

    public boolean containsCreateSnapshotSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetCreateSnapshotSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getCreateSnapshotSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getCreateSnapshotSecrets() {
      return getCreateSnapshotSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; create_snapshot_secrets = 3;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getCreateSnapshotSecretsMap() {
      return internalGetCreateSnapshotSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; create_snapshot_secrets = 3;</code>
     */

    public java.lang.String getCreateSnapshotSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetCreateSnapshotSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot creation request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; create_snapshot_secrets = 3;</code>
     */

    public java.lang.String getCreateSnapshotSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetCreateSnapshotSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int PARAMETERS_FIELD_NUMBER = 4;
    private static final class ParametersDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_CreateSnapshotRequest_ParametersEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> parameters_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetParameters() {
      if (parameters_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ParametersDefaultEntryHolder.defaultEntry);
      }
      return parameters_;
    }

    public int getParametersCount() {
      return internalGetParameters().getMap().size();
    }
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public boolean containsParameters(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetParameters().getMap().containsKey(key);
    }
    /**
     * Use {@link #getParametersMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getParameters() {
      return getParametersMap();
    }
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
      return internalGetParameters().getMap();
    }
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public java.lang.String getParametersOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetParameters().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Plugin specific parameters passed in as opaque key-value pairs.
     * This field is OPTIONAL. The Plugin is responsible for parsing and
     * validating these parameters. COs will treat these as opaque.
     * Use cases for opaque parameters:
     * - Specify a policy to automatically clean up the snapshot.
     * - Specify an expiration date for the snapshot.
     * - Specify whether the snapshot is readonly or read/write.
     * - Specify if the snapshot should be replicated to some place.
     * - Specify primary or secondary for replication systems that
     *   support snapshotting only on primary.
     * </pre>
     *
     * <code>map&lt;string, string&gt; parameters = 4;</code>
     */

    public java.lang.String getParametersOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetParameters().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getSourceVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, sourceVolumeId_);
      }
      if (!getNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, name_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetCreateSnapshotSecrets(),
          CreateSnapshotSecretsDefaultEntryHolder.defaultEntry,
          3);
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetParameters(),
          ParametersDefaultEntryHolder.defaultEntry,
          4);
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getSourceVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, sourceVolumeId_);
      }
      if (!getNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, name_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetCreateSnapshotSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        createSnapshotSecrets__ = CreateSnapshotSecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(3, createSnapshotSecrets__);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetParameters().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        parameters__ = ParametersDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(4, parameters__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.CreateSnapshotRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.CreateSnapshotRequest other = (csi.v0.Csi.CreateSnapshotRequest) obj;

      boolean result = true;
      result = result && getSourceVolumeId()
          .equals(other.getSourceVolumeId());
      result = result && getName()
          .equals(other.getName());
      result = result && internalGetCreateSnapshotSecrets().equals(
          other.internalGetCreateSnapshotSecrets());
      result = result && internalGetParameters().equals(
          other.internalGetParameters());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SOURCE_VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSourceVolumeId().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      if (!internalGetCreateSnapshotSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + CREATE_SNAPSHOT_SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetCreateSnapshotSecrets().hashCode();
      }
      if (!internalGetParameters().getMap().isEmpty()) {
        hash = (37 * hash) + PARAMETERS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetParameters().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.CreateSnapshotRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.CreateSnapshotRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.CreateSnapshotRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.CreateSnapshotRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.CreateSnapshotRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.CreateSnapshotRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.CreateSnapshotRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.CreateSnapshotRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.CreateSnapshotRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.CreateSnapshotRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.CreateSnapshotRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.CreateSnapshotRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.CreateSnapshotRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.CreateSnapshotRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.CreateSnapshotRequest)
        csi.v0.Csi.CreateSnapshotRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_CreateSnapshotRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetCreateSnapshotSecrets();
          case 4:
            return internalGetParameters();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 3:
            return internalGetMutableCreateSnapshotSecrets();
          case 4:
            return internalGetMutableParameters();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_CreateSnapshotRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.CreateSnapshotRequest.class, csi.v0.Csi.CreateSnapshotRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.CreateSnapshotRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        sourceVolumeId_ = "";

        name_ = "";

        internalGetMutableCreateSnapshotSecrets().clear();
        internalGetMutableParameters().clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_CreateSnapshotRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.CreateSnapshotRequest getDefaultInstanceForType() {
        return csi.v0.Csi.CreateSnapshotRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.CreateSnapshotRequest build() {
        csi.v0.Csi.CreateSnapshotRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.CreateSnapshotRequest buildPartial() {
        csi.v0.Csi.CreateSnapshotRequest result = new csi.v0.Csi.CreateSnapshotRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.sourceVolumeId_ = sourceVolumeId_;
        result.name_ = name_;
        result.createSnapshotSecrets_ = internalGetCreateSnapshotSecrets();
        result.createSnapshotSecrets_.makeImmutable();
        result.parameters_ = internalGetParameters();
        result.parameters_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.CreateSnapshotRequest) {
          return mergeFrom((csi.v0.Csi.CreateSnapshotRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.CreateSnapshotRequest other) {
        if (other == csi.v0.Csi.CreateSnapshotRequest.getDefaultInstance()) return this;
        if (!other.getSourceVolumeId().isEmpty()) {
          sourceVolumeId_ = other.sourceVolumeId_;
          onChanged();
        }
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        internalGetMutableCreateSnapshotSecrets().mergeFrom(
            other.internalGetCreateSnapshotSecrets());
        internalGetMutableParameters().mergeFrom(
            other.internalGetParameters());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.CreateSnapshotRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.CreateSnapshotRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object sourceVolumeId_ = "";
      /**
       * <pre>
       * The ID of the source volume to be snapshotted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 1;</code>
       */
      public java.lang.String getSourceVolumeId() {
        java.lang.Object ref = sourceVolumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          sourceVolumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the source volume to be snapshotted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getSourceVolumeIdBytes() {
        java.lang.Object ref = sourceVolumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          sourceVolumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the source volume to be snapshotted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 1;</code>
       */
      public Builder setSourceVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        sourceVolumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the source volume to be snapshotted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 1;</code>
       */
      public Builder clearSourceVolumeId() {
        
        sourceVolumeId_ = getDefaultInstance().getSourceVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the source volume to be snapshotted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 1;</code>
       */
      public Builder setSourceVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        sourceVolumeId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * The suggested name for the snapshot. This field is REQUIRED for
       * idempotency.
       * </pre>
       *
       * <code>string name = 2;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The suggested name for the snapshot. This field is REQUIRED for
       * idempotency.
       * </pre>
       *
       * <code>string name = 2;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The suggested name for the snapshot. This field is REQUIRED for
       * idempotency.
       * </pre>
       *
       * <code>string name = 2;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The suggested name for the snapshot. This field is REQUIRED for
       * idempotency.
       * </pre>
       *
       * <code>string name = 2;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The suggested name for the snapshot. This field is REQUIRED for
       * idempotency.
       * </pre>
       *
       * <code>string name = 2;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> createSnapshotSecrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetCreateSnapshotSecrets() {
        if (createSnapshotSecrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              CreateSnapshotSecretsDefaultEntryHolder.defaultEntry);
        }
        return createSnapshotSecrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableCreateSnapshotSecrets() {
        onChanged();;
        if (createSnapshotSecrets_ == null) {
          createSnapshotSecrets_ = com.google.protobuf.MapField.newMapField(
              CreateSnapshotSecretsDefaultEntryHolder.defaultEntry);
        }
        if (!createSnapshotSecrets_.isMutable()) {
          createSnapshotSecrets_ = createSnapshotSecrets_.copy();
        }
        return createSnapshotSecrets_;
      }

      public int getCreateSnapshotSecretsCount() {
        return internalGetCreateSnapshotSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; create_snapshot_secrets = 3;</code>
       */

      public boolean containsCreateSnapshotSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetCreateSnapshotSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getCreateSnapshotSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getCreateSnapshotSecrets() {
        return getCreateSnapshotSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; create_snapshot_secrets = 3;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getCreateSnapshotSecretsMap() {
        return internalGetCreateSnapshotSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; create_snapshot_secrets = 3;</code>
       */

      public java.lang.String getCreateSnapshotSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetCreateSnapshotSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; create_snapshot_secrets = 3;</code>
       */

      public java.lang.String getCreateSnapshotSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetCreateSnapshotSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearCreateSnapshotSecrets() {
        internalGetMutableCreateSnapshotSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; create_snapshot_secrets = 3;</code>
       */

      public Builder removeCreateSnapshotSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableCreateSnapshotSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableCreateSnapshotSecrets() {
        return internalGetMutableCreateSnapshotSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; create_snapshot_secrets = 3;</code>
       */
      public Builder putCreateSnapshotSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableCreateSnapshotSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot creation request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; create_snapshot_secrets = 3;</code>
       */

      public Builder putAllCreateSnapshotSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableCreateSnapshotSecrets().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> parameters_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetParameters() {
        if (parameters_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        return parameters_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableParameters() {
        onChanged();;
        if (parameters_ == null) {
          parameters_ = com.google.protobuf.MapField.newMapField(
              ParametersDefaultEntryHolder.defaultEntry);
        }
        if (!parameters_.isMutable()) {
          parameters_ = parameters_.copy();
        }
        return parameters_;
      }

      public int getParametersCount() {
        return internalGetParameters().getMap().size();
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * Use cases for opaque parameters:
       * - Specify a policy to automatically clean up the snapshot.
       * - Specify an expiration date for the snapshot.
       * - Specify whether the snapshot is readonly or read/write.
       * - Specify if the snapshot should be replicated to some place.
       * - Specify primary or secondary for replication systems that
       *   support snapshotting only on primary.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public boolean containsParameters(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetParameters().getMap().containsKey(key);
      }
      /**
       * Use {@link #getParametersMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getParameters() {
        return getParametersMap();
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * Use cases for opaque parameters:
       * - Specify a policy to automatically clean up the snapshot.
       * - Specify an expiration date for the snapshot.
       * - Specify whether the snapshot is readonly or read/write.
       * - Specify if the snapshot should be replicated to some place.
       * - Specify primary or secondary for replication systems that
       *   support snapshotting only on primary.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getParametersMap() {
        return internalGetParameters().getMap();
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * Use cases for opaque parameters:
       * - Specify a policy to automatically clean up the snapshot.
       * - Specify an expiration date for the snapshot.
       * - Specify whether the snapshot is readonly or read/write.
       * - Specify if the snapshot should be replicated to some place.
       * - Specify primary or secondary for replication systems that
       *   support snapshotting only on primary.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public java.lang.String getParametersOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * Use cases for opaque parameters:
       * - Specify a policy to automatically clean up the snapshot.
       * - Specify an expiration date for the snapshot.
       * - Specify whether the snapshot is readonly or read/write.
       * - Specify if the snapshot should be replicated to some place.
       * - Specify primary or secondary for replication systems that
       *   support snapshotting only on primary.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public java.lang.String getParametersOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetParameters().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearParameters() {
        internalGetMutableParameters().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * Use cases for opaque parameters:
       * - Specify a policy to automatically clean up the snapshot.
       * - Specify an expiration date for the snapshot.
       * - Specify whether the snapshot is readonly or read/write.
       * - Specify if the snapshot should be replicated to some place.
       * - Specify primary or secondary for replication systems that
       *   support snapshotting only on primary.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public Builder removeParameters(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableParameters().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableParameters() {
        return internalGetMutableParameters().getMutableMap();
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * Use cases for opaque parameters:
       * - Specify a policy to automatically clean up the snapshot.
       * - Specify an expiration date for the snapshot.
       * - Specify whether the snapshot is readonly or read/write.
       * - Specify if the snapshot should be replicated to some place.
       * - Specify primary or secondary for replication systems that
       *   support snapshotting only on primary.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */
      public Builder putParameters(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableParameters().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Plugin specific parameters passed in as opaque key-value pairs.
       * This field is OPTIONAL. The Plugin is responsible for parsing and
       * validating these parameters. COs will treat these as opaque.
       * Use cases for opaque parameters:
       * - Specify a policy to automatically clean up the snapshot.
       * - Specify an expiration date for the snapshot.
       * - Specify whether the snapshot is readonly or read/write.
       * - Specify if the snapshot should be replicated to some place.
       * - Specify primary or secondary for replication systems that
       *   support snapshotting only on primary.
       * </pre>
       *
       * <code>map&lt;string, string&gt; parameters = 4;</code>
       */

      public Builder putAllParameters(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableParameters().getMutableMap()
            .putAll(values);
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.CreateSnapshotRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.CreateSnapshotRequest)
    private static final csi.v0.Csi.CreateSnapshotRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.CreateSnapshotRequest();
    }

    public static csi.v0.Csi.CreateSnapshotRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CreateSnapshotRequest>
        PARSER = new com.google.protobuf.AbstractParser<CreateSnapshotRequest>() {
      @java.lang.Override
      public CreateSnapshotRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CreateSnapshotRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CreateSnapshotRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CreateSnapshotRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.CreateSnapshotRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CreateSnapshotResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.CreateSnapshotResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Contains all attributes of the newly created snapshot that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the snapshot. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v0.Snapshot snapshot = 1;</code>
     */
    boolean hasSnapshot();
    /**
     * <pre>
     * Contains all attributes of the newly created snapshot that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the snapshot. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v0.Snapshot snapshot = 1;</code>
     */
    csi.v0.Csi.Snapshot getSnapshot();
    /**
     * <pre>
     * Contains all attributes of the newly created snapshot that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the snapshot. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v0.Snapshot snapshot = 1;</code>
     */
    csi.v0.Csi.SnapshotOrBuilder getSnapshotOrBuilder();
  }
  /**
   * Protobuf type {@code csi.v0.CreateSnapshotResponse}
   */
  public  static final class CreateSnapshotResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.CreateSnapshotResponse)
      CreateSnapshotResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CreateSnapshotResponse.newBuilder() to construct.
    private CreateSnapshotResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CreateSnapshotResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CreateSnapshotResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              csi.v0.Csi.Snapshot.Builder subBuilder = null;
              if (snapshot_ != null) {
                subBuilder = snapshot_.toBuilder();
              }
              snapshot_ = input.readMessage(csi.v0.Csi.Snapshot.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(snapshot_);
                snapshot_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_CreateSnapshotResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_CreateSnapshotResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.CreateSnapshotResponse.class, csi.v0.Csi.CreateSnapshotResponse.Builder.class);
    }

    public static final int SNAPSHOT_FIELD_NUMBER = 1;
    private csi.v0.Csi.Snapshot snapshot_;
    /**
     * <pre>
     * Contains all attributes of the newly created snapshot that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the snapshot. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v0.Snapshot snapshot = 1;</code>
     */
    public boolean hasSnapshot() {
      return snapshot_ != null;
    }
    /**
     * <pre>
     * Contains all attributes of the newly created snapshot that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the snapshot. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v0.Snapshot snapshot = 1;</code>
     */
    public csi.v0.Csi.Snapshot getSnapshot() {
      return snapshot_ == null ? csi.v0.Csi.Snapshot.getDefaultInstance() : snapshot_;
    }
    /**
     * <pre>
     * Contains all attributes of the newly created snapshot that are
     * relevant to the CO along with information required by the Plugin
     * to uniquely identify the snapshot. This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v0.Snapshot snapshot = 1;</code>
     */
    public csi.v0.Csi.SnapshotOrBuilder getSnapshotOrBuilder() {
      return getSnapshot();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (snapshot_ != null) {
        output.writeMessage(1, getSnapshot());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (snapshot_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getSnapshot());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.CreateSnapshotResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.CreateSnapshotResponse other = (csi.v0.Csi.CreateSnapshotResponse) obj;

      boolean result = true;
      result = result && (hasSnapshot() == other.hasSnapshot());
      if (hasSnapshot()) {
        result = result && getSnapshot()
            .equals(other.getSnapshot());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSnapshot()) {
        hash = (37 * hash) + SNAPSHOT_FIELD_NUMBER;
        hash = (53 * hash) + getSnapshot().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.CreateSnapshotResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.CreateSnapshotResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.CreateSnapshotResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.CreateSnapshotResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.CreateSnapshotResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.CreateSnapshotResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.CreateSnapshotResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.CreateSnapshotResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.CreateSnapshotResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.CreateSnapshotResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.CreateSnapshotResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.CreateSnapshotResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.CreateSnapshotResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.CreateSnapshotResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.CreateSnapshotResponse)
        csi.v0.Csi.CreateSnapshotResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_CreateSnapshotResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_CreateSnapshotResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.CreateSnapshotResponse.class, csi.v0.Csi.CreateSnapshotResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.CreateSnapshotResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (snapshotBuilder_ == null) {
          snapshot_ = null;
        } else {
          snapshot_ = null;
          snapshotBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_CreateSnapshotResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.CreateSnapshotResponse getDefaultInstanceForType() {
        return csi.v0.Csi.CreateSnapshotResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.CreateSnapshotResponse build() {
        csi.v0.Csi.CreateSnapshotResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.CreateSnapshotResponse buildPartial() {
        csi.v0.Csi.CreateSnapshotResponse result = new csi.v0.Csi.CreateSnapshotResponse(this);
        if (snapshotBuilder_ == null) {
          result.snapshot_ = snapshot_;
        } else {
          result.snapshot_ = snapshotBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.CreateSnapshotResponse) {
          return mergeFrom((csi.v0.Csi.CreateSnapshotResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.CreateSnapshotResponse other) {
        if (other == csi.v0.Csi.CreateSnapshotResponse.getDefaultInstance()) return this;
        if (other.hasSnapshot()) {
          mergeSnapshot(other.getSnapshot());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.CreateSnapshotResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.CreateSnapshotResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private csi.v0.Csi.Snapshot snapshot_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.Snapshot, csi.v0.Csi.Snapshot.Builder, csi.v0.Csi.SnapshotOrBuilder> snapshotBuilder_;
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Snapshot snapshot = 1;</code>
       */
      public boolean hasSnapshot() {
        return snapshotBuilder_ != null || snapshot_ != null;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Snapshot snapshot = 1;</code>
       */
      public csi.v0.Csi.Snapshot getSnapshot() {
        if (snapshotBuilder_ == null) {
          return snapshot_ == null ? csi.v0.Csi.Snapshot.getDefaultInstance() : snapshot_;
        } else {
          return snapshotBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Snapshot snapshot = 1;</code>
       */
      public Builder setSnapshot(csi.v0.Csi.Snapshot value) {
        if (snapshotBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          snapshot_ = value;
          onChanged();
        } else {
          snapshotBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Snapshot snapshot = 1;</code>
       */
      public Builder setSnapshot(
          csi.v0.Csi.Snapshot.Builder builderForValue) {
        if (snapshotBuilder_ == null) {
          snapshot_ = builderForValue.build();
          onChanged();
        } else {
          snapshotBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Snapshot snapshot = 1;</code>
       */
      public Builder mergeSnapshot(csi.v0.Csi.Snapshot value) {
        if (snapshotBuilder_ == null) {
          if (snapshot_ != null) {
            snapshot_ =
              csi.v0.Csi.Snapshot.newBuilder(snapshot_).mergeFrom(value).buildPartial();
          } else {
            snapshot_ = value;
          }
          onChanged();
        } else {
          snapshotBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Snapshot snapshot = 1;</code>
       */
      public Builder clearSnapshot() {
        if (snapshotBuilder_ == null) {
          snapshot_ = null;
          onChanged();
        } else {
          snapshot_ = null;
          snapshotBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Snapshot snapshot = 1;</code>
       */
      public csi.v0.Csi.Snapshot.Builder getSnapshotBuilder() {
        
        onChanged();
        return getSnapshotFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Snapshot snapshot = 1;</code>
       */
      public csi.v0.Csi.SnapshotOrBuilder getSnapshotOrBuilder() {
        if (snapshotBuilder_ != null) {
          return snapshotBuilder_.getMessageOrBuilder();
        } else {
          return snapshot_ == null ?
              csi.v0.Csi.Snapshot.getDefaultInstance() : snapshot_;
        }
      }
      /**
       * <pre>
       * Contains all attributes of the newly created snapshot that are
       * relevant to the CO along with information required by the Plugin
       * to uniquely identify the snapshot. This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.Snapshot snapshot = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.Snapshot, csi.v0.Csi.Snapshot.Builder, csi.v0.Csi.SnapshotOrBuilder> 
          getSnapshotFieldBuilder() {
        if (snapshotBuilder_ == null) {
          snapshotBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.Snapshot, csi.v0.Csi.Snapshot.Builder, csi.v0.Csi.SnapshotOrBuilder>(
                  getSnapshot(),
                  getParentForChildren(),
                  isClean());
          snapshot_ = null;
        }
        return snapshotBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.CreateSnapshotResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.CreateSnapshotResponse)
    private static final csi.v0.Csi.CreateSnapshotResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.CreateSnapshotResponse();
    }

    public static csi.v0.Csi.CreateSnapshotResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CreateSnapshotResponse>
        PARSER = new com.google.protobuf.AbstractParser<CreateSnapshotResponse>() {
      @java.lang.Override
      public CreateSnapshotResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CreateSnapshotResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CreateSnapshotResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CreateSnapshotResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.CreateSnapshotResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SnapshotOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.Snapshot)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This is the complete size of the snapshot in bytes. The purpose of
     * this field is to give CO guidance on how much space is needed to
     * create a volume from this snapshot. The size of the volume MUST NOT
     * be less than the size of the source snapshot. This field is
     * OPTIONAL. If this field is not set, it indicates that this size is
     * unknown. The value of this field MUST NOT be negative and a size of
     * zero means it is unspecified.
     * </pre>
     *
     * <code>int64 size_bytes = 1;</code>
     */
    long getSizeBytes();

    /**
     * <pre>
     * Uniquely identifies a snapshot and is generated by the plugin. It
     * will not change over time. This field is REQUIRED. The identity
     * information will be used by the CO in subsequent calls to refer to
     * the provisioned snapshot.
     * </pre>
     *
     * <code>string id = 2;</code>
     */
    java.lang.String getId();
    /**
     * <pre>
     * Uniquely identifies a snapshot and is generated by the plugin. It
     * will not change over time. This field is REQUIRED. The identity
     * information will be used by the CO in subsequent calls to refer to
     * the provisioned snapshot.
     * </pre>
     *
     * <code>string id = 2;</code>
     */
    com.google.protobuf.ByteString
        getIdBytes();

    /**
     * <pre>
     * Identity information for the source volume. Note that creating a
     * snapshot from a snapshot is not supported here so the source has to
     * be a volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string source_volume_id = 3;</code>
     */
    java.lang.String getSourceVolumeId();
    /**
     * <pre>
     * Identity information for the source volume. Note that creating a
     * snapshot from a snapshot is not supported here so the source has to
     * be a volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string source_volume_id = 3;</code>
     */
    com.google.protobuf.ByteString
        getSourceVolumeIdBytes();

    /**
     * <pre>
     * Timestamp when the point-in-time snapshot is taken on the storage
     * system. The format of this field should be a Unix nanoseconds time
     * encoded as an int64. On Unix, the command `date +%s%N` returns the
     * current time in nanoseconds since 1970-01-01 00:00:00 UTC. This
     * field is REQUIRED.
     * </pre>
     *
     * <code>int64 created_at = 4;</code>
     */
    long getCreatedAt();

    /**
     * <pre>
     * The status of a snapshot.
     * </pre>
     *
     * <code>.csi.v0.SnapshotStatus status = 5;</code>
     */
    boolean hasStatus();
    /**
     * <pre>
     * The status of a snapshot.
     * </pre>
     *
     * <code>.csi.v0.SnapshotStatus status = 5;</code>
     */
    csi.v0.Csi.SnapshotStatus getStatus();
    /**
     * <pre>
     * The status of a snapshot.
     * </pre>
     *
     * <code>.csi.v0.SnapshotStatus status = 5;</code>
     */
    csi.v0.Csi.SnapshotStatusOrBuilder getStatusOrBuilder();
  }
  /**
   * <pre>
   * The information about a provisioned snapshot.
   * </pre>
   *
   * Protobuf type {@code csi.v0.Snapshot}
   */
  public  static final class Snapshot extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.Snapshot)
      SnapshotOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Snapshot.newBuilder() to construct.
    private Snapshot(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Snapshot() {
      sizeBytes_ = 0L;
      id_ = "";
      sourceVolumeId_ = "";
      createdAt_ = 0L;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Snapshot(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {

              sizeBytes_ = input.readInt64();
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              id_ = s;
              break;
            }
            case 26: {
              java.lang.String s = input.readStringRequireUtf8();

              sourceVolumeId_ = s;
              break;
            }
            case 32: {

              createdAt_ = input.readInt64();
              break;
            }
            case 42: {
              csi.v0.Csi.SnapshotStatus.Builder subBuilder = null;
              if (status_ != null) {
                subBuilder = status_.toBuilder();
              }
              status_ = input.readMessage(csi.v0.Csi.SnapshotStatus.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(status_);
                status_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_Snapshot_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_Snapshot_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.Snapshot.class, csi.v0.Csi.Snapshot.Builder.class);
    }

    public static final int SIZE_BYTES_FIELD_NUMBER = 1;
    private long sizeBytes_;
    /**
     * <pre>
     * This is the complete size of the snapshot in bytes. The purpose of
     * this field is to give CO guidance on how much space is needed to
     * create a volume from this snapshot. The size of the volume MUST NOT
     * be less than the size of the source snapshot. This field is
     * OPTIONAL. If this field is not set, it indicates that this size is
     * unknown. The value of this field MUST NOT be negative and a size of
     * zero means it is unspecified.
     * </pre>
     *
     * <code>int64 size_bytes = 1;</code>
     */
    public long getSizeBytes() {
      return sizeBytes_;
    }

    public static final int ID_FIELD_NUMBER = 2;
    private volatile java.lang.Object id_;
    /**
     * <pre>
     * Uniquely identifies a snapshot and is generated by the plugin. It
     * will not change over time. This field is REQUIRED. The identity
     * information will be used by the CO in subsequent calls to refer to
     * the provisioned snapshot.
     * </pre>
     *
     * <code>string id = 2;</code>
     */
    public java.lang.String getId() {
      java.lang.Object ref = id_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        id_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Uniquely identifies a snapshot and is generated by the plugin. It
     * will not change over time. This field is REQUIRED. The identity
     * information will be used by the CO in subsequent calls to refer to
     * the provisioned snapshot.
     * </pre>
     *
     * <code>string id = 2;</code>
     */
    public com.google.protobuf.ByteString
        getIdBytes() {
      java.lang.Object ref = id_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        id_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SOURCE_VOLUME_ID_FIELD_NUMBER = 3;
    private volatile java.lang.Object sourceVolumeId_;
    /**
     * <pre>
     * Identity information for the source volume. Note that creating a
     * snapshot from a snapshot is not supported here so the source has to
     * be a volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string source_volume_id = 3;</code>
     */
    public java.lang.String getSourceVolumeId() {
      java.lang.Object ref = sourceVolumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        sourceVolumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identity information for the source volume. Note that creating a
     * snapshot from a snapshot is not supported here so the source has to
     * be a volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string source_volume_id = 3;</code>
     */
    public com.google.protobuf.ByteString
        getSourceVolumeIdBytes() {
      java.lang.Object ref = sourceVolumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        sourceVolumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CREATED_AT_FIELD_NUMBER = 4;
    private long createdAt_;
    /**
     * <pre>
     * Timestamp when the point-in-time snapshot is taken on the storage
     * system. The format of this field should be a Unix nanoseconds time
     * encoded as an int64. On Unix, the command `date +%s%N` returns the
     * current time in nanoseconds since 1970-01-01 00:00:00 UTC. This
     * field is REQUIRED.
     * </pre>
     *
     * <code>int64 created_at = 4;</code>
     */
    public long getCreatedAt() {
      return createdAt_;
    }

    public static final int STATUS_FIELD_NUMBER = 5;
    private csi.v0.Csi.SnapshotStatus status_;
    /**
     * <pre>
     * The status of a snapshot.
     * </pre>
     *
     * <code>.csi.v0.SnapshotStatus status = 5;</code>
     */
    public boolean hasStatus() {
      return status_ != null;
    }
    /**
     * <pre>
     * The status of a snapshot.
     * </pre>
     *
     * <code>.csi.v0.SnapshotStatus status = 5;</code>
     */
    public csi.v0.Csi.SnapshotStatus getStatus() {
      return status_ == null ? csi.v0.Csi.SnapshotStatus.getDefaultInstance() : status_;
    }
    /**
     * <pre>
     * The status of a snapshot.
     * </pre>
     *
     * <code>.csi.v0.SnapshotStatus status = 5;</code>
     */
    public csi.v0.Csi.SnapshotStatusOrBuilder getStatusOrBuilder() {
      return getStatus();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (sizeBytes_ != 0L) {
        output.writeInt64(1, sizeBytes_);
      }
      if (!getIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, id_);
      }
      if (!getSourceVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, sourceVolumeId_);
      }
      if (createdAt_ != 0L) {
        output.writeInt64(4, createdAt_);
      }
      if (status_ != null) {
        output.writeMessage(5, getStatus());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (sizeBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, sizeBytes_);
      }
      if (!getIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, id_);
      }
      if (!getSourceVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, sourceVolumeId_);
      }
      if (createdAt_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(4, createdAt_);
      }
      if (status_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getStatus());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.Snapshot)) {
        return super.equals(obj);
      }
      csi.v0.Csi.Snapshot other = (csi.v0.Csi.Snapshot) obj;

      boolean result = true;
      result = result && (getSizeBytes()
          == other.getSizeBytes());
      result = result && getId()
          .equals(other.getId());
      result = result && getSourceVolumeId()
          .equals(other.getSourceVolumeId());
      result = result && (getCreatedAt()
          == other.getCreatedAt());
      result = result && (hasStatus() == other.hasStatus());
      if (hasStatus()) {
        result = result && getStatus()
            .equals(other.getStatus());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SIZE_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getSizeBytes());
      hash = (37 * hash) + ID_FIELD_NUMBER;
      hash = (53 * hash) + getId().hashCode();
      hash = (37 * hash) + SOURCE_VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSourceVolumeId().hashCode();
      hash = (37 * hash) + CREATED_AT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getCreatedAt());
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.Snapshot parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.Snapshot parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.Snapshot parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.Snapshot parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.Snapshot parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.Snapshot parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.Snapshot parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.Snapshot parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.Snapshot parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.Snapshot parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.Snapshot parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.Snapshot parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.Snapshot prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The information about a provisioned snapshot.
     * </pre>
     *
     * Protobuf type {@code csi.v0.Snapshot}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.Snapshot)
        csi.v0.Csi.SnapshotOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_Snapshot_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_Snapshot_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.Snapshot.class, csi.v0.Csi.Snapshot.Builder.class);
      }

      // Construct using csi.v0.Csi.Snapshot.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        sizeBytes_ = 0L;

        id_ = "";

        sourceVolumeId_ = "";

        createdAt_ = 0L;

        if (statusBuilder_ == null) {
          status_ = null;
        } else {
          status_ = null;
          statusBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_Snapshot_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.Snapshot getDefaultInstanceForType() {
        return csi.v0.Csi.Snapshot.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.Snapshot build() {
        csi.v0.Csi.Snapshot result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.Snapshot buildPartial() {
        csi.v0.Csi.Snapshot result = new csi.v0.Csi.Snapshot(this);
        result.sizeBytes_ = sizeBytes_;
        result.id_ = id_;
        result.sourceVolumeId_ = sourceVolumeId_;
        result.createdAt_ = createdAt_;
        if (statusBuilder_ == null) {
          result.status_ = status_;
        } else {
          result.status_ = statusBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.Snapshot) {
          return mergeFrom((csi.v0.Csi.Snapshot)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.Snapshot other) {
        if (other == csi.v0.Csi.Snapshot.getDefaultInstance()) return this;
        if (other.getSizeBytes() != 0L) {
          setSizeBytes(other.getSizeBytes());
        }
        if (!other.getId().isEmpty()) {
          id_ = other.id_;
          onChanged();
        }
        if (!other.getSourceVolumeId().isEmpty()) {
          sourceVolumeId_ = other.sourceVolumeId_;
          onChanged();
        }
        if (other.getCreatedAt() != 0L) {
          setCreatedAt(other.getCreatedAt());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.Snapshot parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.Snapshot) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private long sizeBytes_ ;
      /**
       * <pre>
       * This is the complete size of the snapshot in bytes. The purpose of
       * this field is to give CO guidance on how much space is needed to
       * create a volume from this snapshot. The size of the volume MUST NOT
       * be less than the size of the source snapshot. This field is
       * OPTIONAL. If this field is not set, it indicates that this size is
       * unknown. The value of this field MUST NOT be negative and a size of
       * zero means it is unspecified.
       * </pre>
       *
       * <code>int64 size_bytes = 1;</code>
       */
      public long getSizeBytes() {
        return sizeBytes_;
      }
      /**
       * <pre>
       * This is the complete size of the snapshot in bytes. The purpose of
       * this field is to give CO guidance on how much space is needed to
       * create a volume from this snapshot. The size of the volume MUST NOT
       * be less than the size of the source snapshot. This field is
       * OPTIONAL. If this field is not set, it indicates that this size is
       * unknown. The value of this field MUST NOT be negative and a size of
       * zero means it is unspecified.
       * </pre>
       *
       * <code>int64 size_bytes = 1;</code>
       */
      public Builder setSizeBytes(long value) {
        
        sizeBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This is the complete size of the snapshot in bytes. The purpose of
       * this field is to give CO guidance on how much space is needed to
       * create a volume from this snapshot. The size of the volume MUST NOT
       * be less than the size of the source snapshot. This field is
       * OPTIONAL. If this field is not set, it indicates that this size is
       * unknown. The value of this field MUST NOT be negative and a size of
       * zero means it is unspecified.
       * </pre>
       *
       * <code>int64 size_bytes = 1;</code>
       */
      public Builder clearSizeBytes() {
        
        sizeBytes_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object id_ = "";
      /**
       * <pre>
       * Uniquely identifies a snapshot and is generated by the plugin. It
       * will not change over time. This field is REQUIRED. The identity
       * information will be used by the CO in subsequent calls to refer to
       * the provisioned snapshot.
       * </pre>
       *
       * <code>string id = 2;</code>
       */
      public java.lang.String getId() {
        java.lang.Object ref = id_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          id_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Uniquely identifies a snapshot and is generated by the plugin. It
       * will not change over time. This field is REQUIRED. The identity
       * information will be used by the CO in subsequent calls to refer to
       * the provisioned snapshot.
       * </pre>
       *
       * <code>string id = 2;</code>
       */
      public com.google.protobuf.ByteString
          getIdBytes() {
        java.lang.Object ref = id_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          id_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Uniquely identifies a snapshot and is generated by the plugin. It
       * will not change over time. This field is REQUIRED. The identity
       * information will be used by the CO in subsequent calls to refer to
       * the provisioned snapshot.
       * </pre>
       *
       * <code>string id = 2;</code>
       */
      public Builder setId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        id_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Uniquely identifies a snapshot and is generated by the plugin. It
       * will not change over time. This field is REQUIRED. The identity
       * information will be used by the CO in subsequent calls to refer to
       * the provisioned snapshot.
       * </pre>
       *
       * <code>string id = 2;</code>
       */
      public Builder clearId() {
        
        id_ = getDefaultInstance().getId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Uniquely identifies a snapshot and is generated by the plugin. It
       * will not change over time. This field is REQUIRED. The identity
       * information will be used by the CO in subsequent calls to refer to
       * the provisioned snapshot.
       * </pre>
       *
       * <code>string id = 2;</code>
       */
      public Builder setIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        id_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object sourceVolumeId_ = "";
      /**
       * <pre>
       * Identity information for the source volume. Note that creating a
       * snapshot from a snapshot is not supported here so the source has to
       * be a volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public java.lang.String getSourceVolumeId() {
        java.lang.Object ref = sourceVolumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          sourceVolumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identity information for the source volume. Note that creating a
       * snapshot from a snapshot is not supported here so the source has to
       * be a volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public com.google.protobuf.ByteString
          getSourceVolumeIdBytes() {
        java.lang.Object ref = sourceVolumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          sourceVolumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identity information for the source volume. Note that creating a
       * snapshot from a snapshot is not supported here so the source has to
       * be a volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public Builder setSourceVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        sourceVolumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identity information for the source volume. Note that creating a
       * snapshot from a snapshot is not supported here so the source has to
       * be a volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public Builder clearSourceVolumeId() {
        
        sourceVolumeId_ = getDefaultInstance().getSourceVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identity information for the source volume. Note that creating a
       * snapshot from a snapshot is not supported here so the source has to
       * be a volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public Builder setSourceVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        sourceVolumeId_ = value;
        onChanged();
        return this;
      }

      private long createdAt_ ;
      /**
       * <pre>
       * Timestamp when the point-in-time snapshot is taken on the storage
       * system. The format of this field should be a Unix nanoseconds time
       * encoded as an int64. On Unix, the command `date +%s%N` returns the
       * current time in nanoseconds since 1970-01-01 00:00:00 UTC. This
       * field is REQUIRED.
       * </pre>
       *
       * <code>int64 created_at = 4;</code>
       */
      public long getCreatedAt() {
        return createdAt_;
      }
      /**
       * <pre>
       * Timestamp when the point-in-time snapshot is taken on the storage
       * system. The format of this field should be a Unix nanoseconds time
       * encoded as an int64. On Unix, the command `date +%s%N` returns the
       * current time in nanoseconds since 1970-01-01 00:00:00 UTC. This
       * field is REQUIRED.
       * </pre>
       *
       * <code>int64 created_at = 4;</code>
       */
      public Builder setCreatedAt(long value) {
        
        createdAt_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Timestamp when the point-in-time snapshot is taken on the storage
       * system. The format of this field should be a Unix nanoseconds time
       * encoded as an int64. On Unix, the command `date +%s%N` returns the
       * current time in nanoseconds since 1970-01-01 00:00:00 UTC. This
       * field is REQUIRED.
       * </pre>
       *
       * <code>int64 created_at = 4;</code>
       */
      public Builder clearCreatedAt() {
        
        createdAt_ = 0L;
        onChanged();
        return this;
      }

      private csi.v0.Csi.SnapshotStatus status_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.SnapshotStatus, csi.v0.Csi.SnapshotStatus.Builder, csi.v0.Csi.SnapshotStatusOrBuilder> statusBuilder_;
      /**
       * <pre>
       * The status of a snapshot.
       * </pre>
       *
       * <code>.csi.v0.SnapshotStatus status = 5;</code>
       */
      public boolean hasStatus() {
        return statusBuilder_ != null || status_ != null;
      }
      /**
       * <pre>
       * The status of a snapshot.
       * </pre>
       *
       * <code>.csi.v0.SnapshotStatus status = 5;</code>
       */
      public csi.v0.Csi.SnapshotStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null ? csi.v0.Csi.SnapshotStatus.getDefaultInstance() : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The status of a snapshot.
       * </pre>
       *
       * <code>.csi.v0.SnapshotStatus status = 5;</code>
       */
      public Builder setStatus(csi.v0.Csi.SnapshotStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
          onChanged();
        } else {
          statusBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The status of a snapshot.
       * </pre>
       *
       * <code>.csi.v0.SnapshotStatus status = 5;</code>
       */
      public Builder setStatus(
          csi.v0.Csi.SnapshotStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
          onChanged();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The status of a snapshot.
       * </pre>
       *
       * <code>.csi.v0.SnapshotStatus status = 5;</code>
       */
      public Builder mergeStatus(csi.v0.Csi.SnapshotStatus value) {
        if (statusBuilder_ == null) {
          if (status_ != null) {
            status_ =
              csi.v0.Csi.SnapshotStatus.newBuilder(status_).mergeFrom(value).buildPartial();
          } else {
            status_ = value;
          }
          onChanged();
        } else {
          statusBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The status of a snapshot.
       * </pre>
       *
       * <code>.csi.v0.SnapshotStatus status = 5;</code>
       */
      public Builder clearStatus() {
        if (statusBuilder_ == null) {
          status_ = null;
          onChanged();
        } else {
          status_ = null;
          statusBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The status of a snapshot.
       * </pre>
       *
       * <code>.csi.v0.SnapshotStatus status = 5;</code>
       */
      public csi.v0.Csi.SnapshotStatus.Builder getStatusBuilder() {
        
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The status of a snapshot.
       * </pre>
       *
       * <code>.csi.v0.SnapshotStatus status = 5;</code>
       */
      public csi.v0.Csi.SnapshotStatusOrBuilder getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null ?
              csi.v0.Csi.SnapshotStatus.getDefaultInstance() : status_;
        }
      }
      /**
       * <pre>
       * The status of a snapshot.
       * </pre>
       *
       * <code>.csi.v0.SnapshotStatus status = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.SnapshotStatus, csi.v0.Csi.SnapshotStatus.Builder, csi.v0.Csi.SnapshotStatusOrBuilder> 
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.SnapshotStatus, csi.v0.Csi.SnapshotStatus.Builder, csi.v0.Csi.SnapshotStatusOrBuilder>(
                  getStatus(),
                  getParentForChildren(),
                  isClean());
          status_ = null;
        }
        return statusBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.Snapshot)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.Snapshot)
    private static final csi.v0.Csi.Snapshot DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.Snapshot();
    }

    public static csi.v0.Csi.Snapshot getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Snapshot>
        PARSER = new com.google.protobuf.AbstractParser<Snapshot>() {
      @java.lang.Override
      public Snapshot parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Snapshot(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Snapshot> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Snapshot> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.Snapshot getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SnapshotStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.SnapshotStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v0.SnapshotStatus.Type type = 1;</code>
     */
    int getTypeValue();
    /**
     * <pre>
     * This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v0.SnapshotStatus.Type type = 1;</code>
     */
    csi.v0.Csi.SnapshotStatus.Type getType();

    /**
     * <pre>
     * Additional information to describe why a snapshot ended up in the
     * `ERROR_UPLOADING` status. This field is OPTIONAL.
     * </pre>
     *
     * <code>string details = 2;</code>
     */
    java.lang.String getDetails();
    /**
     * <pre>
     * Additional information to describe why a snapshot ended up in the
     * `ERROR_UPLOADING` status. This field is OPTIONAL.
     * </pre>
     *
     * <code>string details = 2;</code>
     */
    com.google.protobuf.ByteString
        getDetailsBytes();
  }
  /**
   * <pre>
   * The status of a snapshot.
   * </pre>
   *
   * Protobuf type {@code csi.v0.SnapshotStatus}
   */
  public  static final class SnapshotStatus extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.SnapshotStatus)
      SnapshotStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SnapshotStatus.newBuilder() to construct.
    private SnapshotStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SnapshotStatus() {
      type_ = 0;
      details_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private SnapshotStatus(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              int rawValue = input.readEnum();

              type_ = rawValue;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              details_ = s;
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_SnapshotStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_SnapshotStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.SnapshotStatus.class, csi.v0.Csi.SnapshotStatus.Builder.class);
    }

    /**
     * Protobuf enum {@code csi.v0.SnapshotStatus.Type}
     */
    public enum Type
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>UNKNOWN = 0;</code>
       */
      UNKNOWN(0),
      /**
       * <pre>
       * A snapshot is ready for use.
       * </pre>
       *
       * <code>READY = 1;</code>
       */
      READY(1),
      /**
       * <pre>
       * A snapshot is cut and is now being uploaded.
       * Some cloud providers and storage systems uploads the snapshot
       * to the cloud after the snapshot is cut. During this phase,
       * `thaw` can be done so the application can be running again if
       * `freeze` was done before taking the snapshot.
       * </pre>
       *
       * <code>UPLOADING = 2;</code>
       */
      UPLOADING(2),
      /**
       * <pre>
       * An error occurred during the snapshot uploading process.
       * This error status is specific for uploading because
       * `CreateSnaphot` is a blocking call before the snapshot is
       * cut and therefore it SHOULD NOT come back with an error
       * status when an error occurs. Instead a gRPC error code SHALL
       * be returned by `CreateSnapshot` when an error occurs before
       * a snapshot is cut.
       * </pre>
       *
       * <code>ERROR_UPLOADING = 3;</code>
       */
      ERROR_UPLOADING(3),
      UNRECOGNIZED(-1),
      ;

      /**
       * <code>UNKNOWN = 0;</code>
       */
      public static final int UNKNOWN_VALUE = 0;
      /**
       * <pre>
       * A snapshot is ready for use.
       * </pre>
       *
       * <code>READY = 1;</code>
       */
      public static final int READY_VALUE = 1;
      /**
       * <pre>
       * A snapshot is cut and is now being uploaded.
       * Some cloud providers and storage systems uploads the snapshot
       * to the cloud after the snapshot is cut. During this phase,
       * `thaw` can be done so the application can be running again if
       * `freeze` was done before taking the snapshot.
       * </pre>
       *
       * <code>UPLOADING = 2;</code>
       */
      public static final int UPLOADING_VALUE = 2;
      /**
       * <pre>
       * An error occurred during the snapshot uploading process.
       * This error status is specific for uploading because
       * `CreateSnaphot` is a blocking call before the snapshot is
       * cut and therefore it SHOULD NOT come back with an error
       * status when an error occurs. Instead a gRPC error code SHALL
       * be returned by `CreateSnapshot` when an error occurs before
       * a snapshot is cut.
       * </pre>
       *
       * <code>ERROR_UPLOADING = 3;</code>
       */
      public static final int ERROR_UPLOADING_VALUE = 3;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Type valueOf(int value) {
        return forNumber(value);
      }

      public static Type forNumber(int value) {
        switch (value) {
          case 0: return UNKNOWN;
          case 1: return READY;
          case 2: return UPLOADING;
          case 3: return ERROR_UPLOADING;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Type>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Type> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Type>() {
              public Type findValueByNumber(int number) {
                return Type.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return csi.v0.Csi.SnapshotStatus.getDescriptor().getEnumTypes().get(0);
      }

      private static final Type[] VALUES = values();

      public static Type valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private Type(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:csi.v0.SnapshotStatus.Type)
    }

    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;
    /**
     * <pre>
     * This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v0.SnapshotStatus.Type type = 1;</code>
     */
    public int getTypeValue() {
      return type_;
    }
    /**
     * <pre>
     * This field is REQUIRED.
     * </pre>
     *
     * <code>.csi.v0.SnapshotStatus.Type type = 1;</code>
     */
    public csi.v0.Csi.SnapshotStatus.Type getType() {
      @SuppressWarnings("deprecation")
      csi.v0.Csi.SnapshotStatus.Type result = csi.v0.Csi.SnapshotStatus.Type.valueOf(type_);
      return result == null ? csi.v0.Csi.SnapshotStatus.Type.UNRECOGNIZED : result;
    }

    public static final int DETAILS_FIELD_NUMBER = 2;
    private volatile java.lang.Object details_;
    /**
     * <pre>
     * Additional information to describe why a snapshot ended up in the
     * `ERROR_UPLOADING` status. This field is OPTIONAL.
     * </pre>
     *
     * <code>string details = 2;</code>
     */
    public java.lang.String getDetails() {
      java.lang.Object ref = details_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        details_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Additional information to describe why a snapshot ended up in the
     * `ERROR_UPLOADING` status. This field is OPTIONAL.
     * </pre>
     *
     * <code>string details = 2;</code>
     */
    public com.google.protobuf.ByteString
        getDetailsBytes() {
      java.lang.Object ref = details_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        details_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (type_ != csi.v0.Csi.SnapshotStatus.Type.UNKNOWN.getNumber()) {
        output.writeEnum(1, type_);
      }
      if (!getDetailsBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, details_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (type_ != csi.v0.Csi.SnapshotStatus.Type.UNKNOWN.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, type_);
      }
      if (!getDetailsBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, details_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.SnapshotStatus)) {
        return super.equals(obj);
      }
      csi.v0.Csi.SnapshotStatus other = (csi.v0.Csi.SnapshotStatus) obj;

      boolean result = true;
      result = result && type_ == other.type_;
      result = result && getDetails()
          .equals(other.getDetails());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + type_;
      hash = (37 * hash) + DETAILS_FIELD_NUMBER;
      hash = (53 * hash) + getDetails().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.SnapshotStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.SnapshotStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.SnapshotStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.SnapshotStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.SnapshotStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.SnapshotStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.SnapshotStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.SnapshotStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.SnapshotStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.SnapshotStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.SnapshotStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.SnapshotStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.SnapshotStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The status of a snapshot.
     * </pre>
     *
     * Protobuf type {@code csi.v0.SnapshotStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.SnapshotStatus)
        csi.v0.Csi.SnapshotStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_SnapshotStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_SnapshotStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.SnapshotStatus.class, csi.v0.Csi.SnapshotStatus.Builder.class);
      }

      // Construct using csi.v0.Csi.SnapshotStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = 0;

        details_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_SnapshotStatus_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.SnapshotStatus getDefaultInstanceForType() {
        return csi.v0.Csi.SnapshotStatus.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.SnapshotStatus build() {
        csi.v0.Csi.SnapshotStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.SnapshotStatus buildPartial() {
        csi.v0.Csi.SnapshotStatus result = new csi.v0.Csi.SnapshotStatus(this);
        result.type_ = type_;
        result.details_ = details_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.SnapshotStatus) {
          return mergeFrom((csi.v0.Csi.SnapshotStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.SnapshotStatus other) {
        if (other == csi.v0.Csi.SnapshotStatus.getDefaultInstance()) return this;
        if (other.type_ != 0) {
          setTypeValue(other.getTypeValue());
        }
        if (!other.getDetails().isEmpty()) {
          details_ = other.details_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.SnapshotStatus parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.SnapshotStatus) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int type_ = 0;
      /**
       * <pre>
       * This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.SnapshotStatus.Type type = 1;</code>
       */
      public int getTypeValue() {
        return type_;
      }
      /**
       * <pre>
       * This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.SnapshotStatus.Type type = 1;</code>
       */
      public Builder setTypeValue(int value) {
        type_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.SnapshotStatus.Type type = 1;</code>
       */
      public csi.v0.Csi.SnapshotStatus.Type getType() {
        @SuppressWarnings("deprecation")
        csi.v0.Csi.SnapshotStatus.Type result = csi.v0.Csi.SnapshotStatus.Type.valueOf(type_);
        return result == null ? csi.v0.Csi.SnapshotStatus.Type.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.SnapshotStatus.Type type = 1;</code>
       */
      public Builder setType(csi.v0.Csi.SnapshotStatus.Type value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field is REQUIRED.
       * </pre>
       *
       * <code>.csi.v0.SnapshotStatus.Type type = 1;</code>
       */
      public Builder clearType() {
        
        type_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object details_ = "";
      /**
       * <pre>
       * Additional information to describe why a snapshot ended up in the
       * `ERROR_UPLOADING` status. This field is OPTIONAL.
       * </pre>
       *
       * <code>string details = 2;</code>
       */
      public java.lang.String getDetails() {
        java.lang.Object ref = details_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          details_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Additional information to describe why a snapshot ended up in the
       * `ERROR_UPLOADING` status. This field is OPTIONAL.
       * </pre>
       *
       * <code>string details = 2;</code>
       */
      public com.google.protobuf.ByteString
          getDetailsBytes() {
        java.lang.Object ref = details_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          details_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Additional information to describe why a snapshot ended up in the
       * `ERROR_UPLOADING` status. This field is OPTIONAL.
       * </pre>
       *
       * <code>string details = 2;</code>
       */
      public Builder setDetails(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        details_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Additional information to describe why a snapshot ended up in the
       * `ERROR_UPLOADING` status. This field is OPTIONAL.
       * </pre>
       *
       * <code>string details = 2;</code>
       */
      public Builder clearDetails() {
        
        details_ = getDefaultInstance().getDetails();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Additional information to describe why a snapshot ended up in the
       * `ERROR_UPLOADING` status. This field is OPTIONAL.
       * </pre>
       *
       * <code>string details = 2;</code>
       */
      public Builder setDetailsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        details_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.SnapshotStatus)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.SnapshotStatus)
    private static final csi.v0.Csi.SnapshotStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.SnapshotStatus();
    }

    public static csi.v0.Csi.SnapshotStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SnapshotStatus>
        PARSER = new com.google.protobuf.AbstractParser<SnapshotStatus>() {
      @java.lang.Override
      public SnapshotStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new SnapshotStatus(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<SnapshotStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SnapshotStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.SnapshotStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeleteSnapshotRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.DeleteSnapshotRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the snapshot to be deleted.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string snapshot_id = 1;</code>
     */
    java.lang.String getSnapshotId();
    /**
     * <pre>
     * The ID of the snapshot to be deleted.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string snapshot_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getSnapshotIdBytes();

    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; delete_snapshot_secrets = 2;</code>
     */
    int getDeleteSnapshotSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; delete_snapshot_secrets = 2;</code>
     */
    boolean containsDeleteSnapshotSecrets(
        java.lang.String key);
    /**
     * Use {@link #getDeleteSnapshotSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getDeleteSnapshotSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; delete_snapshot_secrets = 2;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getDeleteSnapshotSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; delete_snapshot_secrets = 2;</code>
     */

    java.lang.String getDeleteSnapshotSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; delete_snapshot_secrets = 2;</code>
     */

    java.lang.String getDeleteSnapshotSecretsOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v0.DeleteSnapshotRequest}
   */
  public  static final class DeleteSnapshotRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.DeleteSnapshotRequest)
      DeleteSnapshotRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DeleteSnapshotRequest.newBuilder() to construct.
    private DeleteSnapshotRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DeleteSnapshotRequest() {
      snapshotId_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DeleteSnapshotRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              snapshotId_ = s;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                deleteSnapshotSecrets_ = com.google.protobuf.MapField.newMapField(
                    DeleteSnapshotSecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000002;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              deleteSnapshotSecrets__ = input.readMessage(
                  DeleteSnapshotSecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              deleteSnapshotSecrets_.getMutableMap().put(
                  deleteSnapshotSecrets__.getKey(), deleteSnapshotSecrets__.getValue());
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_DeleteSnapshotRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetDeleteSnapshotSecrets();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_DeleteSnapshotRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.DeleteSnapshotRequest.class, csi.v0.Csi.DeleteSnapshotRequest.Builder.class);
    }

    private int bitField0_;
    public static final int SNAPSHOT_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object snapshotId_;
    /**
     * <pre>
     * The ID of the snapshot to be deleted.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string snapshot_id = 1;</code>
     */
    public java.lang.String getSnapshotId() {
      java.lang.Object ref = snapshotId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        snapshotId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the snapshot to be deleted.
     * This field is REQUIRED.
     * </pre>
     *
     * <code>string snapshot_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getSnapshotIdBytes() {
      java.lang.Object ref = snapshotId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        snapshotId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DELETE_SNAPSHOT_SECRETS_FIELD_NUMBER = 2;
    private static final class DeleteSnapshotSecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_DeleteSnapshotRequest_DeleteSnapshotSecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> deleteSnapshotSecrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetDeleteSnapshotSecrets() {
      if (deleteSnapshotSecrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            DeleteSnapshotSecretsDefaultEntryHolder.defaultEntry);
      }
      return deleteSnapshotSecrets_;
    }

    public int getDeleteSnapshotSecretsCount() {
      return internalGetDeleteSnapshotSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; delete_snapshot_secrets = 2;</code>
     */

    public boolean containsDeleteSnapshotSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetDeleteSnapshotSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getDeleteSnapshotSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getDeleteSnapshotSecrets() {
      return getDeleteSnapshotSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; delete_snapshot_secrets = 2;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getDeleteSnapshotSecretsMap() {
      return internalGetDeleteSnapshotSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; delete_snapshot_secrets = 2;</code>
     */

    public java.lang.String getDeleteSnapshotSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetDeleteSnapshotSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete snapshot deletion request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; delete_snapshot_secrets = 2;</code>
     */

    public java.lang.String getDeleteSnapshotSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetDeleteSnapshotSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getSnapshotIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, snapshotId_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetDeleteSnapshotSecrets(),
          DeleteSnapshotSecretsDefaultEntryHolder.defaultEntry,
          2);
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getSnapshotIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, snapshotId_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetDeleteSnapshotSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        deleteSnapshotSecrets__ = DeleteSnapshotSecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, deleteSnapshotSecrets__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.DeleteSnapshotRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.DeleteSnapshotRequest other = (csi.v0.Csi.DeleteSnapshotRequest) obj;

      boolean result = true;
      result = result && getSnapshotId()
          .equals(other.getSnapshotId());
      result = result && internalGetDeleteSnapshotSecrets().equals(
          other.internalGetDeleteSnapshotSecrets());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SNAPSHOT_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSnapshotId().hashCode();
      if (!internalGetDeleteSnapshotSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + DELETE_SNAPSHOT_SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetDeleteSnapshotSecrets().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.DeleteSnapshotRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.DeleteSnapshotRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteSnapshotRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.DeleteSnapshotRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteSnapshotRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.DeleteSnapshotRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteSnapshotRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.DeleteSnapshotRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteSnapshotRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.DeleteSnapshotRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteSnapshotRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.DeleteSnapshotRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.DeleteSnapshotRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.DeleteSnapshotRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.DeleteSnapshotRequest)
        csi.v0.Csi.DeleteSnapshotRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_DeleteSnapshotRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetDeleteSnapshotSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutableDeleteSnapshotSecrets();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_DeleteSnapshotRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.DeleteSnapshotRequest.class, csi.v0.Csi.DeleteSnapshotRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.DeleteSnapshotRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        snapshotId_ = "";

        internalGetMutableDeleteSnapshotSecrets().clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_DeleteSnapshotRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.DeleteSnapshotRequest getDefaultInstanceForType() {
        return csi.v0.Csi.DeleteSnapshotRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.DeleteSnapshotRequest build() {
        csi.v0.Csi.DeleteSnapshotRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.DeleteSnapshotRequest buildPartial() {
        csi.v0.Csi.DeleteSnapshotRequest result = new csi.v0.Csi.DeleteSnapshotRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.snapshotId_ = snapshotId_;
        result.deleteSnapshotSecrets_ = internalGetDeleteSnapshotSecrets();
        result.deleteSnapshotSecrets_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.DeleteSnapshotRequest) {
          return mergeFrom((csi.v0.Csi.DeleteSnapshotRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.DeleteSnapshotRequest other) {
        if (other == csi.v0.Csi.DeleteSnapshotRequest.getDefaultInstance()) return this;
        if (!other.getSnapshotId().isEmpty()) {
          snapshotId_ = other.snapshotId_;
          onChanged();
        }
        internalGetMutableDeleteSnapshotSecrets().mergeFrom(
            other.internalGetDeleteSnapshotSecrets());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.DeleteSnapshotRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.DeleteSnapshotRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object snapshotId_ = "";
      /**
       * <pre>
       * The ID of the snapshot to be deleted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string snapshot_id = 1;</code>
       */
      public java.lang.String getSnapshotId() {
        java.lang.Object ref = snapshotId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          snapshotId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the snapshot to be deleted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string snapshot_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getSnapshotIdBytes() {
        java.lang.Object ref = snapshotId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          snapshotId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the snapshot to be deleted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string snapshot_id = 1;</code>
       */
      public Builder setSnapshotId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        snapshotId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the snapshot to be deleted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string snapshot_id = 1;</code>
       */
      public Builder clearSnapshotId() {
        
        snapshotId_ = getDefaultInstance().getSnapshotId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the snapshot to be deleted.
       * This field is REQUIRED.
       * </pre>
       *
       * <code>string snapshot_id = 1;</code>
       */
      public Builder setSnapshotIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        snapshotId_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> deleteSnapshotSecrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetDeleteSnapshotSecrets() {
        if (deleteSnapshotSecrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              DeleteSnapshotSecretsDefaultEntryHolder.defaultEntry);
        }
        return deleteSnapshotSecrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableDeleteSnapshotSecrets() {
        onChanged();;
        if (deleteSnapshotSecrets_ == null) {
          deleteSnapshotSecrets_ = com.google.protobuf.MapField.newMapField(
              DeleteSnapshotSecretsDefaultEntryHolder.defaultEntry);
        }
        if (!deleteSnapshotSecrets_.isMutable()) {
          deleteSnapshotSecrets_ = deleteSnapshotSecrets_.copy();
        }
        return deleteSnapshotSecrets_;
      }

      public int getDeleteSnapshotSecretsCount() {
        return internalGetDeleteSnapshotSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; delete_snapshot_secrets = 2;</code>
       */

      public boolean containsDeleteSnapshotSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetDeleteSnapshotSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getDeleteSnapshotSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getDeleteSnapshotSecrets() {
        return getDeleteSnapshotSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; delete_snapshot_secrets = 2;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getDeleteSnapshotSecretsMap() {
        return internalGetDeleteSnapshotSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; delete_snapshot_secrets = 2;</code>
       */

      public java.lang.String getDeleteSnapshotSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetDeleteSnapshotSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; delete_snapshot_secrets = 2;</code>
       */

      public java.lang.String getDeleteSnapshotSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetDeleteSnapshotSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearDeleteSnapshotSecrets() {
        internalGetMutableDeleteSnapshotSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; delete_snapshot_secrets = 2;</code>
       */

      public Builder removeDeleteSnapshotSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableDeleteSnapshotSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableDeleteSnapshotSecrets() {
        return internalGetMutableDeleteSnapshotSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; delete_snapshot_secrets = 2;</code>
       */
      public Builder putDeleteSnapshotSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableDeleteSnapshotSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete snapshot deletion request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; delete_snapshot_secrets = 2;</code>
       */

      public Builder putAllDeleteSnapshotSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableDeleteSnapshotSecrets().getMutableMap()
            .putAll(values);
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.DeleteSnapshotRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.DeleteSnapshotRequest)
    private static final csi.v0.Csi.DeleteSnapshotRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.DeleteSnapshotRequest();
    }

    public static csi.v0.Csi.DeleteSnapshotRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DeleteSnapshotRequest>
        PARSER = new com.google.protobuf.AbstractParser<DeleteSnapshotRequest>() {
      @java.lang.Override
      public DeleteSnapshotRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new DeleteSnapshotRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DeleteSnapshotRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeleteSnapshotRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.DeleteSnapshotRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeleteSnapshotResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.DeleteSnapshotResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code csi.v0.DeleteSnapshotResponse}
   */
  public  static final class DeleteSnapshotResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.DeleteSnapshotResponse)
      DeleteSnapshotResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DeleteSnapshotResponse.newBuilder() to construct.
    private DeleteSnapshotResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DeleteSnapshotResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DeleteSnapshotResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_DeleteSnapshotResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_DeleteSnapshotResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.DeleteSnapshotResponse.class, csi.v0.Csi.DeleteSnapshotResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.DeleteSnapshotResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.DeleteSnapshotResponse other = (csi.v0.Csi.DeleteSnapshotResponse) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.DeleteSnapshotResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.DeleteSnapshotResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteSnapshotResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.DeleteSnapshotResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteSnapshotResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.DeleteSnapshotResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteSnapshotResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.DeleteSnapshotResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteSnapshotResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.DeleteSnapshotResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.DeleteSnapshotResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.DeleteSnapshotResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.DeleteSnapshotResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.DeleteSnapshotResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.DeleteSnapshotResponse)
        csi.v0.Csi.DeleteSnapshotResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_DeleteSnapshotResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_DeleteSnapshotResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.DeleteSnapshotResponse.class, csi.v0.Csi.DeleteSnapshotResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.DeleteSnapshotResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_DeleteSnapshotResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.DeleteSnapshotResponse getDefaultInstanceForType() {
        return csi.v0.Csi.DeleteSnapshotResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.DeleteSnapshotResponse build() {
        csi.v0.Csi.DeleteSnapshotResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.DeleteSnapshotResponse buildPartial() {
        csi.v0.Csi.DeleteSnapshotResponse result = new csi.v0.Csi.DeleteSnapshotResponse(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.DeleteSnapshotResponse) {
          return mergeFrom((csi.v0.Csi.DeleteSnapshotResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.DeleteSnapshotResponse other) {
        if (other == csi.v0.Csi.DeleteSnapshotResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.DeleteSnapshotResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.DeleteSnapshotResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.DeleteSnapshotResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.DeleteSnapshotResponse)
    private static final csi.v0.Csi.DeleteSnapshotResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.DeleteSnapshotResponse();
    }

    public static csi.v0.Csi.DeleteSnapshotResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DeleteSnapshotResponse>
        PARSER = new com.google.protobuf.AbstractParser<DeleteSnapshotResponse>() {
      @java.lang.Override
      public DeleteSnapshotResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new DeleteSnapshotResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DeleteSnapshotResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeleteSnapshotResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.DeleteSnapshotResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ListSnapshotsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.ListSnapshotsRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * If specified (non-zero value), the Plugin MUST NOT return more
     * entries than this number in the response. If the actual number of
     * entries is more than this number, the Plugin MUST set `next_token`
     * in the response which can be used to get the next page of entries
     * in the subsequent `ListSnapshots` call. This field is OPTIONAL. If
     * not specified (zero value), it means there is no restriction on the
     * number of entries that can be returned.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int32 max_entries = 1;</code>
     */
    int getMaxEntries();

    /**
     * <pre>
     * A token to specify where to start paginating. Set this field to
     * `next_token` returned by a previous `ListSnapshots` call to get the
     * next page of entries. This field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string starting_token = 2;</code>
     */
    java.lang.String getStartingToken();
    /**
     * <pre>
     * A token to specify where to start paginating. Set this field to
     * `next_token` returned by a previous `ListSnapshots` call to get the
     * next page of entries. This field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string starting_token = 2;</code>
     */
    com.google.protobuf.ByteString
        getStartingTokenBytes();

    /**
     * <pre>
     * Identity information for the source volume. This field is OPTIONAL.
     * It can be used to list snapshots by volume.
     * </pre>
     *
     * <code>string source_volume_id = 3;</code>
     */
    java.lang.String getSourceVolumeId();
    /**
     * <pre>
     * Identity information for the source volume. This field is OPTIONAL.
     * It can be used to list snapshots by volume.
     * </pre>
     *
     * <code>string source_volume_id = 3;</code>
     */
    com.google.protobuf.ByteString
        getSourceVolumeIdBytes();

    /**
     * <pre>
     * Identity information for a specific snapshot. This field is
     * OPTIONAL. It can be used to list only a specific snapshot.
     * ListSnapshots will return with current snapshot information
     * and will not block if the snapshot is being uploaded.
     * </pre>
     *
     * <code>string snapshot_id = 4;</code>
     */
    java.lang.String getSnapshotId();
    /**
     * <pre>
     * Identity information for a specific snapshot. This field is
     * OPTIONAL. It can be used to list only a specific snapshot.
     * ListSnapshots will return with current snapshot information
     * and will not block if the snapshot is being uploaded.
     * </pre>
     *
     * <code>string snapshot_id = 4;</code>
     */
    com.google.protobuf.ByteString
        getSnapshotIdBytes();
  }
  /**
   * <pre>
   * List all snapshots on the storage system regardless of how they were
   * created.
   * </pre>
   *
   * Protobuf type {@code csi.v0.ListSnapshotsRequest}
   */
  public  static final class ListSnapshotsRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.ListSnapshotsRequest)
      ListSnapshotsRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ListSnapshotsRequest.newBuilder() to construct.
    private ListSnapshotsRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ListSnapshotsRequest() {
      maxEntries_ = 0;
      startingToken_ = "";
      sourceVolumeId_ = "";
      snapshotId_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ListSnapshotsRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {

              maxEntries_ = input.readInt32();
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              startingToken_ = s;
              break;
            }
            case 26: {
              java.lang.String s = input.readStringRequireUtf8();

              sourceVolumeId_ = s;
              break;
            }
            case 34: {
              java.lang.String s = input.readStringRequireUtf8();

              snapshotId_ = s;
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_ListSnapshotsRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_ListSnapshotsRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.ListSnapshotsRequest.class, csi.v0.Csi.ListSnapshotsRequest.Builder.class);
    }

    public static final int MAX_ENTRIES_FIELD_NUMBER = 1;
    private int maxEntries_;
    /**
     * <pre>
     * If specified (non-zero value), the Plugin MUST NOT return more
     * entries than this number in the response. If the actual number of
     * entries is more than this number, the Plugin MUST set `next_token`
     * in the response which can be used to get the next page of entries
     * in the subsequent `ListSnapshots` call. This field is OPTIONAL. If
     * not specified (zero value), it means there is no restriction on the
     * number of entries that can be returned.
     * The value of this field MUST NOT be negative.
     * </pre>
     *
     * <code>int32 max_entries = 1;</code>
     */
    public int getMaxEntries() {
      return maxEntries_;
    }

    public static final int STARTING_TOKEN_FIELD_NUMBER = 2;
    private volatile java.lang.Object startingToken_;
    /**
     * <pre>
     * A token to specify where to start paginating. Set this field to
     * `next_token` returned by a previous `ListSnapshots` call to get the
     * next page of entries. This field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string starting_token = 2;</code>
     */
    public java.lang.String getStartingToken() {
      java.lang.Object ref = startingToken_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        startingToken_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A token to specify where to start paginating. Set this field to
     * `next_token` returned by a previous `ListSnapshots` call to get the
     * next page of entries. This field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string starting_token = 2;</code>
     */
    public com.google.protobuf.ByteString
        getStartingTokenBytes() {
      java.lang.Object ref = startingToken_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        startingToken_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SOURCE_VOLUME_ID_FIELD_NUMBER = 3;
    private volatile java.lang.Object sourceVolumeId_;
    /**
     * <pre>
     * Identity information for the source volume. This field is OPTIONAL.
     * It can be used to list snapshots by volume.
     * </pre>
     *
     * <code>string source_volume_id = 3;</code>
     */
    public java.lang.String getSourceVolumeId() {
      java.lang.Object ref = sourceVolumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        sourceVolumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identity information for the source volume. This field is OPTIONAL.
     * It can be used to list snapshots by volume.
     * </pre>
     *
     * <code>string source_volume_id = 3;</code>
     */
    public com.google.protobuf.ByteString
        getSourceVolumeIdBytes() {
      java.lang.Object ref = sourceVolumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        sourceVolumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SNAPSHOT_ID_FIELD_NUMBER = 4;
    private volatile java.lang.Object snapshotId_;
    /**
     * <pre>
     * Identity information for a specific snapshot. This field is
     * OPTIONAL. It can be used to list only a specific snapshot.
     * ListSnapshots will return with current snapshot information
     * and will not block if the snapshot is being uploaded.
     * </pre>
     *
     * <code>string snapshot_id = 4;</code>
     */
    public java.lang.String getSnapshotId() {
      java.lang.Object ref = snapshotId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        snapshotId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Identity information for a specific snapshot. This field is
     * OPTIONAL. It can be used to list only a specific snapshot.
     * ListSnapshots will return with current snapshot information
     * and will not block if the snapshot is being uploaded.
     * </pre>
     *
     * <code>string snapshot_id = 4;</code>
     */
    public com.google.protobuf.ByteString
        getSnapshotIdBytes() {
      java.lang.Object ref = snapshotId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        snapshotId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (maxEntries_ != 0) {
        output.writeInt32(1, maxEntries_);
      }
      if (!getStartingTokenBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, startingToken_);
      }
      if (!getSourceVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, sourceVolumeId_);
      }
      if (!getSnapshotIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, snapshotId_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (maxEntries_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, maxEntries_);
      }
      if (!getStartingTokenBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, startingToken_);
      }
      if (!getSourceVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, sourceVolumeId_);
      }
      if (!getSnapshotIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, snapshotId_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.ListSnapshotsRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.ListSnapshotsRequest other = (csi.v0.Csi.ListSnapshotsRequest) obj;

      boolean result = true;
      result = result && (getMaxEntries()
          == other.getMaxEntries());
      result = result && getStartingToken()
          .equals(other.getStartingToken());
      result = result && getSourceVolumeId()
          .equals(other.getSourceVolumeId());
      result = result && getSnapshotId()
          .equals(other.getSnapshotId());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + MAX_ENTRIES_FIELD_NUMBER;
      hash = (53 * hash) + getMaxEntries();
      hash = (37 * hash) + STARTING_TOKEN_FIELD_NUMBER;
      hash = (53 * hash) + getStartingToken().hashCode();
      hash = (37 * hash) + SOURCE_VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSourceVolumeId().hashCode();
      hash = (37 * hash) + SNAPSHOT_ID_FIELD_NUMBER;
      hash = (53 * hash) + getSnapshotId().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.ListSnapshotsRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ListSnapshotsRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ListSnapshotsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ListSnapshotsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ListSnapshotsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ListSnapshotsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ListSnapshotsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ListSnapshotsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ListSnapshotsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ListSnapshotsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ListSnapshotsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ListSnapshotsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.ListSnapshotsRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * List all snapshots on the storage system regardless of how they were
     * created.
     * </pre>
     *
     * Protobuf type {@code csi.v0.ListSnapshotsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.ListSnapshotsRequest)
        csi.v0.Csi.ListSnapshotsRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ListSnapshotsRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ListSnapshotsRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ListSnapshotsRequest.class, csi.v0.Csi.ListSnapshotsRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.ListSnapshotsRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        maxEntries_ = 0;

        startingToken_ = "";

        sourceVolumeId_ = "";

        snapshotId_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_ListSnapshotsRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.ListSnapshotsRequest getDefaultInstanceForType() {
        return csi.v0.Csi.ListSnapshotsRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.ListSnapshotsRequest build() {
        csi.v0.Csi.ListSnapshotsRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.ListSnapshotsRequest buildPartial() {
        csi.v0.Csi.ListSnapshotsRequest result = new csi.v0.Csi.ListSnapshotsRequest(this);
        result.maxEntries_ = maxEntries_;
        result.startingToken_ = startingToken_;
        result.sourceVolumeId_ = sourceVolumeId_;
        result.snapshotId_ = snapshotId_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.ListSnapshotsRequest) {
          return mergeFrom((csi.v0.Csi.ListSnapshotsRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.ListSnapshotsRequest other) {
        if (other == csi.v0.Csi.ListSnapshotsRequest.getDefaultInstance()) return this;
        if (other.getMaxEntries() != 0) {
          setMaxEntries(other.getMaxEntries());
        }
        if (!other.getStartingToken().isEmpty()) {
          startingToken_ = other.startingToken_;
          onChanged();
        }
        if (!other.getSourceVolumeId().isEmpty()) {
          sourceVolumeId_ = other.sourceVolumeId_;
          onChanged();
        }
        if (!other.getSnapshotId().isEmpty()) {
          snapshotId_ = other.snapshotId_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.ListSnapshotsRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.ListSnapshotsRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int maxEntries_ ;
      /**
       * <pre>
       * If specified (non-zero value), the Plugin MUST NOT return more
       * entries than this number in the response. If the actual number of
       * entries is more than this number, the Plugin MUST set `next_token`
       * in the response which can be used to get the next page of entries
       * in the subsequent `ListSnapshots` call. This field is OPTIONAL. If
       * not specified (zero value), it means there is no restriction on the
       * number of entries that can be returned.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int32 max_entries = 1;</code>
       */
      public int getMaxEntries() {
        return maxEntries_;
      }
      /**
       * <pre>
       * If specified (non-zero value), the Plugin MUST NOT return more
       * entries than this number in the response. If the actual number of
       * entries is more than this number, the Plugin MUST set `next_token`
       * in the response which can be used to get the next page of entries
       * in the subsequent `ListSnapshots` call. This field is OPTIONAL. If
       * not specified (zero value), it means there is no restriction on the
       * number of entries that can be returned.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int32 max_entries = 1;</code>
       */
      public Builder setMaxEntries(int value) {
        
        maxEntries_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified (non-zero value), the Plugin MUST NOT return more
       * entries than this number in the response. If the actual number of
       * entries is more than this number, the Plugin MUST set `next_token`
       * in the response which can be used to get the next page of entries
       * in the subsequent `ListSnapshots` call. This field is OPTIONAL. If
       * not specified (zero value), it means there is no restriction on the
       * number of entries that can be returned.
       * The value of this field MUST NOT be negative.
       * </pre>
       *
       * <code>int32 max_entries = 1;</code>
       */
      public Builder clearMaxEntries() {
        
        maxEntries_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object startingToken_ = "";
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListSnapshots` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public java.lang.String getStartingToken() {
        java.lang.Object ref = startingToken_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          startingToken_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListSnapshots` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public com.google.protobuf.ByteString
          getStartingTokenBytes() {
        java.lang.Object ref = startingToken_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          startingToken_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListSnapshots` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public Builder setStartingToken(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        startingToken_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListSnapshots` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public Builder clearStartingToken() {
        
        startingToken_ = getDefaultInstance().getStartingToken();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A token to specify where to start paginating. Set this field to
       * `next_token` returned by a previous `ListSnapshots` call to get the
       * next page of entries. This field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string starting_token = 2;</code>
       */
      public Builder setStartingTokenBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        startingToken_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object sourceVolumeId_ = "";
      /**
       * <pre>
       * Identity information for the source volume. This field is OPTIONAL.
       * It can be used to list snapshots by volume.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public java.lang.String getSourceVolumeId() {
        java.lang.Object ref = sourceVolumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          sourceVolumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identity information for the source volume. This field is OPTIONAL.
       * It can be used to list snapshots by volume.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public com.google.protobuf.ByteString
          getSourceVolumeIdBytes() {
        java.lang.Object ref = sourceVolumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          sourceVolumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identity information for the source volume. This field is OPTIONAL.
       * It can be used to list snapshots by volume.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public Builder setSourceVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        sourceVolumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identity information for the source volume. This field is OPTIONAL.
       * It can be used to list snapshots by volume.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public Builder clearSourceVolumeId() {
        
        sourceVolumeId_ = getDefaultInstance().getSourceVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identity information for the source volume. This field is OPTIONAL.
       * It can be used to list snapshots by volume.
       * </pre>
       *
       * <code>string source_volume_id = 3;</code>
       */
      public Builder setSourceVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        sourceVolumeId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object snapshotId_ = "";
      /**
       * <pre>
       * Identity information for a specific snapshot. This field is
       * OPTIONAL. It can be used to list only a specific snapshot.
       * ListSnapshots will return with current snapshot information
       * and will not block if the snapshot is being uploaded.
       * </pre>
       *
       * <code>string snapshot_id = 4;</code>
       */
      public java.lang.String getSnapshotId() {
        java.lang.Object ref = snapshotId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          snapshotId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Identity information for a specific snapshot. This field is
       * OPTIONAL. It can be used to list only a specific snapshot.
       * ListSnapshots will return with current snapshot information
       * and will not block if the snapshot is being uploaded.
       * </pre>
       *
       * <code>string snapshot_id = 4;</code>
       */
      public com.google.protobuf.ByteString
          getSnapshotIdBytes() {
        java.lang.Object ref = snapshotId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          snapshotId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Identity information for a specific snapshot. This field is
       * OPTIONAL. It can be used to list only a specific snapshot.
       * ListSnapshots will return with current snapshot information
       * and will not block if the snapshot is being uploaded.
       * </pre>
       *
       * <code>string snapshot_id = 4;</code>
       */
      public Builder setSnapshotId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        snapshotId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identity information for a specific snapshot. This field is
       * OPTIONAL. It can be used to list only a specific snapshot.
       * ListSnapshots will return with current snapshot information
       * and will not block if the snapshot is being uploaded.
       * </pre>
       *
       * <code>string snapshot_id = 4;</code>
       */
      public Builder clearSnapshotId() {
        
        snapshotId_ = getDefaultInstance().getSnapshotId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Identity information for a specific snapshot. This field is
       * OPTIONAL. It can be used to list only a specific snapshot.
       * ListSnapshots will return with current snapshot information
       * and will not block if the snapshot is being uploaded.
       * </pre>
       *
       * <code>string snapshot_id = 4;</code>
       */
      public Builder setSnapshotIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        snapshotId_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.ListSnapshotsRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.ListSnapshotsRequest)
    private static final csi.v0.Csi.ListSnapshotsRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.ListSnapshotsRequest();
    }

    public static csi.v0.Csi.ListSnapshotsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ListSnapshotsRequest>
        PARSER = new com.google.protobuf.AbstractParser<ListSnapshotsRequest>() {
      @java.lang.Override
      public ListSnapshotsRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ListSnapshotsRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ListSnapshotsRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ListSnapshotsRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.ListSnapshotsRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ListSnapshotsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.ListSnapshotsResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    java.util.List<csi.v0.Csi.ListSnapshotsResponse.Entry> 
        getEntriesList();
    /**
     * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    csi.v0.Csi.ListSnapshotsResponse.Entry getEntries(int index);
    /**
     * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    int getEntriesCount();
    /**
     * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    java.util.List<? extends csi.v0.Csi.ListSnapshotsResponse.EntryOrBuilder> 
        getEntriesOrBuilderList();
    /**
     * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    csi.v0.Csi.ListSnapshotsResponse.EntryOrBuilder getEntriesOrBuilder(
        int index);

    /**
     * <pre>
     * This token allows you to get the next page of entries for
     * `ListSnapshots` request. If the number of entries is larger than
     * `max_entries`, use the `next_token` as a value for the
     * `starting_token` field in the next `ListSnapshots` request. This
     * field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string next_token = 2;</code>
     */
    java.lang.String getNextToken();
    /**
     * <pre>
     * This token allows you to get the next page of entries for
     * `ListSnapshots` request. If the number of entries is larger than
     * `max_entries`, use the `next_token` as a value for the
     * `starting_token` field in the next `ListSnapshots` request. This
     * field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string next_token = 2;</code>
     */
    com.google.protobuf.ByteString
        getNextTokenBytes();
  }
  /**
   * Protobuf type {@code csi.v0.ListSnapshotsResponse}
   */
  public  static final class ListSnapshotsResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.ListSnapshotsResponse)
      ListSnapshotsResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ListSnapshotsResponse.newBuilder() to construct.
    private ListSnapshotsResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ListSnapshotsResponse() {
      entries_ = java.util.Collections.emptyList();
      nextToken_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ListSnapshotsResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                entries_ = new java.util.ArrayList<csi.v0.Csi.ListSnapshotsResponse.Entry>();
                mutable_bitField0_ |= 0x00000001;
              }
              entries_.add(
                  input.readMessage(csi.v0.Csi.ListSnapshotsResponse.Entry.parser(), extensionRegistry));
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              nextToken_ = s;
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          entries_ = java.util.Collections.unmodifiableList(entries_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_ListSnapshotsResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_ListSnapshotsResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.ListSnapshotsResponse.class, csi.v0.Csi.ListSnapshotsResponse.Builder.class);
    }

    public interface EntryOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v0.ListSnapshotsResponse.Entry)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>.csi.v0.Snapshot snapshot = 1;</code>
       */
      boolean hasSnapshot();
      /**
       * <code>.csi.v0.Snapshot snapshot = 1;</code>
       */
      csi.v0.Csi.Snapshot getSnapshot();
      /**
       * <code>.csi.v0.Snapshot snapshot = 1;</code>
       */
      csi.v0.Csi.SnapshotOrBuilder getSnapshotOrBuilder();
    }
    /**
     * Protobuf type {@code csi.v0.ListSnapshotsResponse.Entry}
     */
    public  static final class Entry extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v0.ListSnapshotsResponse.Entry)
        EntryOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Entry.newBuilder() to construct.
      private Entry(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Entry() {
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private Entry(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                csi.v0.Csi.Snapshot.Builder subBuilder = null;
                if (snapshot_ != null) {
                  subBuilder = snapshot_.toBuilder();
                }
                snapshot_ = input.readMessage(csi.v0.Csi.Snapshot.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(snapshot_);
                  snapshot_ = subBuilder.buildPartial();
                }

                break;
              }
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ListSnapshotsResponse_Entry_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ListSnapshotsResponse_Entry_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ListSnapshotsResponse.Entry.class, csi.v0.Csi.ListSnapshotsResponse.Entry.Builder.class);
      }

      public static final int SNAPSHOT_FIELD_NUMBER = 1;
      private csi.v0.Csi.Snapshot snapshot_;
      /**
       * <code>.csi.v0.Snapshot snapshot = 1;</code>
       */
      public boolean hasSnapshot() {
        return snapshot_ != null;
      }
      /**
       * <code>.csi.v0.Snapshot snapshot = 1;</code>
       */
      public csi.v0.Csi.Snapshot getSnapshot() {
        return snapshot_ == null ? csi.v0.Csi.Snapshot.getDefaultInstance() : snapshot_;
      }
      /**
       * <code>.csi.v0.Snapshot snapshot = 1;</code>
       */
      public csi.v0.Csi.SnapshotOrBuilder getSnapshotOrBuilder() {
        return getSnapshot();
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (snapshot_ != null) {
          output.writeMessage(1, getSnapshot());
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (snapshot_ != null) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, getSnapshot());
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v0.Csi.ListSnapshotsResponse.Entry)) {
          return super.equals(obj);
        }
        csi.v0.Csi.ListSnapshotsResponse.Entry other = (csi.v0.Csi.ListSnapshotsResponse.Entry) obj;

        boolean result = true;
        result = result && (hasSnapshot() == other.hasSnapshot());
        if (hasSnapshot()) {
          result = result && getSnapshot()
              .equals(other.getSnapshot());
        }
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasSnapshot()) {
          hash = (37 * hash) + SNAPSHOT_FIELD_NUMBER;
          hash = (53 * hash) + getSnapshot().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v0.Csi.ListSnapshotsResponse.Entry parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.ListSnapshotsResponse.Entry parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.ListSnapshotsResponse.Entry parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.ListSnapshotsResponse.Entry parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.ListSnapshotsResponse.Entry parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.ListSnapshotsResponse.Entry parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.ListSnapshotsResponse.Entry parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.ListSnapshotsResponse.Entry parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.ListSnapshotsResponse.Entry parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.ListSnapshotsResponse.Entry parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.ListSnapshotsResponse.Entry parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.ListSnapshotsResponse.Entry parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v0.Csi.ListSnapshotsResponse.Entry prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code csi.v0.ListSnapshotsResponse.Entry}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v0.ListSnapshotsResponse.Entry)
          csi.v0.Csi.ListSnapshotsResponse.EntryOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v0.Csi.internal_static_csi_v0_ListSnapshotsResponse_Entry_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v0.Csi.internal_static_csi_v0_ListSnapshotsResponse_Entry_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v0.Csi.ListSnapshotsResponse.Entry.class, csi.v0.Csi.ListSnapshotsResponse.Entry.Builder.class);
        }

        // Construct using csi.v0.Csi.ListSnapshotsResponse.Entry.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          if (snapshotBuilder_ == null) {
            snapshot_ = null;
          } else {
            snapshot_ = null;
            snapshotBuilder_ = null;
          }
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v0.Csi.internal_static_csi_v0_ListSnapshotsResponse_Entry_descriptor;
        }

        @java.lang.Override
        public csi.v0.Csi.ListSnapshotsResponse.Entry getDefaultInstanceForType() {
          return csi.v0.Csi.ListSnapshotsResponse.Entry.getDefaultInstance();
        }

        @java.lang.Override
        public csi.v0.Csi.ListSnapshotsResponse.Entry build() {
          csi.v0.Csi.ListSnapshotsResponse.Entry result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public csi.v0.Csi.ListSnapshotsResponse.Entry buildPartial() {
          csi.v0.Csi.ListSnapshotsResponse.Entry result = new csi.v0.Csi.ListSnapshotsResponse.Entry(this);
          if (snapshotBuilder_ == null) {
            result.snapshot_ = snapshot_;
          } else {
            result.snapshot_ = snapshotBuilder_.build();
          }
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return (Builder) super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v0.Csi.ListSnapshotsResponse.Entry) {
            return mergeFrom((csi.v0.Csi.ListSnapshotsResponse.Entry)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v0.Csi.ListSnapshotsResponse.Entry other) {
          if (other == csi.v0.Csi.ListSnapshotsResponse.Entry.getDefaultInstance()) return this;
          if (other.hasSnapshot()) {
            mergeSnapshot(other.getSnapshot());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v0.Csi.ListSnapshotsResponse.Entry parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v0.Csi.ListSnapshotsResponse.Entry) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private csi.v0.Csi.Snapshot snapshot_ = null;
        private com.google.protobuf.SingleFieldBuilderV3<
            csi.v0.Csi.Snapshot, csi.v0.Csi.Snapshot.Builder, csi.v0.Csi.SnapshotOrBuilder> snapshotBuilder_;
        /**
         * <code>.csi.v0.Snapshot snapshot = 1;</code>
         */
        public boolean hasSnapshot() {
          return snapshotBuilder_ != null || snapshot_ != null;
        }
        /**
         * <code>.csi.v0.Snapshot snapshot = 1;</code>
         */
        public csi.v0.Csi.Snapshot getSnapshot() {
          if (snapshotBuilder_ == null) {
            return snapshot_ == null ? csi.v0.Csi.Snapshot.getDefaultInstance() : snapshot_;
          } else {
            return snapshotBuilder_.getMessage();
          }
        }
        /**
         * <code>.csi.v0.Snapshot snapshot = 1;</code>
         */
        public Builder setSnapshot(csi.v0.Csi.Snapshot value) {
          if (snapshotBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            snapshot_ = value;
            onChanged();
          } else {
            snapshotBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <code>.csi.v0.Snapshot snapshot = 1;</code>
         */
        public Builder setSnapshot(
            csi.v0.Csi.Snapshot.Builder builderForValue) {
          if (snapshotBuilder_ == null) {
            snapshot_ = builderForValue.build();
            onChanged();
          } else {
            snapshotBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <code>.csi.v0.Snapshot snapshot = 1;</code>
         */
        public Builder mergeSnapshot(csi.v0.Csi.Snapshot value) {
          if (snapshotBuilder_ == null) {
            if (snapshot_ != null) {
              snapshot_ =
                csi.v0.Csi.Snapshot.newBuilder(snapshot_).mergeFrom(value).buildPartial();
            } else {
              snapshot_ = value;
            }
            onChanged();
          } else {
            snapshotBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <code>.csi.v0.Snapshot snapshot = 1;</code>
         */
        public Builder clearSnapshot() {
          if (snapshotBuilder_ == null) {
            snapshot_ = null;
            onChanged();
          } else {
            snapshot_ = null;
            snapshotBuilder_ = null;
          }

          return this;
        }
        /**
         * <code>.csi.v0.Snapshot snapshot = 1;</code>
         */
        public csi.v0.Csi.Snapshot.Builder getSnapshotBuilder() {
          
          onChanged();
          return getSnapshotFieldBuilder().getBuilder();
        }
        /**
         * <code>.csi.v0.Snapshot snapshot = 1;</code>
         */
        public csi.v0.Csi.SnapshotOrBuilder getSnapshotOrBuilder() {
          if (snapshotBuilder_ != null) {
            return snapshotBuilder_.getMessageOrBuilder();
          } else {
            return snapshot_ == null ?
                csi.v0.Csi.Snapshot.getDefaultInstance() : snapshot_;
          }
        }
        /**
         * <code>.csi.v0.Snapshot snapshot = 1;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            csi.v0.Csi.Snapshot, csi.v0.Csi.Snapshot.Builder, csi.v0.Csi.SnapshotOrBuilder> 
            getSnapshotFieldBuilder() {
          if (snapshotBuilder_ == null) {
            snapshotBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                csi.v0.Csi.Snapshot, csi.v0.Csi.Snapshot.Builder, csi.v0.Csi.SnapshotOrBuilder>(
                    getSnapshot(),
                    getParentForChildren(),
                    isClean());
            snapshot_ = null;
          }
          return snapshotBuilder_;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v0.ListSnapshotsResponse.Entry)
      }

      // @@protoc_insertion_point(class_scope:csi.v0.ListSnapshotsResponse.Entry)
      private static final csi.v0.Csi.ListSnapshotsResponse.Entry DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v0.Csi.ListSnapshotsResponse.Entry();
      }

      public static csi.v0.Csi.ListSnapshotsResponse.Entry getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<Entry>
          PARSER = new com.google.protobuf.AbstractParser<Entry>() {
        @java.lang.Override
        public Entry parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new Entry(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<Entry> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Entry> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public csi.v0.Csi.ListSnapshotsResponse.Entry getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int ENTRIES_FIELD_NUMBER = 1;
    private java.util.List<csi.v0.Csi.ListSnapshotsResponse.Entry> entries_;
    /**
     * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    public java.util.List<csi.v0.Csi.ListSnapshotsResponse.Entry> getEntriesList() {
      return entries_;
    }
    /**
     * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    public java.util.List<? extends csi.v0.Csi.ListSnapshotsResponse.EntryOrBuilder> 
        getEntriesOrBuilderList() {
      return entries_;
    }
    /**
     * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    public int getEntriesCount() {
      return entries_.size();
    }
    /**
     * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    public csi.v0.Csi.ListSnapshotsResponse.Entry getEntries(int index) {
      return entries_.get(index);
    }
    /**
     * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
     */
    public csi.v0.Csi.ListSnapshotsResponse.EntryOrBuilder getEntriesOrBuilder(
        int index) {
      return entries_.get(index);
    }

    public static final int NEXT_TOKEN_FIELD_NUMBER = 2;
    private volatile java.lang.Object nextToken_;
    /**
     * <pre>
     * This token allows you to get the next page of entries for
     * `ListSnapshots` request. If the number of entries is larger than
     * `max_entries`, use the `next_token` as a value for the
     * `starting_token` field in the next `ListSnapshots` request. This
     * field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string next_token = 2;</code>
     */
    public java.lang.String getNextToken() {
      java.lang.Object ref = nextToken_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        nextToken_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * This token allows you to get the next page of entries for
     * `ListSnapshots` request. If the number of entries is larger than
     * `max_entries`, use the `next_token` as a value for the
     * `starting_token` field in the next `ListSnapshots` request. This
     * field is OPTIONAL.
     * An empty string is equal to an unspecified field value.
     * </pre>
     *
     * <code>string next_token = 2;</code>
     */
    public com.google.protobuf.ByteString
        getNextTokenBytes() {
      java.lang.Object ref = nextToken_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nextToken_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < entries_.size(); i++) {
        output.writeMessage(1, entries_.get(i));
      }
      if (!getNextTokenBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, nextToken_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < entries_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, entries_.get(i));
      }
      if (!getNextTokenBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, nextToken_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.ListSnapshotsResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.ListSnapshotsResponse other = (csi.v0.Csi.ListSnapshotsResponse) obj;

      boolean result = true;
      result = result && getEntriesList()
          .equals(other.getEntriesList());
      result = result && getNextToken()
          .equals(other.getNextToken());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getEntriesCount() > 0) {
        hash = (37 * hash) + ENTRIES_FIELD_NUMBER;
        hash = (53 * hash) + getEntriesList().hashCode();
      }
      hash = (37 * hash) + NEXT_TOKEN_FIELD_NUMBER;
      hash = (53 * hash) + getNextToken().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.ListSnapshotsResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ListSnapshotsResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ListSnapshotsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ListSnapshotsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ListSnapshotsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.ListSnapshotsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.ListSnapshotsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ListSnapshotsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ListSnapshotsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ListSnapshotsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.ListSnapshotsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.ListSnapshotsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.ListSnapshotsResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.ListSnapshotsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.ListSnapshotsResponse)
        csi.v0.Csi.ListSnapshotsResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_ListSnapshotsResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_ListSnapshotsResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.ListSnapshotsResponse.class, csi.v0.Csi.ListSnapshotsResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.ListSnapshotsResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getEntriesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (entriesBuilder_ == null) {
          entries_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          entriesBuilder_.clear();
        }
        nextToken_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_ListSnapshotsResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.ListSnapshotsResponse getDefaultInstanceForType() {
        return csi.v0.Csi.ListSnapshotsResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.ListSnapshotsResponse build() {
        csi.v0.Csi.ListSnapshotsResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.ListSnapshotsResponse buildPartial() {
        csi.v0.Csi.ListSnapshotsResponse result = new csi.v0.Csi.ListSnapshotsResponse(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (entriesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            entries_ = java.util.Collections.unmodifiableList(entries_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.entries_ = entries_;
        } else {
          result.entries_ = entriesBuilder_.build();
        }
        result.nextToken_ = nextToken_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.ListSnapshotsResponse) {
          return mergeFrom((csi.v0.Csi.ListSnapshotsResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.ListSnapshotsResponse other) {
        if (other == csi.v0.Csi.ListSnapshotsResponse.getDefaultInstance()) return this;
        if (entriesBuilder_ == null) {
          if (!other.entries_.isEmpty()) {
            if (entries_.isEmpty()) {
              entries_ = other.entries_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureEntriesIsMutable();
              entries_.addAll(other.entries_);
            }
            onChanged();
          }
        } else {
          if (!other.entries_.isEmpty()) {
            if (entriesBuilder_.isEmpty()) {
              entriesBuilder_.dispose();
              entriesBuilder_ = null;
              entries_ = other.entries_;
              bitField0_ = (bitField0_ & ~0x00000001);
              entriesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getEntriesFieldBuilder() : null;
            } else {
              entriesBuilder_.addAllMessages(other.entries_);
            }
          }
        }
        if (!other.getNextToken().isEmpty()) {
          nextToken_ = other.nextToken_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.ListSnapshotsResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.ListSnapshotsResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<csi.v0.Csi.ListSnapshotsResponse.Entry> entries_ =
        java.util.Collections.emptyList();
      private void ensureEntriesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          entries_ = new java.util.ArrayList<csi.v0.Csi.ListSnapshotsResponse.Entry>(entries_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.ListSnapshotsResponse.Entry, csi.v0.Csi.ListSnapshotsResponse.Entry.Builder, csi.v0.Csi.ListSnapshotsResponse.EntryOrBuilder> entriesBuilder_;

      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public java.util.List<csi.v0.Csi.ListSnapshotsResponse.Entry> getEntriesList() {
        if (entriesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(entries_);
        } else {
          return entriesBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public int getEntriesCount() {
        if (entriesBuilder_ == null) {
          return entries_.size();
        } else {
          return entriesBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public csi.v0.Csi.ListSnapshotsResponse.Entry getEntries(int index) {
        if (entriesBuilder_ == null) {
          return entries_.get(index);
        } else {
          return entriesBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder setEntries(
          int index, csi.v0.Csi.ListSnapshotsResponse.Entry value) {
        if (entriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEntriesIsMutable();
          entries_.set(index, value);
          onChanged();
        } else {
          entriesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder setEntries(
          int index, csi.v0.Csi.ListSnapshotsResponse.Entry.Builder builderForValue) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          entries_.set(index, builderForValue.build());
          onChanged();
        } else {
          entriesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder addEntries(csi.v0.Csi.ListSnapshotsResponse.Entry value) {
        if (entriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEntriesIsMutable();
          entries_.add(value);
          onChanged();
        } else {
          entriesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder addEntries(
          int index, csi.v0.Csi.ListSnapshotsResponse.Entry value) {
        if (entriesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureEntriesIsMutable();
          entries_.add(index, value);
          onChanged();
        } else {
          entriesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder addEntries(
          csi.v0.Csi.ListSnapshotsResponse.Entry.Builder builderForValue) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          entries_.add(builderForValue.build());
          onChanged();
        } else {
          entriesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder addEntries(
          int index, csi.v0.Csi.ListSnapshotsResponse.Entry.Builder builderForValue) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          entries_.add(index, builderForValue.build());
          onChanged();
        } else {
          entriesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder addAllEntries(
          java.lang.Iterable<? extends csi.v0.Csi.ListSnapshotsResponse.Entry> values) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, entries_);
          onChanged();
        } else {
          entriesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder clearEntries() {
        if (entriesBuilder_ == null) {
          entries_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          entriesBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public Builder removeEntries(int index) {
        if (entriesBuilder_ == null) {
          ensureEntriesIsMutable();
          entries_.remove(index);
          onChanged();
        } else {
          entriesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public csi.v0.Csi.ListSnapshotsResponse.Entry.Builder getEntriesBuilder(
          int index) {
        return getEntriesFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public csi.v0.Csi.ListSnapshotsResponse.EntryOrBuilder getEntriesOrBuilder(
          int index) {
        if (entriesBuilder_ == null) {
          return entries_.get(index);  } else {
          return entriesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public java.util.List<? extends csi.v0.Csi.ListSnapshotsResponse.EntryOrBuilder> 
           getEntriesOrBuilderList() {
        if (entriesBuilder_ != null) {
          return entriesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(entries_);
        }
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public csi.v0.Csi.ListSnapshotsResponse.Entry.Builder addEntriesBuilder() {
        return getEntriesFieldBuilder().addBuilder(
            csi.v0.Csi.ListSnapshotsResponse.Entry.getDefaultInstance());
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public csi.v0.Csi.ListSnapshotsResponse.Entry.Builder addEntriesBuilder(
          int index) {
        return getEntriesFieldBuilder().addBuilder(
            index, csi.v0.Csi.ListSnapshotsResponse.Entry.getDefaultInstance());
      }
      /**
       * <code>repeated .csi.v0.ListSnapshotsResponse.Entry entries = 1;</code>
       */
      public java.util.List<csi.v0.Csi.ListSnapshotsResponse.Entry.Builder> 
           getEntriesBuilderList() {
        return getEntriesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.ListSnapshotsResponse.Entry, csi.v0.Csi.ListSnapshotsResponse.Entry.Builder, csi.v0.Csi.ListSnapshotsResponse.EntryOrBuilder> 
          getEntriesFieldBuilder() {
        if (entriesBuilder_ == null) {
          entriesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v0.Csi.ListSnapshotsResponse.Entry, csi.v0.Csi.ListSnapshotsResponse.Entry.Builder, csi.v0.Csi.ListSnapshotsResponse.EntryOrBuilder>(
                  entries_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          entries_ = null;
        }
        return entriesBuilder_;
      }

      private java.lang.Object nextToken_ = "";
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListSnapshots` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListSnapshots` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public java.lang.String getNextToken() {
        java.lang.Object ref = nextToken_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          nextToken_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListSnapshots` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListSnapshots` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public com.google.protobuf.ByteString
          getNextTokenBytes() {
        java.lang.Object ref = nextToken_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nextToken_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListSnapshots` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListSnapshots` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public Builder setNextToken(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        nextToken_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListSnapshots` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListSnapshots` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public Builder clearNextToken() {
        
        nextToken_ = getDefaultInstance().getNextToken();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This token allows you to get the next page of entries for
       * `ListSnapshots` request. If the number of entries is larger than
       * `max_entries`, use the `next_token` as a value for the
       * `starting_token` field in the next `ListSnapshots` request. This
       * field is OPTIONAL.
       * An empty string is equal to an unspecified field value.
       * </pre>
       *
       * <code>string next_token = 2;</code>
       */
      public Builder setNextTokenBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        nextToken_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.ListSnapshotsResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.ListSnapshotsResponse)
    private static final csi.v0.Csi.ListSnapshotsResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.ListSnapshotsResponse();
    }

    public static csi.v0.Csi.ListSnapshotsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ListSnapshotsResponse>
        PARSER = new com.google.protobuf.AbstractParser<ListSnapshotsResponse>() {
      @java.lang.Override
      public ListSnapshotsResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ListSnapshotsResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ListSnapshotsResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ListSnapshotsResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.ListSnapshotsResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeStageVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.NodeStageVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume to publish. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume to publish. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */
    int getPublishInfoCount();
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */
    boolean containsPublishInfo(
        java.lang.String key);
    /**
     * Use {@link #getPublishInfoMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getPublishInfo();
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getPublishInfoMap();
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */

    java.lang.String getPublishInfoOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */

    java.lang.String getPublishInfoOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * The path to which the volume will be published. It MUST be an
     * absolute path in the root filesystem of the process serving this
     * request. The CO SHALL ensure that there is only one
     * staging_target_path per volume.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string staging_target_path = 3;</code>
     */
    java.lang.String getStagingTargetPath();
    /**
     * <pre>
     * The path to which the volume will be published. It MUST be an
     * absolute path in the root filesystem of the process serving this
     * request. The CO SHALL ensure that there is only one
     * staging_target_path per volume.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string staging_target_path = 3;</code>
     */
    com.google.protobuf.ByteString
        getStagingTargetPathBytes();

    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 4;</code>
     */
    boolean hasVolumeCapability();
    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 4;</code>
     */
    csi.v0.Csi.VolumeCapability getVolumeCapability();
    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 4;</code>
     */
    csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder();

    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_stage_secrets = 5;</code>
     */
    int getNodeStageSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_stage_secrets = 5;</code>
     */
    boolean containsNodeStageSecrets(
        java.lang.String key);
    /**
     * Use {@link #getNodeStageSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getNodeStageSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_stage_secrets = 5;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getNodeStageSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_stage_secrets = 5;</code>
     */

    java.lang.String getNodeStageSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_stage_secrets = 5;</code>
     */

    java.lang.String getNodeStageSecretsOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the `Volume` identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */
    int getVolumeAttributesCount();
    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the `Volume` identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */
    boolean containsVolumeAttributes(
        java.lang.String key);
    /**
     * Use {@link #getVolumeAttributesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeAttributes();
    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the `Volume` identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeAttributesMap();
    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the `Volume` identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */

    java.lang.String getVolumeAttributesOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the `Volume` identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */

    java.lang.String getVolumeAttributesOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v0.NodeStageVolumeRequest}
   */
  public  static final class NodeStageVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.NodeStageVolumeRequest)
      NodeStageVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeStageVolumeRequest.newBuilder() to construct.
    private NodeStageVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeStageVolumeRequest() {
      volumeId_ = "";
      stagingTargetPath_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeStageVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                publishInfo_ = com.google.protobuf.MapField.newMapField(
                    PublishInfoDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000002;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              publishInfo__ = input.readMessage(
                  PublishInfoDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              publishInfo_.getMutableMap().put(
                  publishInfo__.getKey(), publishInfo__.getValue());
              break;
            }
            case 26: {
              java.lang.String s = input.readStringRequireUtf8();

              stagingTargetPath_ = s;
              break;
            }
            case 34: {
              csi.v0.Csi.VolumeCapability.Builder subBuilder = null;
              if (volumeCapability_ != null) {
                subBuilder = volumeCapability_.toBuilder();
              }
              volumeCapability_ = input.readMessage(csi.v0.Csi.VolumeCapability.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(volumeCapability_);
                volumeCapability_ = subBuilder.buildPartial();
              }

              break;
            }
            case 42: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                nodeStageSecrets_ = com.google.protobuf.MapField.newMapField(
                    NodeStageSecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000010;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              nodeStageSecrets__ = input.readMessage(
                  NodeStageSecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              nodeStageSecrets_.getMutableMap().put(
                  nodeStageSecrets__.getKey(), nodeStageSecrets__.getValue());
              break;
            }
            case 50: {
              if (!((mutable_bitField0_ & 0x00000020) == 0x00000020)) {
                volumeAttributes_ = com.google.protobuf.MapField.newMapField(
                    VolumeAttributesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000020;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              volumeAttributes__ = input.readMessage(
                  VolumeAttributesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              volumeAttributes_.getMutableMap().put(
                  volumeAttributes__.getKey(), volumeAttributes__.getValue());
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_NodeStageVolumeRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetPublishInfo();
        case 5:
          return internalGetNodeStageSecrets();
        case 6:
          return internalGetVolumeAttributes();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_NodeStageVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.NodeStageVolumeRequest.class, csi.v0.Csi.NodeStageVolumeRequest.Builder.class);
    }

    private int bitField0_;
    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume to publish. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume to publish. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PUBLISH_INFO_FIELD_NUMBER = 2;
    private static final class PublishInfoDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_NodeStageVolumeRequest_PublishInfoEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> publishInfo_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetPublishInfo() {
      if (publishInfo_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            PublishInfoDefaultEntryHolder.defaultEntry);
      }
      return publishInfo_;
    }

    public int getPublishInfoCount() {
      return internalGetPublishInfo().getMap().size();
    }
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */

    public boolean containsPublishInfo(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetPublishInfo().getMap().containsKey(key);
    }
    /**
     * Use {@link #getPublishInfoMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getPublishInfo() {
      return getPublishInfoMap();
    }
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getPublishInfoMap() {
      return internalGetPublishInfo().getMap();
    }
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */

    public java.lang.String getPublishInfoOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetPublishInfo().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */

    public java.lang.String getPublishInfoOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetPublishInfo().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int STAGING_TARGET_PATH_FIELD_NUMBER = 3;
    private volatile java.lang.Object stagingTargetPath_;
    /**
     * <pre>
     * The path to which the volume will be published. It MUST be an
     * absolute path in the root filesystem of the process serving this
     * request. The CO SHALL ensure that there is only one
     * staging_target_path per volume.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string staging_target_path = 3;</code>
     */
    public java.lang.String getStagingTargetPath() {
      java.lang.Object ref = stagingTargetPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        stagingTargetPath_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The path to which the volume will be published. It MUST be an
     * absolute path in the root filesystem of the process serving this
     * request. The CO SHALL ensure that there is only one
     * staging_target_path per volume.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string staging_target_path = 3;</code>
     */
    public com.google.protobuf.ByteString
        getStagingTargetPathBytes() {
      java.lang.Object ref = stagingTargetPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stagingTargetPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VOLUME_CAPABILITY_FIELD_NUMBER = 4;
    private csi.v0.Csi.VolumeCapability volumeCapability_;
    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 4;</code>
     */
    public boolean hasVolumeCapability() {
      return volumeCapability_ != null;
    }
    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 4;</code>
     */
    public csi.v0.Csi.VolumeCapability getVolumeCapability() {
      return volumeCapability_ == null ? csi.v0.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
    }
    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 4;</code>
     */
    public csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder() {
      return getVolumeCapability();
    }

    public static final int NODE_STAGE_SECRETS_FIELD_NUMBER = 5;
    private static final class NodeStageSecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_NodeStageVolumeRequest_NodeStageSecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> nodeStageSecrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetNodeStageSecrets() {
      if (nodeStageSecrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            NodeStageSecretsDefaultEntryHolder.defaultEntry);
      }
      return nodeStageSecrets_;
    }

    public int getNodeStageSecretsCount() {
      return internalGetNodeStageSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_stage_secrets = 5;</code>
     */

    public boolean containsNodeStageSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetNodeStageSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getNodeStageSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getNodeStageSecrets() {
      return getNodeStageSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_stage_secrets = 5;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getNodeStageSecretsMap() {
      return internalGetNodeStageSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_stage_secrets = 5;</code>
     */

    public java.lang.String getNodeStageSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetNodeStageSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete node stage volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_stage_secrets = 5;</code>
     */

    public java.lang.String getNodeStageSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetNodeStageSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int VOLUME_ATTRIBUTES_FIELD_NUMBER = 6;
    private static final class VolumeAttributesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_NodeStageVolumeRequest_VolumeAttributesEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> volumeAttributes_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetVolumeAttributes() {
      if (volumeAttributes_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            VolumeAttributesDefaultEntryHolder.defaultEntry);
      }
      return volumeAttributes_;
    }

    public int getVolumeAttributesCount() {
      return internalGetVolumeAttributes().getMap().size();
    }
    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the `Volume` identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */

    public boolean containsVolumeAttributes(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetVolumeAttributes().getMap().containsKey(key);
    }
    /**
     * Use {@link #getVolumeAttributesMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getVolumeAttributes() {
      return getVolumeAttributesMap();
    }
    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the `Volume` identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getVolumeAttributesMap() {
      return internalGetVolumeAttributes().getMap();
    }
    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the `Volume` identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */

    public java.lang.String getVolumeAttributesOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeAttributes().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the `Volume` identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
     */

    public java.lang.String getVolumeAttributesOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeAttributes().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetPublishInfo(),
          PublishInfoDefaultEntryHolder.defaultEntry,
          2);
      if (!getStagingTargetPathBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, stagingTargetPath_);
      }
      if (volumeCapability_ != null) {
        output.writeMessage(4, getVolumeCapability());
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetNodeStageSecrets(),
          NodeStageSecretsDefaultEntryHolder.defaultEntry,
          5);
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetVolumeAttributes(),
          VolumeAttributesDefaultEntryHolder.defaultEntry,
          6);
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetPublishInfo().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        publishInfo__ = PublishInfoDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, publishInfo__);
      }
      if (!getStagingTargetPathBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, stagingTargetPath_);
      }
      if (volumeCapability_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getVolumeCapability());
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetNodeStageSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        nodeStageSecrets__ = NodeStageSecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(5, nodeStageSecrets__);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetVolumeAttributes().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        volumeAttributes__ = VolumeAttributesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(6, volumeAttributes__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.NodeStageVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.NodeStageVolumeRequest other = (csi.v0.Csi.NodeStageVolumeRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && internalGetPublishInfo().equals(
          other.internalGetPublishInfo());
      result = result && getStagingTargetPath()
          .equals(other.getStagingTargetPath());
      result = result && (hasVolumeCapability() == other.hasVolumeCapability());
      if (hasVolumeCapability()) {
        result = result && getVolumeCapability()
            .equals(other.getVolumeCapability());
      }
      result = result && internalGetNodeStageSecrets().equals(
          other.internalGetNodeStageSecrets());
      result = result && internalGetVolumeAttributes().equals(
          other.internalGetVolumeAttributes());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      if (!internalGetPublishInfo().getMap().isEmpty()) {
        hash = (37 * hash) + PUBLISH_INFO_FIELD_NUMBER;
        hash = (53 * hash) + internalGetPublishInfo().hashCode();
      }
      hash = (37 * hash) + STAGING_TARGET_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getStagingTargetPath().hashCode();
      if (hasVolumeCapability()) {
        hash = (37 * hash) + VOLUME_CAPABILITY_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeCapability().hashCode();
      }
      if (!internalGetNodeStageSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + NODE_STAGE_SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetNodeStageSecrets().hashCode();
      }
      if (!internalGetVolumeAttributes().getMap().isEmpty()) {
        hash = (37 * hash) + VOLUME_ATTRIBUTES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetVolumeAttributes().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.NodeStageVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeStageVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeStageVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeStageVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeStageVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeStageVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeStageVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeStageVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeStageVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeStageVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeStageVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeStageVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.NodeStageVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.NodeStageVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.NodeStageVolumeRequest)
        csi.v0.Csi.NodeStageVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_NodeStageVolumeRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetPublishInfo();
          case 5:
            return internalGetNodeStageSecrets();
          case 6:
            return internalGetVolumeAttributes();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutablePublishInfo();
          case 5:
            return internalGetMutableNodeStageSecrets();
          case 6:
            return internalGetMutableVolumeAttributes();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_NodeStageVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.NodeStageVolumeRequest.class, csi.v0.Csi.NodeStageVolumeRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.NodeStageVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        internalGetMutablePublishInfo().clear();
        stagingTargetPath_ = "";

        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = null;
        } else {
          volumeCapability_ = null;
          volumeCapabilityBuilder_ = null;
        }
        internalGetMutableNodeStageSecrets().clear();
        internalGetMutableVolumeAttributes().clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_NodeStageVolumeRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeStageVolumeRequest getDefaultInstanceForType() {
        return csi.v0.Csi.NodeStageVolumeRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.NodeStageVolumeRequest build() {
        csi.v0.Csi.NodeStageVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeStageVolumeRequest buildPartial() {
        csi.v0.Csi.NodeStageVolumeRequest result = new csi.v0.Csi.NodeStageVolumeRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.volumeId_ = volumeId_;
        result.publishInfo_ = internalGetPublishInfo();
        result.publishInfo_.makeImmutable();
        result.stagingTargetPath_ = stagingTargetPath_;
        if (volumeCapabilityBuilder_ == null) {
          result.volumeCapability_ = volumeCapability_;
        } else {
          result.volumeCapability_ = volumeCapabilityBuilder_.build();
        }
        result.nodeStageSecrets_ = internalGetNodeStageSecrets();
        result.nodeStageSecrets_.makeImmutable();
        result.volumeAttributes_ = internalGetVolumeAttributes();
        result.volumeAttributes_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.NodeStageVolumeRequest) {
          return mergeFrom((csi.v0.Csi.NodeStageVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.NodeStageVolumeRequest other) {
        if (other == csi.v0.Csi.NodeStageVolumeRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        internalGetMutablePublishInfo().mergeFrom(
            other.internalGetPublishInfo());
        if (!other.getStagingTargetPath().isEmpty()) {
          stagingTargetPath_ = other.stagingTargetPath_;
          onChanged();
        }
        if (other.hasVolumeCapability()) {
          mergeVolumeCapability(other.getVolumeCapability());
        }
        internalGetMutableNodeStageSecrets().mergeFrom(
            other.internalGetNodeStageSecrets());
        internalGetMutableVolumeAttributes().mergeFrom(
            other.internalGetVolumeAttributes());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.NodeStageVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.NodeStageVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> publishInfo_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetPublishInfo() {
        if (publishInfo_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              PublishInfoDefaultEntryHolder.defaultEntry);
        }
        return publishInfo_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutablePublishInfo() {
        onChanged();;
        if (publishInfo_ == null) {
          publishInfo_ = com.google.protobuf.MapField.newMapField(
              PublishInfoDefaultEntryHolder.defaultEntry);
        }
        if (!publishInfo_.isMutable()) {
          publishInfo_ = publishInfo_.copy();
        }
        return publishInfo_;
      }

      public int getPublishInfoCount() {
        return internalGetPublishInfo().getMap().size();
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 2;</code>
       */

      public boolean containsPublishInfo(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetPublishInfo().getMap().containsKey(key);
      }
      /**
       * Use {@link #getPublishInfoMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getPublishInfo() {
        return getPublishInfoMap();
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 2;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getPublishInfoMap() {
        return internalGetPublishInfo().getMap();
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 2;</code>
       */

      public java.lang.String getPublishInfoOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetPublishInfo().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 2;</code>
       */

      public java.lang.String getPublishInfoOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetPublishInfo().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearPublishInfo() {
        internalGetMutablePublishInfo().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 2;</code>
       */

      public Builder removePublishInfo(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutablePublishInfo().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutablePublishInfo() {
        return internalGetMutablePublishInfo().getMutableMap();
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 2;</code>
       */
      public Builder putPublishInfo(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutablePublishInfo().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 2;</code>
       */

      public Builder putAllPublishInfo(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutablePublishInfo().getMutableMap()
            .putAll(values);
        return this;
      }

      private java.lang.Object stagingTargetPath_ = "";
      /**
       * <pre>
       * The path to which the volume will be published. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request. The CO SHALL ensure that there is only one
       * staging_target_path per volume.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public java.lang.String getStagingTargetPath() {
        java.lang.Object ref = stagingTargetPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          stagingTargetPath_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The path to which the volume will be published. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request. The CO SHALL ensure that there is only one
       * staging_target_path per volume.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public com.google.protobuf.ByteString
          getStagingTargetPathBytes() {
        java.lang.Object ref = stagingTargetPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stagingTargetPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path to which the volume will be published. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request. The CO SHALL ensure that there is only one
       * staging_target_path per volume.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public Builder setStagingTargetPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        stagingTargetPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to which the volume will be published. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request. The CO SHALL ensure that there is only one
       * staging_target_path per volume.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public Builder clearStagingTargetPath() {
        
        stagingTargetPath_ = getDefaultInstance().getStagingTargetPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to which the volume will be published. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request. The CO SHALL ensure that there is only one
       * staging_target_path per volume.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public Builder setStagingTargetPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        stagingTargetPath_ = value;
        onChanged();
        return this;
      }

      private csi.v0.Csi.VolumeCapability volumeCapability_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder> volumeCapabilityBuilder_;
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 4;</code>
       */
      public boolean hasVolumeCapability() {
        return volumeCapabilityBuilder_ != null || volumeCapability_ != null;
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 4;</code>
       */
      public csi.v0.Csi.VolumeCapability getVolumeCapability() {
        if (volumeCapabilityBuilder_ == null) {
          return volumeCapability_ == null ? csi.v0.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
        } else {
          return volumeCapabilityBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 4;</code>
       */
      public Builder setVolumeCapability(csi.v0.Csi.VolumeCapability value) {
        if (volumeCapabilityBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          volumeCapability_ = value;
          onChanged();
        } else {
          volumeCapabilityBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 4;</code>
       */
      public Builder setVolumeCapability(
          csi.v0.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = builderForValue.build();
          onChanged();
        } else {
          volumeCapabilityBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 4;</code>
       */
      public Builder mergeVolumeCapability(csi.v0.Csi.VolumeCapability value) {
        if (volumeCapabilityBuilder_ == null) {
          if (volumeCapability_ != null) {
            volumeCapability_ =
              csi.v0.Csi.VolumeCapability.newBuilder(volumeCapability_).mergeFrom(value).buildPartial();
          } else {
            volumeCapability_ = value;
          }
          onChanged();
        } else {
          volumeCapabilityBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 4;</code>
       */
      public Builder clearVolumeCapability() {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = null;
          onChanged();
        } else {
          volumeCapability_ = null;
          volumeCapabilityBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 4;</code>
       */
      public csi.v0.Csi.VolumeCapability.Builder getVolumeCapabilityBuilder() {
        
        onChanged();
        return getVolumeCapabilityFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 4;</code>
       */
      public csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder() {
        if (volumeCapabilityBuilder_ != null) {
          return volumeCapabilityBuilder_.getMessageOrBuilder();
        } else {
          return volumeCapability_ == null ?
              csi.v0.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
        }
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder> 
          getVolumeCapabilityFieldBuilder() {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapabilityBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder>(
                  getVolumeCapability(),
                  getParentForChildren(),
                  isClean());
          volumeCapability_ = null;
        }
        return volumeCapabilityBuilder_;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> nodeStageSecrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetNodeStageSecrets() {
        if (nodeStageSecrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              NodeStageSecretsDefaultEntryHolder.defaultEntry);
        }
        return nodeStageSecrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableNodeStageSecrets() {
        onChanged();;
        if (nodeStageSecrets_ == null) {
          nodeStageSecrets_ = com.google.protobuf.MapField.newMapField(
              NodeStageSecretsDefaultEntryHolder.defaultEntry);
        }
        if (!nodeStageSecrets_.isMutable()) {
          nodeStageSecrets_ = nodeStageSecrets_.copy();
        }
        return nodeStageSecrets_;
      }

      public int getNodeStageSecretsCount() {
        return internalGetNodeStageSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node stage volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_stage_secrets = 5;</code>
       */

      public boolean containsNodeStageSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetNodeStageSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getNodeStageSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getNodeStageSecrets() {
        return getNodeStageSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node stage volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_stage_secrets = 5;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getNodeStageSecretsMap() {
        return internalGetNodeStageSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node stage volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_stage_secrets = 5;</code>
       */

      public java.lang.String getNodeStageSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetNodeStageSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node stage volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_stage_secrets = 5;</code>
       */

      public java.lang.String getNodeStageSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetNodeStageSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearNodeStageSecrets() {
        internalGetMutableNodeStageSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node stage volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_stage_secrets = 5;</code>
       */

      public Builder removeNodeStageSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableNodeStageSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableNodeStageSecrets() {
        return internalGetMutableNodeStageSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node stage volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_stage_secrets = 5;</code>
       */
      public Builder putNodeStageSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableNodeStageSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node stage volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_stage_secrets = 5;</code>
       */

      public Builder putAllNodeStageSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableNodeStageSecrets().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> volumeAttributes_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetVolumeAttributes() {
        if (volumeAttributes_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              VolumeAttributesDefaultEntryHolder.defaultEntry);
        }
        return volumeAttributes_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableVolumeAttributes() {
        onChanged();;
        if (volumeAttributes_ == null) {
          volumeAttributes_ = com.google.protobuf.MapField.newMapField(
              VolumeAttributesDefaultEntryHolder.defaultEntry);
        }
        if (!volumeAttributes_.isMutable()) {
          volumeAttributes_ = volumeAttributes_.copy();
        }
        return volumeAttributes_;
      }

      public int getVolumeAttributesCount() {
        return internalGetVolumeAttributes().getMap().size();
      }
      /**
       * <pre>
       * Attributes of the volume to publish. This field is OPTIONAL and
       * MUST match the attributes of the `Volume` identified by
       * `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
       */

      public boolean containsVolumeAttributes(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetVolumeAttributes().getMap().containsKey(key);
      }
      /**
       * Use {@link #getVolumeAttributesMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getVolumeAttributes() {
        return getVolumeAttributesMap();
      }
      /**
       * <pre>
       * Attributes of the volume to publish. This field is OPTIONAL and
       * MUST match the attributes of the `Volume` identified by
       * `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getVolumeAttributesMap() {
        return internalGetVolumeAttributes().getMap();
      }
      /**
       * <pre>
       * Attributes of the volume to publish. This field is OPTIONAL and
       * MUST match the attributes of the `Volume` identified by
       * `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
       */

      public java.lang.String getVolumeAttributesOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeAttributes().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Attributes of the volume to publish. This field is OPTIONAL and
       * MUST match the attributes of the `Volume` identified by
       * `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
       */

      public java.lang.String getVolumeAttributesOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeAttributes().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearVolumeAttributes() {
        internalGetMutableVolumeAttributes().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Attributes of the volume to publish. This field is OPTIONAL and
       * MUST match the attributes of the `Volume` identified by
       * `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
       */

      public Builder removeVolumeAttributes(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeAttributes().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableVolumeAttributes() {
        return internalGetMutableVolumeAttributes().getMutableMap();
      }
      /**
       * <pre>
       * Attributes of the volume to publish. This field is OPTIONAL and
       * MUST match the attributes of the `Volume` identified by
       * `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
       */
      public Builder putVolumeAttributes(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeAttributes().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Attributes of the volume to publish. This field is OPTIONAL and
       * MUST match the attributes of the `Volume` identified by
       * `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 6;</code>
       */

      public Builder putAllVolumeAttributes(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableVolumeAttributes().getMutableMap()
            .putAll(values);
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.NodeStageVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.NodeStageVolumeRequest)
    private static final csi.v0.Csi.NodeStageVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.NodeStageVolumeRequest();
    }

    public static csi.v0.Csi.NodeStageVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeStageVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<NodeStageVolumeRequest>() {
      @java.lang.Override
      public NodeStageVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeStageVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeStageVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeStageVolumeRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.NodeStageVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeStageVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.NodeStageVolumeResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v0.NodeStageVolumeResponse}
   */
  public  static final class NodeStageVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.NodeStageVolumeResponse)
      NodeStageVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeStageVolumeResponse.newBuilder() to construct.
    private NodeStageVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeStageVolumeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeStageVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_NodeStageVolumeResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_NodeStageVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.NodeStageVolumeResponse.class, csi.v0.Csi.NodeStageVolumeResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.NodeStageVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.NodeStageVolumeResponse other = (csi.v0.Csi.NodeStageVolumeResponse) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.NodeStageVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeStageVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeStageVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeStageVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeStageVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeStageVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeStageVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeStageVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeStageVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeStageVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeStageVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeStageVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.NodeStageVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v0.NodeStageVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.NodeStageVolumeResponse)
        csi.v0.Csi.NodeStageVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_NodeStageVolumeResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_NodeStageVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.NodeStageVolumeResponse.class, csi.v0.Csi.NodeStageVolumeResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.NodeStageVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_NodeStageVolumeResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeStageVolumeResponse getDefaultInstanceForType() {
        return csi.v0.Csi.NodeStageVolumeResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.NodeStageVolumeResponse build() {
        csi.v0.Csi.NodeStageVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeStageVolumeResponse buildPartial() {
        csi.v0.Csi.NodeStageVolumeResponse result = new csi.v0.Csi.NodeStageVolumeResponse(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.NodeStageVolumeResponse) {
          return mergeFrom((csi.v0.Csi.NodeStageVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.NodeStageVolumeResponse other) {
        if (other == csi.v0.Csi.NodeStageVolumeResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.NodeStageVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.NodeStageVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.NodeStageVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.NodeStageVolumeResponse)
    private static final csi.v0.Csi.NodeStageVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.NodeStageVolumeResponse();
    }

    public static csi.v0.Csi.NodeStageVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeStageVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<NodeStageVolumeResponse>() {
      @java.lang.Override
      public NodeStageVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeStageVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeStageVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeStageVolumeResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.NodeStageVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeUnstageVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.NodeUnstageVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * The path at which the volume was published. It MUST be an absolute
     * path in the root filesystem of the process serving this request.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string staging_target_path = 2;</code>
     */
    java.lang.String getStagingTargetPath();
    /**
     * <pre>
     * The path at which the volume was published. It MUST be an absolute
     * path in the root filesystem of the process serving this request.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string staging_target_path = 2;</code>
     */
    com.google.protobuf.ByteString
        getStagingTargetPathBytes();
  }
  /**
   * Protobuf type {@code csi.v0.NodeUnstageVolumeRequest}
   */
  public  static final class NodeUnstageVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.NodeUnstageVolumeRequest)
      NodeUnstageVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeUnstageVolumeRequest.newBuilder() to construct.
    private NodeUnstageVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeUnstageVolumeRequest() {
      volumeId_ = "";
      stagingTargetPath_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeUnstageVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              stagingTargetPath_ = s;
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_NodeUnstageVolumeRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_NodeUnstageVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.NodeUnstageVolumeRequest.class, csi.v0.Csi.NodeUnstageVolumeRequest.Builder.class);
    }

    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int STAGING_TARGET_PATH_FIELD_NUMBER = 2;
    private volatile java.lang.Object stagingTargetPath_;
    /**
     * <pre>
     * The path at which the volume was published. It MUST be an absolute
     * path in the root filesystem of the process serving this request.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string staging_target_path = 2;</code>
     */
    public java.lang.String getStagingTargetPath() {
      java.lang.Object ref = stagingTargetPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        stagingTargetPath_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The path at which the volume was published. It MUST be an absolute
     * path in the root filesystem of the process serving this request.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string staging_target_path = 2;</code>
     */
    public com.google.protobuf.ByteString
        getStagingTargetPathBytes() {
      java.lang.Object ref = stagingTargetPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stagingTargetPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      if (!getStagingTargetPathBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, stagingTargetPath_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      if (!getStagingTargetPathBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, stagingTargetPath_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.NodeUnstageVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.NodeUnstageVolumeRequest other = (csi.v0.Csi.NodeUnstageVolumeRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && getStagingTargetPath()
          .equals(other.getStagingTargetPath());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      hash = (37 * hash) + STAGING_TARGET_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getStagingTargetPath().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.NodeUnstageVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeUnstageVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnstageVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeUnstageVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnstageVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeUnstageVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnstageVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeUnstageVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnstageVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeUnstageVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnstageVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeUnstageVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.NodeUnstageVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.NodeUnstageVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.NodeUnstageVolumeRequest)
        csi.v0.Csi.NodeUnstageVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_NodeUnstageVolumeRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_NodeUnstageVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.NodeUnstageVolumeRequest.class, csi.v0.Csi.NodeUnstageVolumeRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.NodeUnstageVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        stagingTargetPath_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_NodeUnstageVolumeRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeUnstageVolumeRequest getDefaultInstanceForType() {
        return csi.v0.Csi.NodeUnstageVolumeRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.NodeUnstageVolumeRequest build() {
        csi.v0.Csi.NodeUnstageVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeUnstageVolumeRequest buildPartial() {
        csi.v0.Csi.NodeUnstageVolumeRequest result = new csi.v0.Csi.NodeUnstageVolumeRequest(this);
        result.volumeId_ = volumeId_;
        result.stagingTargetPath_ = stagingTargetPath_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.NodeUnstageVolumeRequest) {
          return mergeFrom((csi.v0.Csi.NodeUnstageVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.NodeUnstageVolumeRequest other) {
        if (other == csi.v0.Csi.NodeUnstageVolumeRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        if (!other.getStagingTargetPath().isEmpty()) {
          stagingTargetPath_ = other.stagingTargetPath_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.NodeUnstageVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.NodeUnstageVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object stagingTargetPath_ = "";
      /**
       * <pre>
       * The path at which the volume was published. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 2;</code>
       */
      public java.lang.String getStagingTargetPath() {
        java.lang.Object ref = stagingTargetPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          stagingTargetPath_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The path at which the volume was published. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 2;</code>
       */
      public com.google.protobuf.ByteString
          getStagingTargetPathBytes() {
        java.lang.Object ref = stagingTargetPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stagingTargetPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path at which the volume was published. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 2;</code>
       */
      public Builder setStagingTargetPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        stagingTargetPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path at which the volume was published. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 2;</code>
       */
      public Builder clearStagingTargetPath() {
        
        stagingTargetPath_ = getDefaultInstance().getStagingTargetPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path at which the volume was published. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string staging_target_path = 2;</code>
       */
      public Builder setStagingTargetPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        stagingTargetPath_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.NodeUnstageVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.NodeUnstageVolumeRequest)
    private static final csi.v0.Csi.NodeUnstageVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.NodeUnstageVolumeRequest();
    }

    public static csi.v0.Csi.NodeUnstageVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeUnstageVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<NodeUnstageVolumeRequest>() {
      @java.lang.Override
      public NodeUnstageVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeUnstageVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeUnstageVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeUnstageVolumeRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.NodeUnstageVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeUnstageVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.NodeUnstageVolumeResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v0.NodeUnstageVolumeResponse}
   */
  public  static final class NodeUnstageVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.NodeUnstageVolumeResponse)
      NodeUnstageVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeUnstageVolumeResponse.newBuilder() to construct.
    private NodeUnstageVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeUnstageVolumeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeUnstageVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_NodeUnstageVolumeResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_NodeUnstageVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.NodeUnstageVolumeResponse.class, csi.v0.Csi.NodeUnstageVolumeResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.NodeUnstageVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.NodeUnstageVolumeResponse other = (csi.v0.Csi.NodeUnstageVolumeResponse) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.NodeUnstageVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeUnstageVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnstageVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeUnstageVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnstageVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeUnstageVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnstageVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeUnstageVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnstageVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeUnstageVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnstageVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeUnstageVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.NodeUnstageVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v0.NodeUnstageVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.NodeUnstageVolumeResponse)
        csi.v0.Csi.NodeUnstageVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_NodeUnstageVolumeResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_NodeUnstageVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.NodeUnstageVolumeResponse.class, csi.v0.Csi.NodeUnstageVolumeResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.NodeUnstageVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_NodeUnstageVolumeResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeUnstageVolumeResponse getDefaultInstanceForType() {
        return csi.v0.Csi.NodeUnstageVolumeResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.NodeUnstageVolumeResponse build() {
        csi.v0.Csi.NodeUnstageVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeUnstageVolumeResponse buildPartial() {
        csi.v0.Csi.NodeUnstageVolumeResponse result = new csi.v0.Csi.NodeUnstageVolumeResponse(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.NodeUnstageVolumeResponse) {
          return mergeFrom((csi.v0.Csi.NodeUnstageVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.NodeUnstageVolumeResponse other) {
        if (other == csi.v0.Csi.NodeUnstageVolumeResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.NodeUnstageVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.NodeUnstageVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.NodeUnstageVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.NodeUnstageVolumeResponse)
    private static final csi.v0.Csi.NodeUnstageVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.NodeUnstageVolumeResponse();
    }

    public static csi.v0.Csi.NodeUnstageVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeUnstageVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<NodeUnstageVolumeResponse>() {
      @java.lang.Override
      public NodeUnstageVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeUnstageVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeUnstageVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeUnstageVolumeResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.NodeUnstageVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodePublishVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.NodePublishVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume to publish. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume to publish. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */
    int getPublishInfoCount();
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */
    boolean containsPublishInfo(
        java.lang.String key);
    /**
     * Use {@link #getPublishInfoMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getPublishInfo();
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getPublishInfoMap();
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */

    java.lang.String getPublishInfoOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */

    java.lang.String getPublishInfoOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * The path to which the device was mounted by `NodeStageVolume`.
     * It MUST be an absolute path in the root filesystem of the process
     * serving this request.
     * It MUST be set if the Node Plugin implements the
     * `STAGE_UNSTAGE_VOLUME` node capability.
     * This is an OPTIONAL field.
     * </pre>
     *
     * <code>string staging_target_path = 3;</code>
     */
    java.lang.String getStagingTargetPath();
    /**
     * <pre>
     * The path to which the device was mounted by `NodeStageVolume`.
     * It MUST be an absolute path in the root filesystem of the process
     * serving this request.
     * It MUST be set if the Node Plugin implements the
     * `STAGE_UNSTAGE_VOLUME` node capability.
     * This is an OPTIONAL field.
     * </pre>
     *
     * <code>string staging_target_path = 3;</code>
     */
    com.google.protobuf.ByteString
        getStagingTargetPathBytes();

    /**
     * <pre>
     * The path to which the volume will be published. It MUST be an
     * absolute path in the root filesystem of the process serving this
     * request. The CO SHALL ensure uniqueness of target_path per volume.
     * The CO SHALL ensure that the path exists, and that the process
     * serving the request has `read` and `write` permissions to the path.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string target_path = 4;</code>
     */
    java.lang.String getTargetPath();
    /**
     * <pre>
     * The path to which the volume will be published. It MUST be an
     * absolute path in the root filesystem of the process serving this
     * request. The CO SHALL ensure uniqueness of target_path per volume.
     * The CO SHALL ensure that the path exists, and that the process
     * serving the request has `read` and `write` permissions to the path.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string target_path = 4;</code>
     */
    com.google.protobuf.ByteString
        getTargetPathBytes();

    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 5;</code>
     */
    boolean hasVolumeCapability();
    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 5;</code>
     */
    csi.v0.Csi.VolumeCapability getVolumeCapability();
    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 5;</code>
     */
    csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder();

    /**
     * <pre>
     * Whether to publish the volume in readonly mode. This field is
     * REQUIRED.
     * </pre>
     *
     * <code>bool readonly = 6;</code>
     */
    boolean getReadonly();

    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_publish_secrets = 7;</code>
     */
    int getNodePublishSecretsCount();
    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_publish_secrets = 7;</code>
     */
    boolean containsNodePublishSecrets(
        java.lang.String key);
    /**
     * Use {@link #getNodePublishSecretsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getNodePublishSecrets();
    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_publish_secrets = 7;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getNodePublishSecretsMap();
    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_publish_secrets = 7;</code>
     */

    java.lang.String getNodePublishSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_publish_secrets = 7;</code>
     */

    java.lang.String getNodePublishSecretsOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the Volume identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 8;</code>
     */
    int getVolumeAttributesCount();
    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the Volume identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 8;</code>
     */
    boolean containsVolumeAttributes(
        java.lang.String key);
    /**
     * Use {@link #getVolumeAttributesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeAttributes();
    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the Volume identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 8;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getVolumeAttributesMap();
    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the Volume identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 8;</code>
     */

    java.lang.String getVolumeAttributesOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the Volume identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 8;</code>
     */

    java.lang.String getVolumeAttributesOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code csi.v0.NodePublishVolumeRequest}
   */
  public  static final class NodePublishVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.NodePublishVolumeRequest)
      NodePublishVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodePublishVolumeRequest.newBuilder() to construct.
    private NodePublishVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodePublishVolumeRequest() {
      volumeId_ = "";
      stagingTargetPath_ = "";
      targetPath_ = "";
      readonly_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodePublishVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                publishInfo_ = com.google.protobuf.MapField.newMapField(
                    PublishInfoDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000002;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              publishInfo__ = input.readMessage(
                  PublishInfoDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              publishInfo_.getMutableMap().put(
                  publishInfo__.getKey(), publishInfo__.getValue());
              break;
            }
            case 26: {
              java.lang.String s = input.readStringRequireUtf8();

              stagingTargetPath_ = s;
              break;
            }
            case 34: {
              java.lang.String s = input.readStringRequireUtf8();

              targetPath_ = s;
              break;
            }
            case 42: {
              csi.v0.Csi.VolumeCapability.Builder subBuilder = null;
              if (volumeCapability_ != null) {
                subBuilder = volumeCapability_.toBuilder();
              }
              volumeCapability_ = input.readMessage(csi.v0.Csi.VolumeCapability.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(volumeCapability_);
                volumeCapability_ = subBuilder.buildPartial();
              }

              break;
            }
            case 48: {

              readonly_ = input.readBool();
              break;
            }
            case 58: {
              if (!((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
                nodePublishSecrets_ = com.google.protobuf.MapField.newMapField(
                    NodePublishSecretsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000040;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              nodePublishSecrets__ = input.readMessage(
                  NodePublishSecretsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              nodePublishSecrets_.getMutableMap().put(
                  nodePublishSecrets__.getKey(), nodePublishSecrets__.getValue());
              break;
            }
            case 66: {
              if (!((mutable_bitField0_ & 0x00000080) == 0x00000080)) {
                volumeAttributes_ = com.google.protobuf.MapField.newMapField(
                    VolumeAttributesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000080;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              volumeAttributes__ = input.readMessage(
                  VolumeAttributesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              volumeAttributes_.getMutableMap().put(
                  volumeAttributes__.getKey(), volumeAttributes__.getValue());
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_NodePublishVolumeRequest_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetPublishInfo();
        case 7:
          return internalGetNodePublishSecrets();
        case 8:
          return internalGetVolumeAttributes();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_NodePublishVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.NodePublishVolumeRequest.class, csi.v0.Csi.NodePublishVolumeRequest.Builder.class);
    }

    private int bitField0_;
    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume to publish. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume to publish. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PUBLISH_INFO_FIELD_NUMBER = 2;
    private static final class PublishInfoDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_NodePublishVolumeRequest_PublishInfoEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> publishInfo_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetPublishInfo() {
      if (publishInfo_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            PublishInfoDefaultEntryHolder.defaultEntry);
      }
      return publishInfo_;
    }

    public int getPublishInfoCount() {
      return internalGetPublishInfo().getMap().size();
    }
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */

    public boolean containsPublishInfo(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetPublishInfo().getMap().containsKey(key);
    }
    /**
     * Use {@link #getPublishInfoMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getPublishInfo() {
      return getPublishInfoMap();
    }
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getPublishInfoMap() {
      return internalGetPublishInfo().getMap();
    }
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */

    public java.lang.String getPublishInfoOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetPublishInfo().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * The CO SHALL set this field to the value returned by
     * `ControllerPublishVolume` if the corresponding Controller Plugin
     * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
     * left unset if the corresponding Controller Plugin does not have
     * this capability. This is an OPTIONAL field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; publish_info = 2;</code>
     */

    public java.lang.String getPublishInfoOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetPublishInfo().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int STAGING_TARGET_PATH_FIELD_NUMBER = 3;
    private volatile java.lang.Object stagingTargetPath_;
    /**
     * <pre>
     * The path to which the device was mounted by `NodeStageVolume`.
     * It MUST be an absolute path in the root filesystem of the process
     * serving this request.
     * It MUST be set if the Node Plugin implements the
     * `STAGE_UNSTAGE_VOLUME` node capability.
     * This is an OPTIONAL field.
     * </pre>
     *
     * <code>string staging_target_path = 3;</code>
     */
    public java.lang.String getStagingTargetPath() {
      java.lang.Object ref = stagingTargetPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        stagingTargetPath_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The path to which the device was mounted by `NodeStageVolume`.
     * It MUST be an absolute path in the root filesystem of the process
     * serving this request.
     * It MUST be set if the Node Plugin implements the
     * `STAGE_UNSTAGE_VOLUME` node capability.
     * This is an OPTIONAL field.
     * </pre>
     *
     * <code>string staging_target_path = 3;</code>
     */
    public com.google.protobuf.ByteString
        getStagingTargetPathBytes() {
      java.lang.Object ref = stagingTargetPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        stagingTargetPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TARGET_PATH_FIELD_NUMBER = 4;
    private volatile java.lang.Object targetPath_;
    /**
     * <pre>
     * The path to which the volume will be published. It MUST be an
     * absolute path in the root filesystem of the process serving this
     * request. The CO SHALL ensure uniqueness of target_path per volume.
     * The CO SHALL ensure that the path exists, and that the process
     * serving the request has `read` and `write` permissions to the path.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string target_path = 4;</code>
     */
    public java.lang.String getTargetPath() {
      java.lang.Object ref = targetPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        targetPath_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The path to which the volume will be published. It MUST be an
     * absolute path in the root filesystem of the process serving this
     * request. The CO SHALL ensure uniqueness of target_path per volume.
     * The CO SHALL ensure that the path exists, and that the process
     * serving the request has `read` and `write` permissions to the path.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string target_path = 4;</code>
     */
    public com.google.protobuf.ByteString
        getTargetPathBytes() {
      java.lang.Object ref = targetPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        targetPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VOLUME_CAPABILITY_FIELD_NUMBER = 5;
    private csi.v0.Csi.VolumeCapability volumeCapability_;
    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 5;</code>
     */
    public boolean hasVolumeCapability() {
      return volumeCapability_ != null;
    }
    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 5;</code>
     */
    public csi.v0.Csi.VolumeCapability getVolumeCapability() {
      return volumeCapability_ == null ? csi.v0.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
    }
    /**
     * <pre>
     * The capability of the volume the CO expects the volume to have.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>.csi.v0.VolumeCapability volume_capability = 5;</code>
     */
    public csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder() {
      return getVolumeCapability();
    }

    public static final int READONLY_FIELD_NUMBER = 6;
    private boolean readonly_;
    /**
     * <pre>
     * Whether to publish the volume in readonly mode. This field is
     * REQUIRED.
     * </pre>
     *
     * <code>bool readonly = 6;</code>
     */
    public boolean getReadonly() {
      return readonly_;
    }

    public static final int NODE_PUBLISH_SECRETS_FIELD_NUMBER = 7;
    private static final class NodePublishSecretsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_NodePublishVolumeRequest_NodePublishSecretsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> nodePublishSecrets_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetNodePublishSecrets() {
      if (nodePublishSecrets_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            NodePublishSecretsDefaultEntryHolder.defaultEntry);
      }
      return nodePublishSecrets_;
    }

    public int getNodePublishSecretsCount() {
      return internalGetNodePublishSecrets().getMap().size();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_publish_secrets = 7;</code>
     */

    public boolean containsNodePublishSecrets(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetNodePublishSecrets().getMap().containsKey(key);
    }
    /**
     * Use {@link #getNodePublishSecretsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getNodePublishSecrets() {
      return getNodePublishSecretsMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_publish_secrets = 7;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getNodePublishSecretsMap() {
      return internalGetNodePublishSecrets().getMap();
    }
    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_publish_secrets = 7;</code>
     */

    public java.lang.String getNodePublishSecretsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetNodePublishSecrets().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Secrets required by plugin to complete node publish volume request.
     * This field is OPTIONAL. Refer to the `Secrets Requirements`
     * section on how to use this field.
     * </pre>
     *
     * <code>map&lt;string, string&gt; node_publish_secrets = 7;</code>
     */

    public java.lang.String getNodePublishSecretsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetNodePublishSecrets().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int VOLUME_ATTRIBUTES_FIELD_NUMBER = 8;
    private static final class VolumeAttributesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  csi.v0.Csi.internal_static_csi_v0_NodePublishVolumeRequest_VolumeAttributesEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> volumeAttributes_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetVolumeAttributes() {
      if (volumeAttributes_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            VolumeAttributesDefaultEntryHolder.defaultEntry);
      }
      return volumeAttributes_;
    }

    public int getVolumeAttributesCount() {
      return internalGetVolumeAttributes().getMap().size();
    }
    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the Volume identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 8;</code>
     */

    public boolean containsVolumeAttributes(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return internalGetVolumeAttributes().getMap().containsKey(key);
    }
    /**
     * Use {@link #getVolumeAttributesMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getVolumeAttributes() {
      return getVolumeAttributesMap();
    }
    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the Volume identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 8;</code>
     */

    public java.util.Map<java.lang.String, java.lang.String> getVolumeAttributesMap() {
      return internalGetVolumeAttributes().getMap();
    }
    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the Volume identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 8;</code>
     */

    public java.lang.String getVolumeAttributesOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeAttributes().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Attributes of the volume to publish. This field is OPTIONAL and
     * MUST match the attributes of the Volume identified by
     * `volume_id`.
     * </pre>
     *
     * <code>map&lt;string, string&gt; volume_attributes = 8;</code>
     */

    public java.lang.String getVolumeAttributesOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetVolumeAttributes().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetPublishInfo(),
          PublishInfoDefaultEntryHolder.defaultEntry,
          2);
      if (!getStagingTargetPathBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, stagingTargetPath_);
      }
      if (!getTargetPathBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, targetPath_);
      }
      if (volumeCapability_ != null) {
        output.writeMessage(5, getVolumeCapability());
      }
      if (readonly_ != false) {
        output.writeBool(6, readonly_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetNodePublishSecrets(),
          NodePublishSecretsDefaultEntryHolder.defaultEntry,
          7);
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetVolumeAttributes(),
          VolumeAttributesDefaultEntryHolder.defaultEntry,
          8);
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetPublishInfo().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        publishInfo__ = PublishInfoDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, publishInfo__);
      }
      if (!getStagingTargetPathBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, stagingTargetPath_);
      }
      if (!getTargetPathBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, targetPath_);
      }
      if (volumeCapability_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getVolumeCapability());
      }
      if (readonly_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, readonly_);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetNodePublishSecrets().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        nodePublishSecrets__ = NodePublishSecretsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(7, nodePublishSecrets__);
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetVolumeAttributes().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        volumeAttributes__ = VolumeAttributesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(8, volumeAttributes__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.NodePublishVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.NodePublishVolumeRequest other = (csi.v0.Csi.NodePublishVolumeRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && internalGetPublishInfo().equals(
          other.internalGetPublishInfo());
      result = result && getStagingTargetPath()
          .equals(other.getStagingTargetPath());
      result = result && getTargetPath()
          .equals(other.getTargetPath());
      result = result && (hasVolumeCapability() == other.hasVolumeCapability());
      if (hasVolumeCapability()) {
        result = result && getVolumeCapability()
            .equals(other.getVolumeCapability());
      }
      result = result && (getReadonly()
          == other.getReadonly());
      result = result && internalGetNodePublishSecrets().equals(
          other.internalGetNodePublishSecrets());
      result = result && internalGetVolumeAttributes().equals(
          other.internalGetVolumeAttributes());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      if (!internalGetPublishInfo().getMap().isEmpty()) {
        hash = (37 * hash) + PUBLISH_INFO_FIELD_NUMBER;
        hash = (53 * hash) + internalGetPublishInfo().hashCode();
      }
      hash = (37 * hash) + STAGING_TARGET_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getStagingTargetPath().hashCode();
      hash = (37 * hash) + TARGET_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getTargetPath().hashCode();
      if (hasVolumeCapability()) {
        hash = (37 * hash) + VOLUME_CAPABILITY_FIELD_NUMBER;
        hash = (53 * hash) + getVolumeCapability().hashCode();
      }
      hash = (37 * hash) + READONLY_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getReadonly());
      if (!internalGetNodePublishSecrets().getMap().isEmpty()) {
        hash = (37 * hash) + NODE_PUBLISH_SECRETS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetNodePublishSecrets().hashCode();
      }
      if (!internalGetVolumeAttributes().getMap().isEmpty()) {
        hash = (37 * hash) + VOLUME_ATTRIBUTES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetVolumeAttributes().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.NodePublishVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodePublishVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodePublishVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodePublishVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodePublishVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodePublishVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodePublishVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodePublishVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodePublishVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodePublishVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodePublishVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodePublishVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.NodePublishVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.NodePublishVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.NodePublishVolumeRequest)
        csi.v0.Csi.NodePublishVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_NodePublishVolumeRequest_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetPublishInfo();
          case 7:
            return internalGetNodePublishSecrets();
          case 8:
            return internalGetVolumeAttributes();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutablePublishInfo();
          case 7:
            return internalGetMutableNodePublishSecrets();
          case 8:
            return internalGetMutableVolumeAttributes();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_NodePublishVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.NodePublishVolumeRequest.class, csi.v0.Csi.NodePublishVolumeRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.NodePublishVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        internalGetMutablePublishInfo().clear();
        stagingTargetPath_ = "";

        targetPath_ = "";

        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = null;
        } else {
          volumeCapability_ = null;
          volumeCapabilityBuilder_ = null;
        }
        readonly_ = false;

        internalGetMutableNodePublishSecrets().clear();
        internalGetMutableVolumeAttributes().clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_NodePublishVolumeRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.NodePublishVolumeRequest getDefaultInstanceForType() {
        return csi.v0.Csi.NodePublishVolumeRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.NodePublishVolumeRequest build() {
        csi.v0.Csi.NodePublishVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.NodePublishVolumeRequest buildPartial() {
        csi.v0.Csi.NodePublishVolumeRequest result = new csi.v0.Csi.NodePublishVolumeRequest(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.volumeId_ = volumeId_;
        result.publishInfo_ = internalGetPublishInfo();
        result.publishInfo_.makeImmutable();
        result.stagingTargetPath_ = stagingTargetPath_;
        result.targetPath_ = targetPath_;
        if (volumeCapabilityBuilder_ == null) {
          result.volumeCapability_ = volumeCapability_;
        } else {
          result.volumeCapability_ = volumeCapabilityBuilder_.build();
        }
        result.readonly_ = readonly_;
        result.nodePublishSecrets_ = internalGetNodePublishSecrets();
        result.nodePublishSecrets_.makeImmutable();
        result.volumeAttributes_ = internalGetVolumeAttributes();
        result.volumeAttributes_.makeImmutable();
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.NodePublishVolumeRequest) {
          return mergeFrom((csi.v0.Csi.NodePublishVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.NodePublishVolumeRequest other) {
        if (other == csi.v0.Csi.NodePublishVolumeRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        internalGetMutablePublishInfo().mergeFrom(
            other.internalGetPublishInfo());
        if (!other.getStagingTargetPath().isEmpty()) {
          stagingTargetPath_ = other.stagingTargetPath_;
          onChanged();
        }
        if (!other.getTargetPath().isEmpty()) {
          targetPath_ = other.targetPath_;
          onChanged();
        }
        if (other.hasVolumeCapability()) {
          mergeVolumeCapability(other.getVolumeCapability());
        }
        if (other.getReadonly() != false) {
          setReadonly(other.getReadonly());
        }
        internalGetMutableNodePublishSecrets().mergeFrom(
            other.internalGetNodePublishSecrets());
        internalGetMutableVolumeAttributes().mergeFrom(
            other.internalGetVolumeAttributes());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.NodePublishVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.NodePublishVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume to publish. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> publishInfo_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetPublishInfo() {
        if (publishInfo_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              PublishInfoDefaultEntryHolder.defaultEntry);
        }
        return publishInfo_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutablePublishInfo() {
        onChanged();;
        if (publishInfo_ == null) {
          publishInfo_ = com.google.protobuf.MapField.newMapField(
              PublishInfoDefaultEntryHolder.defaultEntry);
        }
        if (!publishInfo_.isMutable()) {
          publishInfo_ = publishInfo_.copy();
        }
        return publishInfo_;
      }

      public int getPublishInfoCount() {
        return internalGetPublishInfo().getMap().size();
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 2;</code>
       */

      public boolean containsPublishInfo(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetPublishInfo().getMap().containsKey(key);
      }
      /**
       * Use {@link #getPublishInfoMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getPublishInfo() {
        return getPublishInfoMap();
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 2;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getPublishInfoMap() {
        return internalGetPublishInfo().getMap();
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 2;</code>
       */

      public java.lang.String getPublishInfoOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetPublishInfo().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 2;</code>
       */

      public java.lang.String getPublishInfoOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetPublishInfo().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearPublishInfo() {
        internalGetMutablePublishInfo().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 2;</code>
       */

      public Builder removePublishInfo(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutablePublishInfo().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutablePublishInfo() {
        return internalGetMutablePublishInfo().getMutableMap();
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 2;</code>
       */
      public Builder putPublishInfo(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutablePublishInfo().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * The CO SHALL set this field to the value returned by
       * `ControllerPublishVolume` if the corresponding Controller Plugin
       * has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
       * left unset if the corresponding Controller Plugin does not have
       * this capability. This is an OPTIONAL field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; publish_info = 2;</code>
       */

      public Builder putAllPublishInfo(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutablePublishInfo().getMutableMap()
            .putAll(values);
        return this;
      }

      private java.lang.Object stagingTargetPath_ = "";
      /**
       * <pre>
       * The path to which the device was mounted by `NodeStageVolume`.
       * It MUST be an absolute path in the root filesystem of the process
       * serving this request.
       * It MUST be set if the Node Plugin implements the
       * `STAGE_UNSTAGE_VOLUME` node capability.
       * This is an OPTIONAL field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public java.lang.String getStagingTargetPath() {
        java.lang.Object ref = stagingTargetPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          stagingTargetPath_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The path to which the device was mounted by `NodeStageVolume`.
       * It MUST be an absolute path in the root filesystem of the process
       * serving this request.
       * It MUST be set if the Node Plugin implements the
       * `STAGE_UNSTAGE_VOLUME` node capability.
       * This is an OPTIONAL field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public com.google.protobuf.ByteString
          getStagingTargetPathBytes() {
        java.lang.Object ref = stagingTargetPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          stagingTargetPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path to which the device was mounted by `NodeStageVolume`.
       * It MUST be an absolute path in the root filesystem of the process
       * serving this request.
       * It MUST be set if the Node Plugin implements the
       * `STAGE_UNSTAGE_VOLUME` node capability.
       * This is an OPTIONAL field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public Builder setStagingTargetPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        stagingTargetPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to which the device was mounted by `NodeStageVolume`.
       * It MUST be an absolute path in the root filesystem of the process
       * serving this request.
       * It MUST be set if the Node Plugin implements the
       * `STAGE_UNSTAGE_VOLUME` node capability.
       * This is an OPTIONAL field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public Builder clearStagingTargetPath() {
        
        stagingTargetPath_ = getDefaultInstance().getStagingTargetPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to which the device was mounted by `NodeStageVolume`.
       * It MUST be an absolute path in the root filesystem of the process
       * serving this request.
       * It MUST be set if the Node Plugin implements the
       * `STAGE_UNSTAGE_VOLUME` node capability.
       * This is an OPTIONAL field.
       * </pre>
       *
       * <code>string staging_target_path = 3;</code>
       */
      public Builder setStagingTargetPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        stagingTargetPath_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object targetPath_ = "";
      /**
       * <pre>
       * The path to which the volume will be published. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request. The CO SHALL ensure uniqueness of target_path per volume.
       * The CO SHALL ensure that the path exists, and that the process
       * serving the request has `read` and `write` permissions to the path.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 4;</code>
       */
      public java.lang.String getTargetPath() {
        java.lang.Object ref = targetPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          targetPath_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The path to which the volume will be published. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request. The CO SHALL ensure uniqueness of target_path per volume.
       * The CO SHALL ensure that the path exists, and that the process
       * serving the request has `read` and `write` permissions to the path.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 4;</code>
       */
      public com.google.protobuf.ByteString
          getTargetPathBytes() {
        java.lang.Object ref = targetPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          targetPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path to which the volume will be published. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request. The CO SHALL ensure uniqueness of target_path per volume.
       * The CO SHALL ensure that the path exists, and that the process
       * serving the request has `read` and `write` permissions to the path.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 4;</code>
       */
      public Builder setTargetPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        targetPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to which the volume will be published. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request. The CO SHALL ensure uniqueness of target_path per volume.
       * The CO SHALL ensure that the path exists, and that the process
       * serving the request has `read` and `write` permissions to the path.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 4;</code>
       */
      public Builder clearTargetPath() {
        
        targetPath_ = getDefaultInstance().getTargetPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path to which the volume will be published. It MUST be an
       * absolute path in the root filesystem of the process serving this
       * request. The CO SHALL ensure uniqueness of target_path per volume.
       * The CO SHALL ensure that the path exists, and that the process
       * serving the request has `read` and `write` permissions to the path.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 4;</code>
       */
      public Builder setTargetPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        targetPath_ = value;
        onChanged();
        return this;
      }

      private csi.v0.Csi.VolumeCapability volumeCapability_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder> volumeCapabilityBuilder_;
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 5;</code>
       */
      public boolean hasVolumeCapability() {
        return volumeCapabilityBuilder_ != null || volumeCapability_ != null;
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 5;</code>
       */
      public csi.v0.Csi.VolumeCapability getVolumeCapability() {
        if (volumeCapabilityBuilder_ == null) {
          return volumeCapability_ == null ? csi.v0.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
        } else {
          return volumeCapabilityBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 5;</code>
       */
      public Builder setVolumeCapability(csi.v0.Csi.VolumeCapability value) {
        if (volumeCapabilityBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          volumeCapability_ = value;
          onChanged();
        } else {
          volumeCapabilityBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 5;</code>
       */
      public Builder setVolumeCapability(
          csi.v0.Csi.VolumeCapability.Builder builderForValue) {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = builderForValue.build();
          onChanged();
        } else {
          volumeCapabilityBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 5;</code>
       */
      public Builder mergeVolumeCapability(csi.v0.Csi.VolumeCapability value) {
        if (volumeCapabilityBuilder_ == null) {
          if (volumeCapability_ != null) {
            volumeCapability_ =
              csi.v0.Csi.VolumeCapability.newBuilder(volumeCapability_).mergeFrom(value).buildPartial();
          } else {
            volumeCapability_ = value;
          }
          onChanged();
        } else {
          volumeCapabilityBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 5;</code>
       */
      public Builder clearVolumeCapability() {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapability_ = null;
          onChanged();
        } else {
          volumeCapability_ = null;
          volumeCapabilityBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 5;</code>
       */
      public csi.v0.Csi.VolumeCapability.Builder getVolumeCapabilityBuilder() {
        
        onChanged();
        return getVolumeCapabilityFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 5;</code>
       */
      public csi.v0.Csi.VolumeCapabilityOrBuilder getVolumeCapabilityOrBuilder() {
        if (volumeCapabilityBuilder_ != null) {
          return volumeCapabilityBuilder_.getMessageOrBuilder();
        } else {
          return volumeCapability_ == null ?
              csi.v0.Csi.VolumeCapability.getDefaultInstance() : volumeCapability_;
        }
      }
      /**
       * <pre>
       * The capability of the volume the CO expects the volume to have.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>.csi.v0.VolumeCapability volume_capability = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder> 
          getVolumeCapabilityFieldBuilder() {
        if (volumeCapabilityBuilder_ == null) {
          volumeCapabilityBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.VolumeCapability, csi.v0.Csi.VolumeCapability.Builder, csi.v0.Csi.VolumeCapabilityOrBuilder>(
                  getVolumeCapability(),
                  getParentForChildren(),
                  isClean());
          volumeCapability_ = null;
        }
        return volumeCapabilityBuilder_;
      }

      private boolean readonly_ ;
      /**
       * <pre>
       * Whether to publish the volume in readonly mode. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>bool readonly = 6;</code>
       */
      public boolean getReadonly() {
        return readonly_;
      }
      /**
       * <pre>
       * Whether to publish the volume in readonly mode. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>bool readonly = 6;</code>
       */
      public Builder setReadonly(boolean value) {
        
        readonly_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to publish the volume in readonly mode. This field is
       * REQUIRED.
       * </pre>
       *
       * <code>bool readonly = 6;</code>
       */
      public Builder clearReadonly() {
        
        readonly_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> nodePublishSecrets_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetNodePublishSecrets() {
        if (nodePublishSecrets_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              NodePublishSecretsDefaultEntryHolder.defaultEntry);
        }
        return nodePublishSecrets_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableNodePublishSecrets() {
        onChanged();;
        if (nodePublishSecrets_ == null) {
          nodePublishSecrets_ = com.google.protobuf.MapField.newMapField(
              NodePublishSecretsDefaultEntryHolder.defaultEntry);
        }
        if (!nodePublishSecrets_.isMutable()) {
          nodePublishSecrets_ = nodePublishSecrets_.copy();
        }
        return nodePublishSecrets_;
      }

      public int getNodePublishSecretsCount() {
        return internalGetNodePublishSecrets().getMap().size();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node publish volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_publish_secrets = 7;</code>
       */

      public boolean containsNodePublishSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetNodePublishSecrets().getMap().containsKey(key);
      }
      /**
       * Use {@link #getNodePublishSecretsMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getNodePublishSecrets() {
        return getNodePublishSecretsMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node publish volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_publish_secrets = 7;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getNodePublishSecretsMap() {
        return internalGetNodePublishSecrets().getMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node publish volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_publish_secrets = 7;</code>
       */

      public java.lang.String getNodePublishSecretsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetNodePublishSecrets().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node publish volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_publish_secrets = 7;</code>
       */

      public java.lang.String getNodePublishSecretsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetNodePublishSecrets().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearNodePublishSecrets() {
        internalGetMutableNodePublishSecrets().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node publish volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_publish_secrets = 7;</code>
       */

      public Builder removeNodePublishSecrets(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableNodePublishSecrets().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableNodePublishSecrets() {
        return internalGetMutableNodePublishSecrets().getMutableMap();
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node publish volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_publish_secrets = 7;</code>
       */
      public Builder putNodePublishSecrets(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableNodePublishSecrets().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Secrets required by plugin to complete node publish volume request.
       * This field is OPTIONAL. Refer to the `Secrets Requirements`
       * section on how to use this field.
       * </pre>
       *
       * <code>map&lt;string, string&gt; node_publish_secrets = 7;</code>
       */

      public Builder putAllNodePublishSecrets(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableNodePublishSecrets().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> volumeAttributes_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetVolumeAttributes() {
        if (volumeAttributes_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              VolumeAttributesDefaultEntryHolder.defaultEntry);
        }
        return volumeAttributes_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableVolumeAttributes() {
        onChanged();;
        if (volumeAttributes_ == null) {
          volumeAttributes_ = com.google.protobuf.MapField.newMapField(
              VolumeAttributesDefaultEntryHolder.defaultEntry);
        }
        if (!volumeAttributes_.isMutable()) {
          volumeAttributes_ = volumeAttributes_.copy();
        }
        return volumeAttributes_;
      }

      public int getVolumeAttributesCount() {
        return internalGetVolumeAttributes().getMap().size();
      }
      /**
       * <pre>
       * Attributes of the volume to publish. This field is OPTIONAL and
       * MUST match the attributes of the Volume identified by
       * `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 8;</code>
       */

      public boolean containsVolumeAttributes(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        return internalGetVolumeAttributes().getMap().containsKey(key);
      }
      /**
       * Use {@link #getVolumeAttributesMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getVolumeAttributes() {
        return getVolumeAttributesMap();
      }
      /**
       * <pre>
       * Attributes of the volume to publish. This field is OPTIONAL and
       * MUST match the attributes of the Volume identified by
       * `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 8;</code>
       */

      public java.util.Map<java.lang.String, java.lang.String> getVolumeAttributesMap() {
        return internalGetVolumeAttributes().getMap();
      }
      /**
       * <pre>
       * Attributes of the volume to publish. This field is OPTIONAL and
       * MUST match the attributes of the Volume identified by
       * `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 8;</code>
       */

      public java.lang.String getVolumeAttributesOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeAttributes().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Attributes of the volume to publish. This field is OPTIONAL and
       * MUST match the attributes of the Volume identified by
       * `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 8;</code>
       */

      public java.lang.String getVolumeAttributesOrThrow(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetVolumeAttributes().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearVolumeAttributes() {
        internalGetMutableVolumeAttributes().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Attributes of the volume to publish. This field is OPTIONAL and
       * MUST match the attributes of the Volume identified by
       * `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 8;</code>
       */

      public Builder removeVolumeAttributes(
          java.lang.String key) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeAttributes().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableVolumeAttributes() {
        return internalGetMutableVolumeAttributes().getMutableMap();
      }
      /**
       * <pre>
       * Attributes of the volume to publish. This field is OPTIONAL and
       * MUST match the attributes of the Volume identified by
       * `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 8;</code>
       */
      public Builder putVolumeAttributes(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new java.lang.NullPointerException(); }
        if (value == null) { throw new java.lang.NullPointerException(); }
        internalGetMutableVolumeAttributes().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Attributes of the volume to publish. This field is OPTIONAL and
       * MUST match the attributes of the Volume identified by
       * `volume_id`.
       * </pre>
       *
       * <code>map&lt;string, string&gt; volume_attributes = 8;</code>
       */

      public Builder putAllVolumeAttributes(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableVolumeAttributes().getMutableMap()
            .putAll(values);
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.NodePublishVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.NodePublishVolumeRequest)
    private static final csi.v0.Csi.NodePublishVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.NodePublishVolumeRequest();
    }

    public static csi.v0.Csi.NodePublishVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodePublishVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<NodePublishVolumeRequest>() {
      @java.lang.Override
      public NodePublishVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodePublishVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodePublishVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodePublishVolumeRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.NodePublishVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodePublishVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.NodePublishVolumeResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v0.NodePublishVolumeResponse}
   */
  public  static final class NodePublishVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.NodePublishVolumeResponse)
      NodePublishVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodePublishVolumeResponse.newBuilder() to construct.
    private NodePublishVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodePublishVolumeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodePublishVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_NodePublishVolumeResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_NodePublishVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.NodePublishVolumeResponse.class, csi.v0.Csi.NodePublishVolumeResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.NodePublishVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.NodePublishVolumeResponse other = (csi.v0.Csi.NodePublishVolumeResponse) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.NodePublishVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodePublishVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodePublishVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodePublishVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodePublishVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodePublishVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodePublishVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodePublishVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodePublishVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodePublishVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodePublishVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodePublishVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.NodePublishVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v0.NodePublishVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.NodePublishVolumeResponse)
        csi.v0.Csi.NodePublishVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_NodePublishVolumeResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_NodePublishVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.NodePublishVolumeResponse.class, csi.v0.Csi.NodePublishVolumeResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.NodePublishVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_NodePublishVolumeResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.NodePublishVolumeResponse getDefaultInstanceForType() {
        return csi.v0.Csi.NodePublishVolumeResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.NodePublishVolumeResponse build() {
        csi.v0.Csi.NodePublishVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.NodePublishVolumeResponse buildPartial() {
        csi.v0.Csi.NodePublishVolumeResponse result = new csi.v0.Csi.NodePublishVolumeResponse(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.NodePublishVolumeResponse) {
          return mergeFrom((csi.v0.Csi.NodePublishVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.NodePublishVolumeResponse other) {
        if (other == csi.v0.Csi.NodePublishVolumeResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.NodePublishVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.NodePublishVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.NodePublishVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.NodePublishVolumeResponse)
    private static final csi.v0.Csi.NodePublishVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.NodePublishVolumeResponse();
    }

    public static csi.v0.Csi.NodePublishVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodePublishVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<NodePublishVolumeResponse>() {
      @java.lang.Override
      public NodePublishVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodePublishVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodePublishVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodePublishVolumeResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.NodePublishVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeUnpublishVolumeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.NodeUnpublishVolumeRequest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    java.lang.String getVolumeId();
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getVolumeIdBytes();

    /**
     * <pre>
     * The path at which the volume was published. It MUST be an absolute
     * path in the root filesystem of the process serving this request.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string target_path = 2;</code>
     */
    java.lang.String getTargetPath();
    /**
     * <pre>
     * The path at which the volume was published. It MUST be an absolute
     * path in the root filesystem of the process serving this request.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string target_path = 2;</code>
     */
    com.google.protobuf.ByteString
        getTargetPathBytes();
  }
  /**
   * Protobuf type {@code csi.v0.NodeUnpublishVolumeRequest}
   */
  public  static final class NodeUnpublishVolumeRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.NodeUnpublishVolumeRequest)
      NodeUnpublishVolumeRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeUnpublishVolumeRequest.newBuilder() to construct.
    private NodeUnpublishVolumeRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeUnpublishVolumeRequest() {
      volumeId_ = "";
      targetPath_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeUnpublishVolumeRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              volumeId_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              targetPath_ = s;
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_NodeUnpublishVolumeRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_NodeUnpublishVolumeRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.NodeUnpublishVolumeRequest.class, csi.v0.Csi.NodeUnpublishVolumeRequest.Builder.class);
    }

    public static final int VOLUME_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object volumeId_;
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public java.lang.String getVolumeId() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        volumeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the volume. This field is REQUIRED.
     * </pre>
     *
     * <code>string volume_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getVolumeIdBytes() {
      java.lang.Object ref = volumeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        volumeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TARGET_PATH_FIELD_NUMBER = 2;
    private volatile java.lang.Object targetPath_;
    /**
     * <pre>
     * The path at which the volume was published. It MUST be an absolute
     * path in the root filesystem of the process serving this request.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string target_path = 2;</code>
     */
    public java.lang.String getTargetPath() {
      java.lang.Object ref = targetPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        targetPath_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The path at which the volume was published. It MUST be an absolute
     * path in the root filesystem of the process serving this request.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string target_path = 2;</code>
     */
    public com.google.protobuf.ByteString
        getTargetPathBytes() {
      java.lang.Object ref = targetPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        targetPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getVolumeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, volumeId_);
      }
      if (!getTargetPathBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, targetPath_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getVolumeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, volumeId_);
      }
      if (!getTargetPathBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, targetPath_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.NodeUnpublishVolumeRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.NodeUnpublishVolumeRequest other = (csi.v0.Csi.NodeUnpublishVolumeRequest) obj;

      boolean result = true;
      result = result && getVolumeId()
          .equals(other.getVolumeId());
      result = result && getTargetPath()
          .equals(other.getTargetPath());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + VOLUME_ID_FIELD_NUMBER;
      hash = (53 * hash) + getVolumeId().hashCode();
      hash = (37 * hash) + TARGET_PATH_FIELD_NUMBER;
      hash = (53 * hash) + getTargetPath().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.NodeUnpublishVolumeRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.NodeUnpublishVolumeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.NodeUnpublishVolumeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.NodeUnpublishVolumeRequest)
        csi.v0.Csi.NodeUnpublishVolumeRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_NodeUnpublishVolumeRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_NodeUnpublishVolumeRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.NodeUnpublishVolumeRequest.class, csi.v0.Csi.NodeUnpublishVolumeRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.NodeUnpublishVolumeRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        volumeId_ = "";

        targetPath_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_NodeUnpublishVolumeRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeUnpublishVolumeRequest getDefaultInstanceForType() {
        return csi.v0.Csi.NodeUnpublishVolumeRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.NodeUnpublishVolumeRequest build() {
        csi.v0.Csi.NodeUnpublishVolumeRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeUnpublishVolumeRequest buildPartial() {
        csi.v0.Csi.NodeUnpublishVolumeRequest result = new csi.v0.Csi.NodeUnpublishVolumeRequest(this);
        result.volumeId_ = volumeId_;
        result.targetPath_ = targetPath_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.NodeUnpublishVolumeRequest) {
          return mergeFrom((csi.v0.Csi.NodeUnpublishVolumeRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.NodeUnpublishVolumeRequest other) {
        if (other == csi.v0.Csi.NodeUnpublishVolumeRequest.getDefaultInstance()) return this;
        if (!other.getVolumeId().isEmpty()) {
          volumeId_ = other.volumeId_;
          onChanged();
        }
        if (!other.getTargetPath().isEmpty()) {
          targetPath_ = other.targetPath_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.NodeUnpublishVolumeRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.NodeUnpublishVolumeRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object volumeId_ = "";
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public java.lang.String getVolumeId() {
        java.lang.Object ref = volumeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          volumeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getVolumeIdBytes() {
        java.lang.Object ref = volumeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          volumeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        volumeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder clearVolumeId() {
        
        volumeId_ = getDefaultInstance().getVolumeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the volume. This field is REQUIRED.
       * </pre>
       *
       * <code>string volume_id = 1;</code>
       */
      public Builder setVolumeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        volumeId_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object targetPath_ = "";
      /**
       * <pre>
       * The path at which the volume was published. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 2;</code>
       */
      public java.lang.String getTargetPath() {
        java.lang.Object ref = targetPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          targetPath_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The path at which the volume was published. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 2;</code>
       */
      public com.google.protobuf.ByteString
          getTargetPathBytes() {
        java.lang.Object ref = targetPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          targetPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path at which the volume was published. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 2;</code>
       */
      public Builder setTargetPath(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        targetPath_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path at which the volume was published. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 2;</code>
       */
      public Builder clearTargetPath() {
        
        targetPath_ = getDefaultInstance().getTargetPath();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path at which the volume was published. It MUST be an absolute
       * path in the root filesystem of the process serving this request.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string target_path = 2;</code>
       */
      public Builder setTargetPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        targetPath_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.NodeUnpublishVolumeRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.NodeUnpublishVolumeRequest)
    private static final csi.v0.Csi.NodeUnpublishVolumeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.NodeUnpublishVolumeRequest();
    }

    public static csi.v0.Csi.NodeUnpublishVolumeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeUnpublishVolumeRequest>
        PARSER = new com.google.protobuf.AbstractParser<NodeUnpublishVolumeRequest>() {
      @java.lang.Override
      public NodeUnpublishVolumeRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeUnpublishVolumeRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeUnpublishVolumeRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeUnpublishVolumeRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.NodeUnpublishVolumeRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeUnpublishVolumeResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.NodeUnpublishVolumeResponse)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v0.NodeUnpublishVolumeResponse}
   */
  public  static final class NodeUnpublishVolumeResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.NodeUnpublishVolumeResponse)
      NodeUnpublishVolumeResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeUnpublishVolumeResponse.newBuilder() to construct.
    private NodeUnpublishVolumeResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeUnpublishVolumeResponse() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeUnpublishVolumeResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_NodeUnpublishVolumeResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_NodeUnpublishVolumeResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.NodeUnpublishVolumeResponse.class, csi.v0.Csi.NodeUnpublishVolumeResponse.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.NodeUnpublishVolumeResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.NodeUnpublishVolumeResponse other = (csi.v0.Csi.NodeUnpublishVolumeResponse) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.NodeUnpublishVolumeResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeUnpublishVolumeResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.NodeUnpublishVolumeResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v0.NodeUnpublishVolumeResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.NodeUnpublishVolumeResponse)
        csi.v0.Csi.NodeUnpublishVolumeResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_NodeUnpublishVolumeResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_NodeUnpublishVolumeResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.NodeUnpublishVolumeResponse.class, csi.v0.Csi.NodeUnpublishVolumeResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.NodeUnpublishVolumeResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_NodeUnpublishVolumeResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeUnpublishVolumeResponse getDefaultInstanceForType() {
        return csi.v0.Csi.NodeUnpublishVolumeResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.NodeUnpublishVolumeResponse build() {
        csi.v0.Csi.NodeUnpublishVolumeResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeUnpublishVolumeResponse buildPartial() {
        csi.v0.Csi.NodeUnpublishVolumeResponse result = new csi.v0.Csi.NodeUnpublishVolumeResponse(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.NodeUnpublishVolumeResponse) {
          return mergeFrom((csi.v0.Csi.NodeUnpublishVolumeResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.NodeUnpublishVolumeResponse other) {
        if (other == csi.v0.Csi.NodeUnpublishVolumeResponse.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.NodeUnpublishVolumeResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.NodeUnpublishVolumeResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.NodeUnpublishVolumeResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.NodeUnpublishVolumeResponse)
    private static final csi.v0.Csi.NodeUnpublishVolumeResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.NodeUnpublishVolumeResponse();
    }

    public static csi.v0.Csi.NodeUnpublishVolumeResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeUnpublishVolumeResponse>
        PARSER = new com.google.protobuf.AbstractParser<NodeUnpublishVolumeResponse>() {
      @java.lang.Override
      public NodeUnpublishVolumeResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeUnpublishVolumeResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeUnpublishVolumeResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeUnpublishVolumeResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.NodeUnpublishVolumeResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeGetIdRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.NodeGetIdRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v0.NodeGetIdRequest}
   */
  public  static final class NodeGetIdRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.NodeGetIdRequest)
      NodeGetIdRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeGetIdRequest.newBuilder() to construct.
    private NodeGetIdRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeGetIdRequest() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeGetIdRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_NodeGetIdRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_NodeGetIdRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.NodeGetIdRequest.class, csi.v0.Csi.NodeGetIdRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.NodeGetIdRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.NodeGetIdRequest other = (csi.v0.Csi.NodeGetIdRequest) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.NodeGetIdRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetIdRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetIdRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetIdRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetIdRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetIdRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetIdRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetIdRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetIdRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetIdRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetIdRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetIdRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.NodeGetIdRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v0.NodeGetIdRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.NodeGetIdRequest)
        csi.v0.Csi.NodeGetIdRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetIdRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetIdRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.NodeGetIdRequest.class, csi.v0.Csi.NodeGetIdRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.NodeGetIdRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetIdRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetIdRequest getDefaultInstanceForType() {
        return csi.v0.Csi.NodeGetIdRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetIdRequest build() {
        csi.v0.Csi.NodeGetIdRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetIdRequest buildPartial() {
        csi.v0.Csi.NodeGetIdRequest result = new csi.v0.Csi.NodeGetIdRequest(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.NodeGetIdRequest) {
          return mergeFrom((csi.v0.Csi.NodeGetIdRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.NodeGetIdRequest other) {
        if (other == csi.v0.Csi.NodeGetIdRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.NodeGetIdRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.NodeGetIdRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.NodeGetIdRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.NodeGetIdRequest)
    private static final csi.v0.Csi.NodeGetIdRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.NodeGetIdRequest();
    }

    public static csi.v0.Csi.NodeGetIdRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeGetIdRequest>
        PARSER = new com.google.protobuf.AbstractParser<NodeGetIdRequest>() {
      @java.lang.Override
      public NodeGetIdRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeGetIdRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeGetIdRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeGetIdRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.NodeGetIdRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeGetIdResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.NodeGetIdResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the node as understood by the SP which SHALL be used by
     * CO in subsequent `ControllerPublishVolume`.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     */
    java.lang.String getNodeId();
    /**
     * <pre>
     * The ID of the node as understood by the SP which SHALL be used by
     * CO in subsequent `ControllerPublishVolume`.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getNodeIdBytes();
  }
  /**
   * Protobuf type {@code csi.v0.NodeGetIdResponse}
   */
  public  static final class NodeGetIdResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.NodeGetIdResponse)
      NodeGetIdResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeGetIdResponse.newBuilder() to construct.
    private NodeGetIdResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeGetIdResponse() {
      nodeId_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeGetIdResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              nodeId_ = s;
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_NodeGetIdResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_NodeGetIdResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.NodeGetIdResponse.class, csi.v0.Csi.NodeGetIdResponse.Builder.class);
    }

    public static final int NODE_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object nodeId_;
    /**
     * <pre>
     * The ID of the node as understood by the SP which SHALL be used by
     * CO in subsequent `ControllerPublishVolume`.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     */
    public java.lang.String getNodeId() {
      java.lang.Object ref = nodeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        nodeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the node as understood by the SP which SHALL be used by
     * CO in subsequent `ControllerPublishVolume`.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNodeIdBytes() {
      java.lang.Object ref = nodeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nodeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getNodeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, nodeId_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNodeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, nodeId_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.NodeGetIdResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.NodeGetIdResponse other = (csi.v0.Csi.NodeGetIdResponse) obj;

      boolean result = true;
      result = result && getNodeId()
          .equals(other.getNodeId());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NODE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getNodeId().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.NodeGetIdResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetIdResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetIdResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetIdResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetIdResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetIdResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetIdResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetIdResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetIdResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetIdResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetIdResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetIdResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.NodeGetIdResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.NodeGetIdResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.NodeGetIdResponse)
        csi.v0.Csi.NodeGetIdResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetIdResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetIdResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.NodeGetIdResponse.class, csi.v0.Csi.NodeGetIdResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.NodeGetIdResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        nodeId_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetIdResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetIdResponse getDefaultInstanceForType() {
        return csi.v0.Csi.NodeGetIdResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetIdResponse build() {
        csi.v0.Csi.NodeGetIdResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetIdResponse buildPartial() {
        csi.v0.Csi.NodeGetIdResponse result = new csi.v0.Csi.NodeGetIdResponse(this);
        result.nodeId_ = nodeId_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.NodeGetIdResponse) {
          return mergeFrom((csi.v0.Csi.NodeGetIdResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.NodeGetIdResponse other) {
        if (other == csi.v0.Csi.NodeGetIdResponse.getDefaultInstance()) return this;
        if (!other.getNodeId().isEmpty()) {
          nodeId_ = other.nodeId_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.NodeGetIdResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.NodeGetIdResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object nodeId_ = "";
      /**
       * <pre>
       * The ID of the node as understood by the SP which SHALL be used by
       * CO in subsequent `ControllerPublishVolume`.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       */
      public java.lang.String getNodeId() {
        java.lang.Object ref = nodeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          nodeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the node as understood by the SP which SHALL be used by
       * CO in subsequent `ControllerPublishVolume`.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNodeIdBytes() {
        java.lang.Object ref = nodeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nodeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the node as understood by the SP which SHALL be used by
       * CO in subsequent `ControllerPublishVolume`.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       */
      public Builder setNodeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        nodeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the node as understood by the SP which SHALL be used by
       * CO in subsequent `ControllerPublishVolume`.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       */
      public Builder clearNodeId() {
        
        nodeId_ = getDefaultInstance().getNodeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the node as understood by the SP which SHALL be used by
       * CO in subsequent `ControllerPublishVolume`.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       */
      public Builder setNodeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        nodeId_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.NodeGetIdResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.NodeGetIdResponse)
    private static final csi.v0.Csi.NodeGetIdResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.NodeGetIdResponse();
    }

    public static csi.v0.Csi.NodeGetIdResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeGetIdResponse>
        PARSER = new com.google.protobuf.AbstractParser<NodeGetIdResponse>() {
      @java.lang.Override
      public NodeGetIdResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeGetIdResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeGetIdResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeGetIdResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.NodeGetIdResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeGetCapabilitiesRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.NodeGetCapabilitiesRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * Intentionally empty.
   * </pre>
   *
   * Protobuf type {@code csi.v0.NodeGetCapabilitiesRequest}
   */
  public  static final class NodeGetCapabilitiesRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.NodeGetCapabilitiesRequest)
      NodeGetCapabilitiesRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeGetCapabilitiesRequest.newBuilder() to construct.
    private NodeGetCapabilitiesRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeGetCapabilitiesRequest() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeGetCapabilitiesRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_NodeGetCapabilitiesRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_NodeGetCapabilitiesRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.NodeGetCapabilitiesRequest.class, csi.v0.Csi.NodeGetCapabilitiesRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.NodeGetCapabilitiesRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.NodeGetCapabilitiesRequest other = (csi.v0.Csi.NodeGetCapabilitiesRequest) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.NodeGetCapabilitiesRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.NodeGetCapabilitiesRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Intentionally empty.
     * </pre>
     *
     * Protobuf type {@code csi.v0.NodeGetCapabilitiesRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.NodeGetCapabilitiesRequest)
        csi.v0.Csi.NodeGetCapabilitiesRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetCapabilitiesRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetCapabilitiesRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.NodeGetCapabilitiesRequest.class, csi.v0.Csi.NodeGetCapabilitiesRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.NodeGetCapabilitiesRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetCapabilitiesRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetCapabilitiesRequest getDefaultInstanceForType() {
        return csi.v0.Csi.NodeGetCapabilitiesRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetCapabilitiesRequest build() {
        csi.v0.Csi.NodeGetCapabilitiesRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetCapabilitiesRequest buildPartial() {
        csi.v0.Csi.NodeGetCapabilitiesRequest result = new csi.v0.Csi.NodeGetCapabilitiesRequest(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.NodeGetCapabilitiesRequest) {
          return mergeFrom((csi.v0.Csi.NodeGetCapabilitiesRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.NodeGetCapabilitiesRequest other) {
        if (other == csi.v0.Csi.NodeGetCapabilitiesRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.NodeGetCapabilitiesRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.NodeGetCapabilitiesRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.NodeGetCapabilitiesRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.NodeGetCapabilitiesRequest)
    private static final csi.v0.Csi.NodeGetCapabilitiesRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.NodeGetCapabilitiesRequest();
    }

    public static csi.v0.Csi.NodeGetCapabilitiesRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeGetCapabilitiesRequest>
        PARSER = new com.google.protobuf.AbstractParser<NodeGetCapabilitiesRequest>() {
      @java.lang.Override
      public NodeGetCapabilitiesRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeGetCapabilitiesRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeGetCapabilitiesRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeGetCapabilitiesRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.NodeGetCapabilitiesRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeGetCapabilitiesResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.NodeGetCapabilitiesResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
     */
    java.util.List<csi.v0.Csi.NodeServiceCapability> 
        getCapabilitiesList();
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
     */
    csi.v0.Csi.NodeServiceCapability getCapabilities(int index);
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
     */
    int getCapabilitiesCount();
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
     */
    java.util.List<? extends csi.v0.Csi.NodeServiceCapabilityOrBuilder> 
        getCapabilitiesOrBuilderList();
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
     */
    csi.v0.Csi.NodeServiceCapabilityOrBuilder getCapabilitiesOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code csi.v0.NodeGetCapabilitiesResponse}
   */
  public  static final class NodeGetCapabilitiesResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.NodeGetCapabilitiesResponse)
      NodeGetCapabilitiesResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeGetCapabilitiesResponse.newBuilder() to construct.
    private NodeGetCapabilitiesResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeGetCapabilitiesResponse() {
      capabilities_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeGetCapabilitiesResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                capabilities_ = new java.util.ArrayList<csi.v0.Csi.NodeServiceCapability>();
                mutable_bitField0_ |= 0x00000001;
              }
              capabilities_.add(
                  input.readMessage(csi.v0.Csi.NodeServiceCapability.parser(), extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          capabilities_ = java.util.Collections.unmodifiableList(capabilities_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_NodeGetCapabilitiesResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_NodeGetCapabilitiesResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.NodeGetCapabilitiesResponse.class, csi.v0.Csi.NodeGetCapabilitiesResponse.Builder.class);
    }

    public static final int CAPABILITIES_FIELD_NUMBER = 1;
    private java.util.List<csi.v0.Csi.NodeServiceCapability> capabilities_;
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
     */
    public java.util.List<csi.v0.Csi.NodeServiceCapability> getCapabilitiesList() {
      return capabilities_;
    }
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
     */
    public java.util.List<? extends csi.v0.Csi.NodeServiceCapabilityOrBuilder> 
        getCapabilitiesOrBuilderList() {
      return capabilities_;
    }
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
     */
    public int getCapabilitiesCount() {
      return capabilities_.size();
    }
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
     */
    public csi.v0.Csi.NodeServiceCapability getCapabilities(int index) {
      return capabilities_.get(index);
    }
    /**
     * <pre>
     * All the capabilities that the node service supports. This field
     * is OPTIONAL.
     * </pre>
     *
     * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
     */
    public csi.v0.Csi.NodeServiceCapabilityOrBuilder getCapabilitiesOrBuilder(
        int index) {
      return capabilities_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < capabilities_.size(); i++) {
        output.writeMessage(1, capabilities_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < capabilities_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, capabilities_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.NodeGetCapabilitiesResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.NodeGetCapabilitiesResponse other = (csi.v0.Csi.NodeGetCapabilitiesResponse) obj;

      boolean result = true;
      result = result && getCapabilitiesList()
          .equals(other.getCapabilitiesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getCapabilitiesCount() > 0) {
        hash = (37 * hash) + CAPABILITIES_FIELD_NUMBER;
        hash = (53 * hash) + getCapabilitiesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.NodeGetCapabilitiesResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetCapabilitiesResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.NodeGetCapabilitiesResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.NodeGetCapabilitiesResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.NodeGetCapabilitiesResponse)
        csi.v0.Csi.NodeGetCapabilitiesResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetCapabilitiesResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetCapabilitiesResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.NodeGetCapabilitiesResponse.class, csi.v0.Csi.NodeGetCapabilitiesResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.NodeGetCapabilitiesResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getCapabilitiesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (capabilitiesBuilder_ == null) {
          capabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          capabilitiesBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetCapabilitiesResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetCapabilitiesResponse getDefaultInstanceForType() {
        return csi.v0.Csi.NodeGetCapabilitiesResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetCapabilitiesResponse build() {
        csi.v0.Csi.NodeGetCapabilitiesResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetCapabilitiesResponse buildPartial() {
        csi.v0.Csi.NodeGetCapabilitiesResponse result = new csi.v0.Csi.NodeGetCapabilitiesResponse(this);
        int from_bitField0_ = bitField0_;
        if (capabilitiesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            capabilities_ = java.util.Collections.unmodifiableList(capabilities_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.capabilities_ = capabilities_;
        } else {
          result.capabilities_ = capabilitiesBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.NodeGetCapabilitiesResponse) {
          return mergeFrom((csi.v0.Csi.NodeGetCapabilitiesResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.NodeGetCapabilitiesResponse other) {
        if (other == csi.v0.Csi.NodeGetCapabilitiesResponse.getDefaultInstance()) return this;
        if (capabilitiesBuilder_ == null) {
          if (!other.capabilities_.isEmpty()) {
            if (capabilities_.isEmpty()) {
              capabilities_ = other.capabilities_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureCapabilitiesIsMutable();
              capabilities_.addAll(other.capabilities_);
            }
            onChanged();
          }
        } else {
          if (!other.capabilities_.isEmpty()) {
            if (capabilitiesBuilder_.isEmpty()) {
              capabilitiesBuilder_.dispose();
              capabilitiesBuilder_ = null;
              capabilities_ = other.capabilities_;
              bitField0_ = (bitField0_ & ~0x00000001);
              capabilitiesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getCapabilitiesFieldBuilder() : null;
            } else {
              capabilitiesBuilder_.addAllMessages(other.capabilities_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.NodeGetCapabilitiesResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.NodeGetCapabilitiesResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<csi.v0.Csi.NodeServiceCapability> capabilities_ =
        java.util.Collections.emptyList();
      private void ensureCapabilitiesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          capabilities_ = new java.util.ArrayList<csi.v0.Csi.NodeServiceCapability>(capabilities_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.NodeServiceCapability, csi.v0.Csi.NodeServiceCapability.Builder, csi.v0.Csi.NodeServiceCapabilityOrBuilder> capabilitiesBuilder_;

      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public java.util.List<csi.v0.Csi.NodeServiceCapability> getCapabilitiesList() {
        if (capabilitiesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(capabilities_);
        } else {
          return capabilitiesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public int getCapabilitiesCount() {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.size();
        } else {
          return capabilitiesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public csi.v0.Csi.NodeServiceCapability getCapabilities(int index) {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.get(index);
        } else {
          return capabilitiesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder setCapabilities(
          int index, csi.v0.Csi.NodeServiceCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.set(index, value);
          onChanged();
        } else {
          capabilitiesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder setCapabilities(
          int index, csi.v0.Csi.NodeServiceCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.set(index, builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder addCapabilities(csi.v0.Csi.NodeServiceCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.add(value);
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder addCapabilities(
          int index, csi.v0.Csi.NodeServiceCapability value) {
        if (capabilitiesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCapabilitiesIsMutable();
          capabilities_.add(index, value);
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder addCapabilities(
          csi.v0.Csi.NodeServiceCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.add(builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder addCapabilities(
          int index, csi.v0.Csi.NodeServiceCapability.Builder builderForValue) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.add(index, builderForValue.build());
          onChanged();
        } else {
          capabilitiesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder addAllCapabilities(
          java.lang.Iterable<? extends csi.v0.Csi.NodeServiceCapability> values) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, capabilities_);
          onChanged();
        } else {
          capabilitiesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder clearCapabilities() {
        if (capabilitiesBuilder_ == null) {
          capabilities_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          capabilitiesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public Builder removeCapabilities(int index) {
        if (capabilitiesBuilder_ == null) {
          ensureCapabilitiesIsMutable();
          capabilities_.remove(index);
          onChanged();
        } else {
          capabilitiesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public csi.v0.Csi.NodeServiceCapability.Builder getCapabilitiesBuilder(
          int index) {
        return getCapabilitiesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public csi.v0.Csi.NodeServiceCapabilityOrBuilder getCapabilitiesOrBuilder(
          int index) {
        if (capabilitiesBuilder_ == null) {
          return capabilities_.get(index);  } else {
          return capabilitiesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public java.util.List<? extends csi.v0.Csi.NodeServiceCapabilityOrBuilder> 
           getCapabilitiesOrBuilderList() {
        if (capabilitiesBuilder_ != null) {
          return capabilitiesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(capabilities_);
        }
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public csi.v0.Csi.NodeServiceCapability.Builder addCapabilitiesBuilder() {
        return getCapabilitiesFieldBuilder().addBuilder(
            csi.v0.Csi.NodeServiceCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public csi.v0.Csi.NodeServiceCapability.Builder addCapabilitiesBuilder(
          int index) {
        return getCapabilitiesFieldBuilder().addBuilder(
            index, csi.v0.Csi.NodeServiceCapability.getDefaultInstance());
      }
      /**
       * <pre>
       * All the capabilities that the node service supports. This field
       * is OPTIONAL.
       * </pre>
       *
       * <code>repeated .csi.v0.NodeServiceCapability capabilities = 1;</code>
       */
      public java.util.List<csi.v0.Csi.NodeServiceCapability.Builder> 
           getCapabilitiesBuilderList() {
        return getCapabilitiesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          csi.v0.Csi.NodeServiceCapability, csi.v0.Csi.NodeServiceCapability.Builder, csi.v0.Csi.NodeServiceCapabilityOrBuilder> 
          getCapabilitiesFieldBuilder() {
        if (capabilitiesBuilder_ == null) {
          capabilitiesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              csi.v0.Csi.NodeServiceCapability, csi.v0.Csi.NodeServiceCapability.Builder, csi.v0.Csi.NodeServiceCapabilityOrBuilder>(
                  capabilities_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          capabilities_ = null;
        }
        return capabilitiesBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.NodeGetCapabilitiesResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.NodeGetCapabilitiesResponse)
    private static final csi.v0.Csi.NodeGetCapabilitiesResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.NodeGetCapabilitiesResponse();
    }

    public static csi.v0.Csi.NodeGetCapabilitiesResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeGetCapabilitiesResponse>
        PARSER = new com.google.protobuf.AbstractParser<NodeGetCapabilitiesResponse>() {
      @java.lang.Override
      public NodeGetCapabilitiesResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeGetCapabilitiesResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeGetCapabilitiesResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeGetCapabilitiesResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.NodeGetCapabilitiesResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeServiceCapabilityOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.NodeServiceCapability)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v0.NodeServiceCapability.RPC rpc = 1;</code>
     */
    boolean hasRpc();
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v0.NodeServiceCapability.RPC rpc = 1;</code>
     */
    csi.v0.Csi.NodeServiceCapability.RPC getRpc();
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v0.NodeServiceCapability.RPC rpc = 1;</code>
     */
    csi.v0.Csi.NodeServiceCapability.RPCOrBuilder getRpcOrBuilder();

    public csi.v0.Csi.NodeServiceCapability.TypeCase getTypeCase();
  }
  /**
   * <pre>
   * Specifies a capability of the node service.
   * </pre>
   *
   * Protobuf type {@code csi.v0.NodeServiceCapability}
   */
  public  static final class NodeServiceCapability extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.NodeServiceCapability)
      NodeServiceCapabilityOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeServiceCapability.newBuilder() to construct.
    private NodeServiceCapability(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeServiceCapability() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeServiceCapability(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              csi.v0.Csi.NodeServiceCapability.RPC.Builder subBuilder = null;
              if (typeCase_ == 1) {
                subBuilder = ((csi.v0.Csi.NodeServiceCapability.RPC) type_).toBuilder();
              }
              type_ =
                  input.readMessage(csi.v0.Csi.NodeServiceCapability.RPC.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((csi.v0.Csi.NodeServiceCapability.RPC) type_);
                type_ = subBuilder.buildPartial();
              }
              typeCase_ = 1;
              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_NodeServiceCapability_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_NodeServiceCapability_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.NodeServiceCapability.class, csi.v0.Csi.NodeServiceCapability.Builder.class);
    }

    public interface RPCOrBuilder extends
        // @@protoc_insertion_point(interface_extends:csi.v0.NodeServiceCapability.RPC)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>.csi.v0.NodeServiceCapability.RPC.Type type = 1;</code>
       */
      int getTypeValue();
      /**
       * <code>.csi.v0.NodeServiceCapability.RPC.Type type = 1;</code>
       */
      csi.v0.Csi.NodeServiceCapability.RPC.Type getType();
    }
    /**
     * Protobuf type {@code csi.v0.NodeServiceCapability.RPC}
     */
    public  static final class RPC extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:csi.v0.NodeServiceCapability.RPC)
        RPCOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use RPC.newBuilder() to construct.
      private RPC(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private RPC() {
        type_ = 0;
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private RPC(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int rawValue = input.readEnum();

                type_ = rawValue;
                break;
              }
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_NodeServiceCapability_RPC_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_NodeServiceCapability_RPC_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.NodeServiceCapability.RPC.class, csi.v0.Csi.NodeServiceCapability.RPC.Builder.class);
      }

      /**
       * Protobuf enum {@code csi.v0.NodeServiceCapability.RPC.Type}
       */
      public enum Type
          implements com.google.protobuf.ProtocolMessageEnum {
        /**
         * <code>UNKNOWN = 0;</code>
         */
        UNKNOWN(0),
        /**
         * <code>STAGE_UNSTAGE_VOLUME = 1;</code>
         */
        STAGE_UNSTAGE_VOLUME(1),
        UNRECOGNIZED(-1),
        ;

        /**
         * <code>UNKNOWN = 0;</code>
         */
        public static final int UNKNOWN_VALUE = 0;
        /**
         * <code>STAGE_UNSTAGE_VOLUME = 1;</code>
         */
        public static final int STAGE_UNSTAGE_VOLUME_VALUE = 1;


        public final int getNumber() {
          if (this == UNRECOGNIZED) {
            throw new java.lang.IllegalArgumentException(
                "Can't get the number of an unknown enum value.");
          }
          return value;
        }

        /**
         * @deprecated Use {@link #forNumber(int)} instead.
         */
        @java.lang.Deprecated
        public static Type valueOf(int value) {
          return forNumber(value);
        }

        public static Type forNumber(int value) {
          switch (value) {
            case 0: return UNKNOWN;
            case 1: return STAGE_UNSTAGE_VOLUME;
            default: return null;
          }
        }

        public static com.google.protobuf.Internal.EnumLiteMap<Type>
            internalGetValueMap() {
          return internalValueMap;
        }
        private static final com.google.protobuf.Internal.EnumLiteMap<
            Type> internalValueMap =
              new com.google.protobuf.Internal.EnumLiteMap<Type>() {
                public Type findValueByNumber(int number) {
                  return Type.forNumber(number);
                }
              };

        public final com.google.protobuf.Descriptors.EnumValueDescriptor
            getValueDescriptor() {
          return getDescriptor().getValues().get(ordinal());
        }
        public final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptorForType() {
          return getDescriptor();
        }
        public static final com.google.protobuf.Descriptors.EnumDescriptor
            getDescriptor() {
          return csi.v0.Csi.NodeServiceCapability.RPC.getDescriptor().getEnumTypes().get(0);
        }

        private static final Type[] VALUES = values();

        public static Type valueOf(
            com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
          if (desc.getType() != getDescriptor()) {
            throw new java.lang.IllegalArgumentException(
              "EnumValueDescriptor is not for this type.");
          }
          if (desc.getIndex() == -1) {
            return UNRECOGNIZED;
          }
          return VALUES[desc.getIndex()];
        }

        private final int value;

        private Type(int value) {
          this.value = value;
        }

        // @@protoc_insertion_point(enum_scope:csi.v0.NodeServiceCapability.RPC.Type)
      }

      public static final int TYPE_FIELD_NUMBER = 1;
      private int type_;
      /**
       * <code>.csi.v0.NodeServiceCapability.RPC.Type type = 1;</code>
       */
      public int getTypeValue() {
        return type_;
      }
      /**
       * <code>.csi.v0.NodeServiceCapability.RPC.Type type = 1;</code>
       */
      public csi.v0.Csi.NodeServiceCapability.RPC.Type getType() {
        @SuppressWarnings("deprecation")
        csi.v0.Csi.NodeServiceCapability.RPC.Type result = csi.v0.Csi.NodeServiceCapability.RPC.Type.valueOf(type_);
        return result == null ? csi.v0.Csi.NodeServiceCapability.RPC.Type.UNRECOGNIZED : result;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (type_ != csi.v0.Csi.NodeServiceCapability.RPC.Type.UNKNOWN.getNumber()) {
          output.writeEnum(1, type_);
        }
        unknownFields.writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (type_ != csi.v0.Csi.NodeServiceCapability.RPC.Type.UNKNOWN.getNumber()) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(1, type_);
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof csi.v0.Csi.NodeServiceCapability.RPC)) {
          return super.equals(obj);
        }
        csi.v0.Csi.NodeServiceCapability.RPC other = (csi.v0.Csi.NodeServiceCapability.RPC) obj;

        boolean result = true;
        result = result && type_ == other.type_;
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static csi.v0.Csi.NodeServiceCapability.RPC parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.NodeServiceCapability.RPC parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.NodeServiceCapability.RPC parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.NodeServiceCapability.RPC parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.NodeServiceCapability.RPC parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static csi.v0.Csi.NodeServiceCapability.RPC parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static csi.v0.Csi.NodeServiceCapability.RPC parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.NodeServiceCapability.RPC parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.NodeServiceCapability.RPC parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.NodeServiceCapability.RPC parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static csi.v0.Csi.NodeServiceCapability.RPC parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static csi.v0.Csi.NodeServiceCapability.RPC parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(csi.v0.Csi.NodeServiceCapability.RPC prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code csi.v0.NodeServiceCapability.RPC}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:csi.v0.NodeServiceCapability.RPC)
          csi.v0.Csi.NodeServiceCapability.RPCOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return csi.v0.Csi.internal_static_csi_v0_NodeServiceCapability_RPC_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return csi.v0.Csi.internal_static_csi_v0_NodeServiceCapability_RPC_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  csi.v0.Csi.NodeServiceCapability.RPC.class, csi.v0.Csi.NodeServiceCapability.RPC.Builder.class);
        }

        // Construct using csi.v0.Csi.NodeServiceCapability.RPC.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          type_ = 0;

          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return csi.v0.Csi.internal_static_csi_v0_NodeServiceCapability_RPC_descriptor;
        }

        @java.lang.Override
        public csi.v0.Csi.NodeServiceCapability.RPC getDefaultInstanceForType() {
          return csi.v0.Csi.NodeServiceCapability.RPC.getDefaultInstance();
        }

        @java.lang.Override
        public csi.v0.Csi.NodeServiceCapability.RPC build() {
          csi.v0.Csi.NodeServiceCapability.RPC result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public csi.v0.Csi.NodeServiceCapability.RPC buildPartial() {
          csi.v0.Csi.NodeServiceCapability.RPC result = new csi.v0.Csi.NodeServiceCapability.RPC(this);
          result.type_ = type_;
          onBuilt();
          return result;
        }

        @java.lang.Override
        public Builder clone() {
          return (Builder) super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof csi.v0.Csi.NodeServiceCapability.RPC) {
            return mergeFrom((csi.v0.Csi.NodeServiceCapability.RPC)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(csi.v0.Csi.NodeServiceCapability.RPC other) {
          if (other == csi.v0.Csi.NodeServiceCapability.RPC.getDefaultInstance()) return this;
          if (other.type_ != 0) {
            setTypeValue(other.getTypeValue());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          csi.v0.Csi.NodeServiceCapability.RPC parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (csi.v0.Csi.NodeServiceCapability.RPC) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private int type_ = 0;
        /**
         * <code>.csi.v0.NodeServiceCapability.RPC.Type type = 1;</code>
         */
        public int getTypeValue() {
          return type_;
        }
        /**
         * <code>.csi.v0.NodeServiceCapability.RPC.Type type = 1;</code>
         */
        public Builder setTypeValue(int value) {
          type_ = value;
          onChanged();
          return this;
        }
        /**
         * <code>.csi.v0.NodeServiceCapability.RPC.Type type = 1;</code>
         */
        public csi.v0.Csi.NodeServiceCapability.RPC.Type getType() {
          @SuppressWarnings("deprecation")
          csi.v0.Csi.NodeServiceCapability.RPC.Type result = csi.v0.Csi.NodeServiceCapability.RPC.Type.valueOf(type_);
          return result == null ? csi.v0.Csi.NodeServiceCapability.RPC.Type.UNRECOGNIZED : result;
        }
        /**
         * <code>.csi.v0.NodeServiceCapability.RPC.Type type = 1;</code>
         */
        public Builder setType(csi.v0.Csi.NodeServiceCapability.RPC.Type value) {
          if (value == null) {
            throw new NullPointerException();
          }
          
          type_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <code>.csi.v0.NodeServiceCapability.RPC.Type type = 1;</code>
         */
        public Builder clearType() {
          
          type_ = 0;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:csi.v0.NodeServiceCapability.RPC)
      }

      // @@protoc_insertion_point(class_scope:csi.v0.NodeServiceCapability.RPC)
      private static final csi.v0.Csi.NodeServiceCapability.RPC DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new csi.v0.Csi.NodeServiceCapability.RPC();
      }

      public static csi.v0.Csi.NodeServiceCapability.RPC getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<RPC>
          PARSER = new com.google.protobuf.AbstractParser<RPC>() {
        @java.lang.Override
        public RPC parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new RPC(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<RPC> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<RPC> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeServiceCapability.RPC getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int typeCase_ = 0;
    private java.lang.Object type_;
    public enum TypeCase
        implements com.google.protobuf.Internal.EnumLite {
      RPC(1),
      TYPE_NOT_SET(0);
      private final int value;
      private TypeCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TypeCase valueOf(int value) {
        return forNumber(value);
      }

      public static TypeCase forNumber(int value) {
        switch (value) {
          case 1: return RPC;
          case 0: return TYPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public TypeCase
    getTypeCase() {
      return TypeCase.forNumber(
          typeCase_);
    }

    public static final int RPC_FIELD_NUMBER = 1;
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v0.NodeServiceCapability.RPC rpc = 1;</code>
     */
    public boolean hasRpc() {
      return typeCase_ == 1;
    }
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v0.NodeServiceCapability.RPC rpc = 1;</code>
     */
    public csi.v0.Csi.NodeServiceCapability.RPC getRpc() {
      if (typeCase_ == 1) {
         return (csi.v0.Csi.NodeServiceCapability.RPC) type_;
      }
      return csi.v0.Csi.NodeServiceCapability.RPC.getDefaultInstance();
    }
    /**
     * <pre>
     * RPC that the controller supports.
     * </pre>
     *
     * <code>.csi.v0.NodeServiceCapability.RPC rpc = 1;</code>
     */
    public csi.v0.Csi.NodeServiceCapability.RPCOrBuilder getRpcOrBuilder() {
      if (typeCase_ == 1) {
         return (csi.v0.Csi.NodeServiceCapability.RPC) type_;
      }
      return csi.v0.Csi.NodeServiceCapability.RPC.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (typeCase_ == 1) {
        output.writeMessage(1, (csi.v0.Csi.NodeServiceCapability.RPC) type_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (typeCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, (csi.v0.Csi.NodeServiceCapability.RPC) type_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.NodeServiceCapability)) {
        return super.equals(obj);
      }
      csi.v0.Csi.NodeServiceCapability other = (csi.v0.Csi.NodeServiceCapability) obj;

      boolean result = true;
      result = result && getTypeCase().equals(
          other.getTypeCase());
      if (!result) return false;
      switch (typeCase_) {
        case 1:
          result = result && getRpc()
              .equals(other.getRpc());
          break;
        case 0:
        default:
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      switch (typeCase_) {
        case 1:
          hash = (37 * hash) + RPC_FIELD_NUMBER;
          hash = (53 * hash) + getRpc().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.NodeServiceCapability parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeServiceCapability parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeServiceCapability parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeServiceCapability parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeServiceCapability parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeServiceCapability parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeServiceCapability parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeServiceCapability parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeServiceCapability parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeServiceCapability parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeServiceCapability parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeServiceCapability parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.NodeServiceCapability prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Specifies a capability of the node service.
     * </pre>
     *
     * Protobuf type {@code csi.v0.NodeServiceCapability}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.NodeServiceCapability)
        csi.v0.Csi.NodeServiceCapabilityOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_NodeServiceCapability_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_NodeServiceCapability_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.NodeServiceCapability.class, csi.v0.Csi.NodeServiceCapability.Builder.class);
      }

      // Construct using csi.v0.Csi.NodeServiceCapability.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        typeCase_ = 0;
        type_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_NodeServiceCapability_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeServiceCapability getDefaultInstanceForType() {
        return csi.v0.Csi.NodeServiceCapability.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.NodeServiceCapability build() {
        csi.v0.Csi.NodeServiceCapability result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeServiceCapability buildPartial() {
        csi.v0.Csi.NodeServiceCapability result = new csi.v0.Csi.NodeServiceCapability(this);
        if (typeCase_ == 1) {
          if (rpcBuilder_ == null) {
            result.type_ = type_;
          } else {
            result.type_ = rpcBuilder_.build();
          }
        }
        result.typeCase_ = typeCase_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.NodeServiceCapability) {
          return mergeFrom((csi.v0.Csi.NodeServiceCapability)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.NodeServiceCapability other) {
        if (other == csi.v0.Csi.NodeServiceCapability.getDefaultInstance()) return this;
        switch (other.getTypeCase()) {
          case RPC: {
            mergeRpc(other.getRpc());
            break;
          }
          case TYPE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.NodeServiceCapability parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.NodeServiceCapability) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int typeCase_ = 0;
      private java.lang.Object type_;
      public TypeCase
          getTypeCase() {
        return TypeCase.forNumber(
            typeCase_);
      }

      public Builder clearType() {
        typeCase_ = 0;
        type_ = null;
        onChanged();
        return this;
      }


      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.NodeServiceCapability.RPC, csi.v0.Csi.NodeServiceCapability.RPC.Builder, csi.v0.Csi.NodeServiceCapability.RPCOrBuilder> rpcBuilder_;
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.NodeServiceCapability.RPC rpc = 1;</code>
       */
      public boolean hasRpc() {
        return typeCase_ == 1;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.NodeServiceCapability.RPC rpc = 1;</code>
       */
      public csi.v0.Csi.NodeServiceCapability.RPC getRpc() {
        if (rpcBuilder_ == null) {
          if (typeCase_ == 1) {
            return (csi.v0.Csi.NodeServiceCapability.RPC) type_;
          }
          return csi.v0.Csi.NodeServiceCapability.RPC.getDefaultInstance();
        } else {
          if (typeCase_ == 1) {
            return rpcBuilder_.getMessage();
          }
          return csi.v0.Csi.NodeServiceCapability.RPC.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.NodeServiceCapability.RPC rpc = 1;</code>
       */
      public Builder setRpc(csi.v0.Csi.NodeServiceCapability.RPC value) {
        if (rpcBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          type_ = value;
          onChanged();
        } else {
          rpcBuilder_.setMessage(value);
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.NodeServiceCapability.RPC rpc = 1;</code>
       */
      public Builder setRpc(
          csi.v0.Csi.NodeServiceCapability.RPC.Builder builderForValue) {
        if (rpcBuilder_ == null) {
          type_ = builderForValue.build();
          onChanged();
        } else {
          rpcBuilder_.setMessage(builderForValue.build());
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.NodeServiceCapability.RPC rpc = 1;</code>
       */
      public Builder mergeRpc(csi.v0.Csi.NodeServiceCapability.RPC value) {
        if (rpcBuilder_ == null) {
          if (typeCase_ == 1 &&
              type_ != csi.v0.Csi.NodeServiceCapability.RPC.getDefaultInstance()) {
            type_ = csi.v0.Csi.NodeServiceCapability.RPC.newBuilder((csi.v0.Csi.NodeServiceCapability.RPC) type_)
                .mergeFrom(value).buildPartial();
          } else {
            type_ = value;
          }
          onChanged();
        } else {
          if (typeCase_ == 1) {
            rpcBuilder_.mergeFrom(value);
          }
          rpcBuilder_.setMessage(value);
        }
        typeCase_ = 1;
        return this;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.NodeServiceCapability.RPC rpc = 1;</code>
       */
      public Builder clearRpc() {
        if (rpcBuilder_ == null) {
          if (typeCase_ == 1) {
            typeCase_ = 0;
            type_ = null;
            onChanged();
          }
        } else {
          if (typeCase_ == 1) {
            typeCase_ = 0;
            type_ = null;
          }
          rpcBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.NodeServiceCapability.RPC rpc = 1;</code>
       */
      public csi.v0.Csi.NodeServiceCapability.RPC.Builder getRpcBuilder() {
        return getRpcFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.NodeServiceCapability.RPC rpc = 1;</code>
       */
      public csi.v0.Csi.NodeServiceCapability.RPCOrBuilder getRpcOrBuilder() {
        if ((typeCase_ == 1) && (rpcBuilder_ != null)) {
          return rpcBuilder_.getMessageOrBuilder();
        } else {
          if (typeCase_ == 1) {
            return (csi.v0.Csi.NodeServiceCapability.RPC) type_;
          }
          return csi.v0.Csi.NodeServiceCapability.RPC.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * RPC that the controller supports.
       * </pre>
       *
       * <code>.csi.v0.NodeServiceCapability.RPC rpc = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.NodeServiceCapability.RPC, csi.v0.Csi.NodeServiceCapability.RPC.Builder, csi.v0.Csi.NodeServiceCapability.RPCOrBuilder> 
          getRpcFieldBuilder() {
        if (rpcBuilder_ == null) {
          if (!(typeCase_ == 1)) {
            type_ = csi.v0.Csi.NodeServiceCapability.RPC.getDefaultInstance();
          }
          rpcBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.NodeServiceCapability.RPC, csi.v0.Csi.NodeServiceCapability.RPC.Builder, csi.v0.Csi.NodeServiceCapability.RPCOrBuilder>(
                  (csi.v0.Csi.NodeServiceCapability.RPC) type_,
                  getParentForChildren(),
                  isClean());
          type_ = null;
        }
        typeCase_ = 1;
        onChanged();;
        return rpcBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.NodeServiceCapability)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.NodeServiceCapability)
    private static final csi.v0.Csi.NodeServiceCapability DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.NodeServiceCapability();
    }

    public static csi.v0.Csi.NodeServiceCapability getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeServiceCapability>
        PARSER = new com.google.protobuf.AbstractParser<NodeServiceCapability>() {
      @java.lang.Override
      public NodeServiceCapability parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeServiceCapability(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeServiceCapability> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeServiceCapability> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.NodeServiceCapability getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeGetInfoRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.NodeGetInfoRequest)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * Protobuf type {@code csi.v0.NodeGetInfoRequest}
   */
  public  static final class NodeGetInfoRequest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.NodeGetInfoRequest)
      NodeGetInfoRequestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeGetInfoRequest.newBuilder() to construct.
    private NodeGetInfoRequest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeGetInfoRequest() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeGetInfoRequest(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_NodeGetInfoRequest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_NodeGetInfoRequest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.NodeGetInfoRequest.class, csi.v0.Csi.NodeGetInfoRequest.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.NodeGetInfoRequest)) {
        return super.equals(obj);
      }
      csi.v0.Csi.NodeGetInfoRequest other = (csi.v0.Csi.NodeGetInfoRequest) obj;

      boolean result = true;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.NodeGetInfoRequest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetInfoRequest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetInfoRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetInfoRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetInfoRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetInfoRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetInfoRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetInfoRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetInfoRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetInfoRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetInfoRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.NodeGetInfoRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.NodeGetInfoRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.NodeGetInfoRequest)
        csi.v0.Csi.NodeGetInfoRequestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetInfoRequest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetInfoRequest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.NodeGetInfoRequest.class, csi.v0.Csi.NodeGetInfoRequest.Builder.class);
      }

      // Construct using csi.v0.Csi.NodeGetInfoRequest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetInfoRequest_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetInfoRequest getDefaultInstanceForType() {
        return csi.v0.Csi.NodeGetInfoRequest.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetInfoRequest build() {
        csi.v0.Csi.NodeGetInfoRequest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetInfoRequest buildPartial() {
        csi.v0.Csi.NodeGetInfoRequest result = new csi.v0.Csi.NodeGetInfoRequest(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.NodeGetInfoRequest) {
          return mergeFrom((csi.v0.Csi.NodeGetInfoRequest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.NodeGetInfoRequest other) {
        if (other == csi.v0.Csi.NodeGetInfoRequest.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.NodeGetInfoRequest parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.NodeGetInfoRequest) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.NodeGetInfoRequest)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.NodeGetInfoRequest)
    private static final csi.v0.Csi.NodeGetInfoRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.NodeGetInfoRequest();
    }

    public static csi.v0.Csi.NodeGetInfoRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeGetInfoRequest>
        PARSER = new com.google.protobuf.AbstractParser<NodeGetInfoRequest>() {
      @java.lang.Override
      public NodeGetInfoRequest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeGetInfoRequest(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeGetInfoRequest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeGetInfoRequest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.NodeGetInfoRequest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface NodeGetInfoResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:csi.v0.NodeGetInfoResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The ID of the node as understood by the SP which SHALL be used by
     * CO in subsequent calls to `ControllerPublishVolume`.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     */
    java.lang.String getNodeId();
    /**
     * <pre>
     * The ID of the node as understood by the SP which SHALL be used by
     * CO in subsequent calls to `ControllerPublishVolume`.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getNodeIdBytes();

    /**
     * <pre>
     * Maximum number of volumes that controller can publish to the node.
     * If value is not set or zero CO SHALL decide how many volumes of
     * this type can be published by the controller to the node. The
     * plugin MUST NOT set negative values here.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>int64 max_volumes_per_node = 2;</code>
     */
    long getMaxVolumesPerNode();

    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the node is
     * accessible from.
     * A plugin that returns this field MUST also set the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * COs MAY use this information along with the topology information
     * returned in CreateVolumeResponse to ensure that a given volume is
     * accessible from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the node is not subject to any topological constraint, and MAY
     * schedule workloads that reference any volume V, such that there are
     * no topological constraints declared for V.
     * Example 1:
     *   accessible_topology =
     *     {"region": "R1", "zone": "R2"}
     * Indicates the node exists within the "region" "R1" and the "zone"
     * "Z2".
     * </pre>
     *
     * <code>.csi.v0.Topology accessible_topology = 3;</code>
     */
    boolean hasAccessibleTopology();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the node is
     * accessible from.
     * A plugin that returns this field MUST also set the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * COs MAY use this information along with the topology information
     * returned in CreateVolumeResponse to ensure that a given volume is
     * accessible from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the node is not subject to any topological constraint, and MAY
     * schedule workloads that reference any volume V, such that there are
     * no topological constraints declared for V.
     * Example 1:
     *   accessible_topology =
     *     {"region": "R1", "zone": "R2"}
     * Indicates the node exists within the "region" "R1" and the "zone"
     * "Z2".
     * </pre>
     *
     * <code>.csi.v0.Topology accessible_topology = 3;</code>
     */
    csi.v0.Csi.Topology getAccessibleTopology();
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the node is
     * accessible from.
     * A plugin that returns this field MUST also set the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * COs MAY use this information along with the topology information
     * returned in CreateVolumeResponse to ensure that a given volume is
     * accessible from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the node is not subject to any topological constraint, and MAY
     * schedule workloads that reference any volume V, such that there are
     * no topological constraints declared for V.
     * Example 1:
     *   accessible_topology =
     *     {"region": "R1", "zone": "R2"}
     * Indicates the node exists within the "region" "R1" and the "zone"
     * "Z2".
     * </pre>
     *
     * <code>.csi.v0.Topology accessible_topology = 3;</code>
     */
    csi.v0.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder();
  }
  /**
   * Protobuf type {@code csi.v0.NodeGetInfoResponse}
   */
  public  static final class NodeGetInfoResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:csi.v0.NodeGetInfoResponse)
      NodeGetInfoResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use NodeGetInfoResponse.newBuilder() to construct.
    private NodeGetInfoResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private NodeGetInfoResponse() {
      nodeId_ = "";
      maxVolumesPerNode_ = 0L;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private NodeGetInfoResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              nodeId_ = s;
              break;
            }
            case 16: {

              maxVolumesPerNode_ = input.readInt64();
              break;
            }
            case 26: {
              csi.v0.Csi.Topology.Builder subBuilder = null;
              if (accessibleTopology_ != null) {
                subBuilder = accessibleTopology_.toBuilder();
              }
              accessibleTopology_ = input.readMessage(csi.v0.Csi.Topology.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(accessibleTopology_);
                accessibleTopology_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return csi.v0.Csi.internal_static_csi_v0_NodeGetInfoResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return csi.v0.Csi.internal_static_csi_v0_NodeGetInfoResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              csi.v0.Csi.NodeGetInfoResponse.class, csi.v0.Csi.NodeGetInfoResponse.Builder.class);
    }

    public static final int NODE_ID_FIELD_NUMBER = 1;
    private volatile java.lang.Object nodeId_;
    /**
     * <pre>
     * The ID of the node as understood by the SP which SHALL be used by
     * CO in subsequent calls to `ControllerPublishVolume`.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     */
    public java.lang.String getNodeId() {
      java.lang.Object ref = nodeId_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        nodeId_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The ID of the node as understood by the SP which SHALL be used by
     * CO in subsequent calls to `ControllerPublishVolume`.
     * This is a REQUIRED field.
     * </pre>
     *
     * <code>string node_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNodeIdBytes() {
      java.lang.Object ref = nodeId_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nodeId_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MAX_VOLUMES_PER_NODE_FIELD_NUMBER = 2;
    private long maxVolumesPerNode_;
    /**
     * <pre>
     * Maximum number of volumes that controller can publish to the node.
     * If value is not set or zero CO SHALL decide how many volumes of
     * this type can be published by the controller to the node. The
     * plugin MUST NOT set negative values here.
     * This field is OPTIONAL.
     * </pre>
     *
     * <code>int64 max_volumes_per_node = 2;</code>
     */
    public long getMaxVolumesPerNode() {
      return maxVolumesPerNode_;
    }

    public static final int ACCESSIBLE_TOPOLOGY_FIELD_NUMBER = 3;
    private csi.v0.Csi.Topology accessibleTopology_;
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the node is
     * accessible from.
     * A plugin that returns this field MUST also set the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * COs MAY use this information along with the topology information
     * returned in CreateVolumeResponse to ensure that a given volume is
     * accessible from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the node is not subject to any topological constraint, and MAY
     * schedule workloads that reference any volume V, such that there are
     * no topological constraints declared for V.
     * Example 1:
     *   accessible_topology =
     *     {"region": "R1", "zone": "R2"}
     * Indicates the node exists within the "region" "R1" and the "zone"
     * "Z2".
     * </pre>
     *
     * <code>.csi.v0.Topology accessible_topology = 3;</code>
     */
    public boolean hasAccessibleTopology() {
      return accessibleTopology_ != null;
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the node is
     * accessible from.
     * A plugin that returns this field MUST also set the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * COs MAY use this information along with the topology information
     * returned in CreateVolumeResponse to ensure that a given volume is
     * accessible from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the node is not subject to any topological constraint, and MAY
     * schedule workloads that reference any volume V, such that there are
     * no topological constraints declared for V.
     * Example 1:
     *   accessible_topology =
     *     {"region": "R1", "zone": "R2"}
     * Indicates the node exists within the "region" "R1" and the "zone"
     * "Z2".
     * </pre>
     *
     * <code>.csi.v0.Topology accessible_topology = 3;</code>
     */
    public csi.v0.Csi.Topology getAccessibleTopology() {
      return accessibleTopology_ == null ? csi.v0.Csi.Topology.getDefaultInstance() : accessibleTopology_;
    }
    /**
     * <pre>
     * Specifies where (regions, zones, racks, etc.) the node is
     * accessible from.
     * A plugin that returns this field MUST also set the
     * ACCESSIBILITY_CONSTRAINTS plugin capability.
     * COs MAY use this information along with the topology information
     * returned in CreateVolumeResponse to ensure that a given volume is
     * accessible from a given node when scheduling workloads.
     * This field is OPTIONAL. If it is not specified, the CO MAY assume
     * the node is not subject to any topological constraint, and MAY
     * schedule workloads that reference any volume V, such that there are
     * no topological constraints declared for V.
     * Example 1:
     *   accessible_topology =
     *     {"region": "R1", "zone": "R2"}
     * Indicates the node exists within the "region" "R1" and the "zone"
     * "Z2".
     * </pre>
     *
     * <code>.csi.v0.Topology accessible_topology = 3;</code>
     */
    public csi.v0.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder() {
      return getAccessibleTopology();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getNodeIdBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, nodeId_);
      }
      if (maxVolumesPerNode_ != 0L) {
        output.writeInt64(2, maxVolumesPerNode_);
      }
      if (accessibleTopology_ != null) {
        output.writeMessage(3, getAccessibleTopology());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNodeIdBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, nodeId_);
      }
      if (maxVolumesPerNode_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, maxVolumesPerNode_);
      }
      if (accessibleTopology_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getAccessibleTopology());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof csi.v0.Csi.NodeGetInfoResponse)) {
        return super.equals(obj);
      }
      csi.v0.Csi.NodeGetInfoResponse other = (csi.v0.Csi.NodeGetInfoResponse) obj;

      boolean result = true;
      result = result && getNodeId()
          .equals(other.getNodeId());
      result = result && (getMaxVolumesPerNode()
          == other.getMaxVolumesPerNode());
      result = result && (hasAccessibleTopology() == other.hasAccessibleTopology());
      if (hasAccessibleTopology()) {
        result = result && getAccessibleTopology()
            .equals(other.getAccessibleTopology());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NODE_ID_FIELD_NUMBER;
      hash = (53 * hash) + getNodeId().hashCode();
      hash = (37 * hash) + MAX_VOLUMES_PER_NODE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getMaxVolumesPerNode());
      if (hasAccessibleTopology()) {
        hash = (37 * hash) + ACCESSIBLE_TOPOLOGY_FIELD_NUMBER;
        hash = (53 * hash) + getAccessibleTopology().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static csi.v0.Csi.NodeGetInfoResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetInfoResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetInfoResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetInfoResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetInfoResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static csi.v0.Csi.NodeGetInfoResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetInfoResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetInfoResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetInfoResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetInfoResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static csi.v0.Csi.NodeGetInfoResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static csi.v0.Csi.NodeGetInfoResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(csi.v0.Csi.NodeGetInfoResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code csi.v0.NodeGetInfoResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:csi.v0.NodeGetInfoResponse)
        csi.v0.Csi.NodeGetInfoResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetInfoResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetInfoResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                csi.v0.Csi.NodeGetInfoResponse.class, csi.v0.Csi.NodeGetInfoResponse.Builder.class);
      }

      // Construct using csi.v0.Csi.NodeGetInfoResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        nodeId_ = "";

        maxVolumesPerNode_ = 0L;

        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = null;
        } else {
          accessibleTopology_ = null;
          accessibleTopologyBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return csi.v0.Csi.internal_static_csi_v0_NodeGetInfoResponse_descriptor;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetInfoResponse getDefaultInstanceForType() {
        return csi.v0.Csi.NodeGetInfoResponse.getDefaultInstance();
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetInfoResponse build() {
        csi.v0.Csi.NodeGetInfoResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public csi.v0.Csi.NodeGetInfoResponse buildPartial() {
        csi.v0.Csi.NodeGetInfoResponse result = new csi.v0.Csi.NodeGetInfoResponse(this);
        result.nodeId_ = nodeId_;
        result.maxVolumesPerNode_ = maxVolumesPerNode_;
        if (accessibleTopologyBuilder_ == null) {
          result.accessibleTopology_ = accessibleTopology_;
        } else {
          result.accessibleTopology_ = accessibleTopologyBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return (Builder) super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof csi.v0.Csi.NodeGetInfoResponse) {
          return mergeFrom((csi.v0.Csi.NodeGetInfoResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(csi.v0.Csi.NodeGetInfoResponse other) {
        if (other == csi.v0.Csi.NodeGetInfoResponse.getDefaultInstance()) return this;
        if (!other.getNodeId().isEmpty()) {
          nodeId_ = other.nodeId_;
          onChanged();
        }
        if (other.getMaxVolumesPerNode() != 0L) {
          setMaxVolumesPerNode(other.getMaxVolumesPerNode());
        }
        if (other.hasAccessibleTopology()) {
          mergeAccessibleTopology(other.getAccessibleTopology());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        csi.v0.Csi.NodeGetInfoResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (csi.v0.Csi.NodeGetInfoResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object nodeId_ = "";
      /**
       * <pre>
       * The ID of the node as understood by the SP which SHALL be used by
       * CO in subsequent calls to `ControllerPublishVolume`.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       */
      public java.lang.String getNodeId() {
        java.lang.Object ref = nodeId_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          nodeId_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The ID of the node as understood by the SP which SHALL be used by
       * CO in subsequent calls to `ControllerPublishVolume`.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNodeIdBytes() {
        java.lang.Object ref = nodeId_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nodeId_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The ID of the node as understood by the SP which SHALL be used by
       * CO in subsequent calls to `ControllerPublishVolume`.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       */
      public Builder setNodeId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        nodeId_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the node as understood by the SP which SHALL be used by
       * CO in subsequent calls to `ControllerPublishVolume`.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       */
      public Builder clearNodeId() {
        
        nodeId_ = getDefaultInstance().getNodeId();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The ID of the node as understood by the SP which SHALL be used by
       * CO in subsequent calls to `ControllerPublishVolume`.
       * This is a REQUIRED field.
       * </pre>
       *
       * <code>string node_id = 1;</code>
       */
      public Builder setNodeIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        nodeId_ = value;
        onChanged();
        return this;
      }

      private long maxVolumesPerNode_ ;
      /**
       * <pre>
       * Maximum number of volumes that controller can publish to the node.
       * If value is not set or zero CO SHALL decide how many volumes of
       * this type can be published by the controller to the node. The
       * plugin MUST NOT set negative values here.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>int64 max_volumes_per_node = 2;</code>
       */
      public long getMaxVolumesPerNode() {
        return maxVolumesPerNode_;
      }
      /**
       * <pre>
       * Maximum number of volumes that controller can publish to the node.
       * If value is not set or zero CO SHALL decide how many volumes of
       * this type can be published by the controller to the node. The
       * plugin MUST NOT set negative values here.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>int64 max_volumes_per_node = 2;</code>
       */
      public Builder setMaxVolumesPerNode(long value) {
        
        maxVolumesPerNode_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum number of volumes that controller can publish to the node.
       * If value is not set or zero CO SHALL decide how many volumes of
       * this type can be published by the controller to the node. The
       * plugin MUST NOT set negative values here.
       * This field is OPTIONAL.
       * </pre>
       *
       * <code>int64 max_volumes_per_node = 2;</code>
       */
      public Builder clearMaxVolumesPerNode() {
        
        maxVolumesPerNode_ = 0L;
        onChanged();
        return this;
      }

      private csi.v0.Csi.Topology accessibleTopology_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder> accessibleTopologyBuilder_;
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      public boolean hasAccessibleTopology() {
        return accessibleTopologyBuilder_ != null || accessibleTopology_ != null;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      public csi.v0.Csi.Topology getAccessibleTopology() {
        if (accessibleTopologyBuilder_ == null) {
          return accessibleTopology_ == null ? csi.v0.Csi.Topology.getDefaultInstance() : accessibleTopology_;
        } else {
          return accessibleTopologyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      public Builder setAccessibleTopology(csi.v0.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          accessibleTopology_ = value;
          onChanged();
        } else {
          accessibleTopologyBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      public Builder setAccessibleTopology(
          csi.v0.Csi.Topology.Builder builderForValue) {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = builderForValue.build();
          onChanged();
        } else {
          accessibleTopologyBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      public Builder mergeAccessibleTopology(csi.v0.Csi.Topology value) {
        if (accessibleTopologyBuilder_ == null) {
          if (accessibleTopology_ != null) {
            accessibleTopology_ =
              csi.v0.Csi.Topology.newBuilder(accessibleTopology_).mergeFrom(value).buildPartial();
          } else {
            accessibleTopology_ = value;
          }
          onChanged();
        } else {
          accessibleTopologyBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      public Builder clearAccessibleTopology() {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopology_ = null;
          onChanged();
        } else {
          accessibleTopology_ = null;
          accessibleTopologyBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      public csi.v0.Csi.Topology.Builder getAccessibleTopologyBuilder() {
        
        onChanged();
        return getAccessibleTopologyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      public csi.v0.Csi.TopologyOrBuilder getAccessibleTopologyOrBuilder() {
        if (accessibleTopologyBuilder_ != null) {
          return accessibleTopologyBuilder_.getMessageOrBuilder();
        } else {
          return accessibleTopology_ == null ?
              csi.v0.Csi.Topology.getDefaultInstance() : accessibleTopology_;
        }
      }
      /**
       * <pre>
       * Specifies where (regions, zones, racks, etc.) the node is
       * accessible from.
       * A plugin that returns this field MUST also set the
       * ACCESSIBILITY_CONSTRAINTS plugin capability.
       * COs MAY use this information along with the topology information
       * returned in CreateVolumeResponse to ensure that a given volume is
       * accessible from a given node when scheduling workloads.
       * This field is OPTIONAL. If it is not specified, the CO MAY assume
       * the node is not subject to any topological constraint, and MAY
       * schedule workloads that reference any volume V, such that there are
       * no topological constraints declared for V.
       * Example 1:
       *   accessible_topology =
       *     {"region": "R1", "zone": "R2"}
       * Indicates the node exists within the "region" "R1" and the "zone"
       * "Z2".
       * </pre>
       *
       * <code>.csi.v0.Topology accessible_topology = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder> 
          getAccessibleTopologyFieldBuilder() {
        if (accessibleTopologyBuilder_ == null) {
          accessibleTopologyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              csi.v0.Csi.Topology, csi.v0.Csi.Topology.Builder, csi.v0.Csi.TopologyOrBuilder>(
                  getAccessibleTopology(),
                  getParentForChildren(),
                  isClean());
          accessibleTopology_ = null;
        }
        return accessibleTopologyBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:csi.v0.NodeGetInfoResponse)
    }

    // @@protoc_insertion_point(class_scope:csi.v0.NodeGetInfoResponse)
    private static final csi.v0.Csi.NodeGetInfoResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new csi.v0.Csi.NodeGetInfoResponse();
    }

    public static csi.v0.Csi.NodeGetInfoResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<NodeGetInfoResponse>
        PARSER = new com.google.protobuf.AbstractParser<NodeGetInfoResponse>() {
      @java.lang.Override
      public NodeGetInfoResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NodeGetInfoResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<NodeGetInfoResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<NodeGetInfoResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public csi.v0.Csi.NodeGetInfoResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_GetPluginInfoRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_GetPluginInfoRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_GetPluginInfoResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_GetPluginInfoResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_GetPluginInfoResponse_ManifestEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_GetPluginInfoResponse_ManifestEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_GetPluginCapabilitiesRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_GetPluginCapabilitiesRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_GetPluginCapabilitiesResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_GetPluginCapabilitiesResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_PluginCapability_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_PluginCapability_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_PluginCapability_Service_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_PluginCapability_Service_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ProbeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ProbeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ProbeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ProbeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_CreateVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_CreateVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_CreateVolumeRequest_ParametersEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_CreateVolumeRequest_ParametersEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_CreateVolumeRequest_ControllerCreateSecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_CreateVolumeRequest_ControllerCreateSecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_VolumeContentSource_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_VolumeContentSource_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_VolumeContentSource_SnapshotSource_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_VolumeContentSource_SnapshotSource_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_CreateVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_CreateVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_VolumeCapability_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_VolumeCapability_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_VolumeCapability_BlockVolume_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_VolumeCapability_BlockVolume_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_VolumeCapability_MountVolume_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_VolumeCapability_MountVolume_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_VolumeCapability_AccessMode_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_VolumeCapability_AccessMode_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_CapacityRange_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_CapacityRange_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_Volume_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_Volume_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_Volume_AttributesEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_Volume_AttributesEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_TopologyRequirement_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_TopologyRequirement_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_Topology_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_Topology_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_Topology_SegmentsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_Topology_SegmentsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_DeleteVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_DeleteVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_DeleteVolumeRequest_ControllerDeleteSecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_DeleteVolumeRequest_ControllerDeleteSecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_DeleteVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_DeleteVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ControllerPublishVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ControllerPublishVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ControllerPublishVolumeRequest_ControllerPublishSecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ControllerPublishVolumeRequest_ControllerPublishSecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ControllerPublishVolumeRequest_VolumeAttributesEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ControllerPublishVolumeRequest_VolumeAttributesEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ControllerPublishVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ControllerPublishVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ControllerPublishVolumeResponse_PublishInfoEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ControllerPublishVolumeResponse_PublishInfoEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ControllerUnpublishVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ControllerUnpublishVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ControllerUnpublishVolumeRequest_ControllerUnpublishSecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ControllerUnpublishVolumeRequest_ControllerUnpublishSecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ControllerUnpublishVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ControllerUnpublishVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_VolumeAttributesEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_VolumeAttributesEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ValidateVolumeCapabilitiesResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ValidateVolumeCapabilitiesResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ListVolumesRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ListVolumesRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ListVolumesResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ListVolumesResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ListVolumesResponse_Entry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ListVolumesResponse_Entry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_GetCapacityRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_GetCapacityRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_GetCapacityRequest_ParametersEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_GetCapacityRequest_ParametersEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_GetCapacityResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_GetCapacityResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ControllerGetCapabilitiesRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ControllerGetCapabilitiesRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ControllerGetCapabilitiesResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ControllerGetCapabilitiesResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ControllerServiceCapability_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ControllerServiceCapability_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ControllerServiceCapability_RPC_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ControllerServiceCapability_RPC_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_CreateSnapshotRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_CreateSnapshotRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_CreateSnapshotRequest_CreateSnapshotSecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_CreateSnapshotRequest_CreateSnapshotSecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_CreateSnapshotRequest_ParametersEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_CreateSnapshotRequest_ParametersEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_CreateSnapshotResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_CreateSnapshotResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_Snapshot_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_Snapshot_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_SnapshotStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_SnapshotStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_DeleteSnapshotRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_DeleteSnapshotRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_DeleteSnapshotRequest_DeleteSnapshotSecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_DeleteSnapshotRequest_DeleteSnapshotSecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_DeleteSnapshotResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_DeleteSnapshotResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ListSnapshotsRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ListSnapshotsRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ListSnapshotsResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ListSnapshotsResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_ListSnapshotsResponse_Entry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_ListSnapshotsResponse_Entry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeStageVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeStageVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeStageVolumeRequest_PublishInfoEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeStageVolumeRequest_PublishInfoEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeStageVolumeRequest_NodeStageSecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeStageVolumeRequest_NodeStageSecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeStageVolumeRequest_VolumeAttributesEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeStageVolumeRequest_VolumeAttributesEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeStageVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeStageVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeUnstageVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeUnstageVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeUnstageVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeUnstageVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodePublishVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodePublishVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodePublishVolumeRequest_PublishInfoEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodePublishVolumeRequest_PublishInfoEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodePublishVolumeRequest_NodePublishSecretsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodePublishVolumeRequest_NodePublishSecretsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodePublishVolumeRequest_VolumeAttributesEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodePublishVolumeRequest_VolumeAttributesEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodePublishVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodePublishVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeUnpublishVolumeRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeUnpublishVolumeRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeUnpublishVolumeResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeUnpublishVolumeResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeGetIdRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeGetIdRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeGetIdResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeGetIdResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeGetCapabilitiesRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeGetCapabilitiesRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeGetCapabilitiesResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeGetCapabilitiesResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeServiceCapability_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeServiceCapability_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeServiceCapability_RPC_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeServiceCapability_RPC_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeGetInfoRequest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeGetInfoRequest_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_csi_v0_NodeGetInfoResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_csi_v0_NodeGetInfoResponse_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\tcsi.proto\022\006csi.v0\032\036google/protobuf/wra" +
      "ppers.proto\"\026\n\024GetPluginInfoRequest\"\255\001\n\025" +
      "GetPluginInfoResponse\022\014\n\004name\030\001 \001(\t\022\026\n\016v" +
      "endor_version\030\002 \001(\t\022=\n\010manifest\030\003 \003(\0132+." +
      "csi.v0.GetPluginInfoResponse.ManifestEnt" +
      "ry\032/\n\rManifestEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005valu" +
      "e\030\002 \001(\t:\0028\001\"\036\n\034GetPluginCapabilitiesRequ" +
      "est\"O\n\035GetPluginCapabilitiesResponse\022.\n\014" +
      "capabilities\030\002 \003(\0132\030.csi.v0.PluginCapabi" +
      "lity\"\334\001\n\020PluginCapability\0223\n\007service\030\001 \001" +
      "(\0132 .csi.v0.PluginCapability.ServiceH\000\032\212" +
      "\001\n\007Service\0223\n\004type\030\001 \001(\0162%.csi.v0.Plugin" +
      "Capability.Service.Type\"J\n\004Type\022\013\n\007UNKNO" +
      "WN\020\000\022\026\n\022CONTROLLER_SERVICE\020\001\022\035\n\031ACCESSIB" +
      "ILITY_CONSTRAINTS\020\002B\006\n\004type\"\016\n\014ProbeRequ" +
      "est\":\n\rProbeResponse\022)\n\005ready\030\001 \001(\0132\032.go" +
      "ogle.protobuf.BoolValue\"\227\004\n\023CreateVolume" +
      "Request\022\014\n\004name\030\001 \001(\t\022-\n\016capacity_range\030" +
      "\002 \001(\0132\025.csi.v0.CapacityRange\0225\n\023volume_c" +
      "apabilities\030\003 \003(\0132\030.csi.v0.VolumeCapabil" +
      "ity\022?\n\nparameters\030\004 \003(\0132+.csi.v0.CreateV" +
      "olumeRequest.ParametersEntry\022[\n\031controll" +
      "er_create_secrets\030\005 \003(\01328.csi.v0.CreateV" +
      "olumeRequest.ControllerCreateSecretsEntr" +
      "y\022:\n\025volume_content_source\030\006 \001(\0132\033.csi.v" +
      "0.VolumeContentSource\022?\n\032accessibility_r" +
      "equirements\030\007 \001(\0132\033.csi.v0.TopologyRequi" +
      "rement\0321\n\017ParametersEntry\022\013\n\003key\030\001 \001(\t\022\r" +
      "\n\005value\030\002 \001(\t:\0028\001\032>\n\034ControllerCreateSec" +
      "retsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028" +
      "\001\"{\n\023VolumeContentSource\022>\n\010snapshot\030\001 \001" +
      "(\0132*.csi.v0.VolumeContentSource.Snapshot" +
      "SourceH\000\032\034\n\016SnapshotSource\022\n\n\002id\030\001 \001(\tB\006" +
      "\n\004type\"6\n\024CreateVolumeResponse\022\036\n\006volume" +
      "\030\001 \001(\0132\016.csi.v0.Volume\"\366\003\n\020VolumeCapabil" +
      "ity\0225\n\005block\030\001 \001(\0132$.csi.v0.VolumeCapabi" +
      "lity.BlockVolumeH\000\0225\n\005mount\030\002 \001(\0132$.csi." +
      "v0.VolumeCapability.MountVolumeH\000\0228\n\013acc" +
      "ess_mode\030\003 \001(\0132#.csi.v0.VolumeCapability" +
      ".AccessMode\032\r\n\013BlockVolume\0323\n\013MountVolum" +
      "e\022\017\n\007fs_type\030\001 \001(\t\022\023\n\013mount_flags\030\002 \003(\t\032" +
      "\346\001\n\nAccessMode\0226\n\004mode\030\001 \001(\0162(.csi.v0.Vo" +
      "lumeCapability.AccessMode.Mode\"\237\001\n\004Mode\022" +
      "\013\n\007UNKNOWN\020\000\022\026\n\022SINGLE_NODE_WRITER\020\001\022\033\n\027" +
      "SINGLE_NODE_READER_ONLY\020\002\022\032\n\026MULTI_NODE_" +
      "READER_ONLY\020\003\022\034\n\030MULTI_NODE_SINGLE_WRITE" +
      "R\020\004\022\033\n\027MULTI_NODE_MULTI_WRITER\020\005B\r\n\013acce" +
      "ss_type\"<\n\rCapacityRange\022\026\n\016required_byt" +
      "es\030\001 \001(\003\022\023\n\013limit_bytes\030\002 \001(\003\"\367\001\n\006Volume" +
      "\022\026\n\016capacity_bytes\030\001 \001(\003\022\n\n\002id\030\002 \001(\t\0222\n\n" +
      "attributes\030\003 \003(\0132\036.csi.v0.Volume.Attribu" +
      "tesEntry\0223\n\016content_source\030\004 \001(\0132\033.csi.v" +
      "0.VolumeContentSource\022-\n\023accessible_topo" +
      "logy\030\005 \003(\0132\020.csi.v0.Topology\0321\n\017Attribut" +
      "esEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"" +
      "_\n\023TopologyRequirement\022#\n\trequisite\030\001 \003(" +
      "\0132\020.csi.v0.Topology\022#\n\tpreferred\030\002 \003(\0132\020" +
      ".csi.v0.Topology\"m\n\010Topology\0220\n\010segments" +
      "\030\001 \003(\0132\036.csi.v0.Topology.SegmentsEntry\032/" +
      "\n\rSegmentsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 " +
      "\001(\t:\0028\001\"\305\001\n\023DeleteVolumeRequest\022\021\n\tvolum" +
      "e_id\030\001 \001(\t\022[\n\031controller_delete_secrets\030" +
      "\002 \003(\01328.csi.v0.DeleteVolumeRequest.Contr" +
      "ollerDeleteSecretsEntry\032>\n\034ControllerDel" +
      "eteSecretsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 " +
      "\001(\t:\0028\001\"\026\n\024DeleteVolumeResponse\"\310\003\n\036Cont" +
      "rollerPublishVolumeRequest\022\021\n\tvolume_id\030" +
      "\001 \001(\t\022\017\n\007node_id\030\002 \001(\t\0223\n\021volume_capabil" +
      "ity\030\003 \001(\0132\030.csi.v0.VolumeCapability\022\020\n\010r" +
      "eadonly\030\004 \001(\010\022h\n\032controller_publish_secr" +
      "ets\030\005 \003(\0132D.csi.v0.ControllerPublishVolu" +
      "meRequest.ControllerPublishSecretsEntry\022" +
      "W\n\021volume_attributes\030\006 \003(\0132<.csi.v0.Cont" +
      "rollerPublishVolumeRequest.VolumeAttribu" +
      "tesEntry\032?\n\035ControllerPublishSecretsEntr" +
      "y\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\0327\n\025Vol" +
      "umeAttributesEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value" +
      "\030\002 \001(\t:\0028\001\"\245\001\n\037ControllerPublishVolumeRe" +
      "sponse\022N\n\014publish_info\030\001 \003(\01328.csi.v0.Co" +
      "ntrollerPublishVolumeResponse.PublishInf" +
      "oEntry\0322\n\020PublishInfoEntry\022\013\n\003key\030\001 \001(\t\022" +
      "\r\n\005value\030\002 \001(\t:\0028\001\"\371\001\n ControllerUnpubli" +
      "shVolumeRequest\022\021\n\tvolume_id\030\001 \001(\t\022\017\n\007no" +
      "de_id\030\002 \001(\t\022n\n\034controller_unpublish_secr" +
      "ets\030\003 \003(\0132H.csi.v0.ControllerUnpublishVo" +
      "lumeRequest.ControllerUnpublishSecretsEn" +
      "try\032A\n\037ControllerUnpublishSecretsEntry\022\013" +
      "\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"#\n!Contro" +
      "llerUnpublishVolumeResponse\"\261\002\n!Validate" +
      "VolumeCapabilitiesRequest\022\021\n\tvolume_id\030\001" +
      " \001(\t\0225\n\023volume_capabilities\030\002 \003(\0132\030.csi." +
      "v0.VolumeCapability\022Z\n\021volume_attributes" +
      "\030\003 \003(\0132?.csi.v0.ValidateVolumeCapabiliti" +
      "esRequest.VolumeAttributesEntry\022-\n\023acces" +
      "sible_topology\030\004 \003(\0132\020.csi.v0.Topology\0327" +
      "\n\025VolumeAttributesEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005" +
      "value\030\002 \001(\t:\0028\001\"H\n\"ValidateVolumeCapabil" +
      "itiesResponse\022\021\n\tsupported\030\001 \001(\010\022\017\n\007mess" +
      "age\030\002 \001(\t\"A\n\022ListVolumesRequest\022\023\n\013max_e" +
      "ntries\030\001 \001(\005\022\026\n\016starting_token\030\002 \001(\t\"\206\001\n" +
      "\023ListVolumesResponse\0222\n\007entries\030\001 \003(\0132!." +
      "csi.v0.ListVolumesResponse.Entry\022\022\n\nnext" +
      "_token\030\002 \001(\t\032\'\n\005Entry\022\036\n\006volume\030\001 \001(\0132\016." +
      "csi.v0.Volume\"\355\001\n\022GetCapacityRequest\0225\n\023" +
      "volume_capabilities\030\001 \003(\0132\030.csi.v0.Volum" +
      "eCapability\022>\n\nparameters\030\002 \003(\0132*.csi.v0" +
      ".GetCapacityRequest.ParametersEntry\022-\n\023a" +
      "ccessible_topology\030\003 \001(\0132\020.csi.v0.Topolo" +
      "gy\0321\n\017ParametersEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005va" +
      "lue\030\002 \001(\t:\0028\001\"1\n\023GetCapacityResponse\022\032\n\022" +
      "available_capacity\030\001 \001(\003\"\"\n ControllerGe" +
      "tCapabilitiesRequest\"^\n!ControllerGetCap" +
      "abilitiesResponse\0229\n\014capabilities\030\002 \003(\0132" +
      "#.csi.v0.ControllerServiceCapability\"\303\002\n" +
      "\033ControllerServiceCapability\0226\n\003rpc\030\001 \001(" +
      "\0132\'.csi.v0.ControllerServiceCapability.R" +
      "PCH\000\032\343\001\n\003RPC\022:\n\004type\030\001 \001(\0162,.csi.v0.Cont" +
      "rollerServiceCapability.RPC.Type\"\237\001\n\004Typ" +
      "e\022\013\n\007UNKNOWN\020\000\022\030\n\024CREATE_DELETE_VOLUME\020\001" +
      "\022\034\n\030PUBLISH_UNPUBLISH_VOLUME\020\002\022\020\n\014LIST_V" +
      "OLUMES\020\003\022\020\n\014GET_CAPACITY\020\004\022\032\n\026CREATE_DEL" +
      "ETE_SNAPSHOT\020\005\022\022\n\016LIST_SNAPSHOTS\020\006B\006\n\004ty" +
      "pe\"\316\002\n\025CreateSnapshotRequest\022\030\n\020source_v" +
      "olume_id\030\001 \001(\t\022\014\n\004name\030\002 \001(\t\022Y\n\027create_s" +
      "napshot_secrets\030\003 \003(\01328.csi.v0.CreateSna" +
      "pshotRequest.CreateSnapshotSecretsEntry\022" +
      "A\n\nparameters\030\004 \003(\0132-.csi.v0.CreateSnaps" +
      "hotRequest.ParametersEntry\032<\n\032CreateSnap" +
      "shotSecretsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002" +
      " \001(\t:\0028\001\0321\n\017ParametersEntry\022\013\n\003key\030\001 \001(\t" +
      "\022\r\n\005value\030\002 \001(\t:\0028\001\"<\n\026CreateSnapshotRes" +
      "ponse\022\"\n\010snapshot\030\001 \001(\0132\020.csi.v0.Snapsho" +
      "t\"\200\001\n\010Snapshot\022\022\n\nsize_bytes\030\001 \001(\003\022\n\n\002id" +
      "\030\002 \001(\t\022\030\n\020source_volume_id\030\003 \001(\t\022\022\n\ncrea" +
      "ted_at\030\004 \001(\003\022&\n\006status\030\005 \001(\0132\026.csi.v0.Sn" +
      "apshotStatus\"\220\001\n\016SnapshotStatus\022)\n\004type\030" +
      "\001 \001(\0162\033.csi.v0.SnapshotStatus.Type\022\017\n\007de" +
      "tails\030\002 \001(\t\"B\n\004Type\022\013\n\007UNKNOWN\020\000\022\t\n\005READ" +
      "Y\020\001\022\r\n\tUPLOADING\020\002\022\023\n\017ERROR_UPLOADING\020\003\"" +
      "\305\001\n\025DeleteSnapshotRequest\022\023\n\013snapshot_id" +
      "\030\001 \001(\t\022Y\n\027delete_snapshot_secrets\030\002 \003(\0132" +
      "8.csi.v0.DeleteSnapshotRequest.DeleteSna" +
      "pshotSecretsEntry\032<\n\032DeleteSnapshotSecre" +
      "tsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"" +
      "\030\n\026DeleteSnapshotResponse\"r\n\024ListSnapsho" +
      "tsRequest\022\023\n\013max_entries\030\001 \001(\005\022\026\n\016starti" +
      "ng_token\030\002 \001(\t\022\030\n\020source_volume_id\030\003 \001(\t" +
      "\022\023\n\013snapshot_id\030\004 \001(\t\"\216\001\n\025ListSnapshotsR" +
      "esponse\0224\n\007entries\030\001 \003(\0132#.csi.v0.ListSn" +
      "apshotsResponse.Entry\022\022\n\nnext_token\030\002 \001(" +
      "\t\032+\n\005Entry\022\"\n\010snapshot\030\001 \001(\0132\020.csi.v0.Sn" +
      "apshot\"\215\004\n\026NodeStageVolumeRequest\022\021\n\tvol" +
      "ume_id\030\001 \001(\t\022E\n\014publish_info\030\002 \003(\0132/.csi" +
      ".v0.NodeStageVolumeRequest.PublishInfoEn" +
      "try\022\033\n\023staging_target_path\030\003 \001(\t\0223\n\021volu" +
      "me_capability\030\004 \001(\0132\030.csi.v0.VolumeCapab" +
      "ility\022P\n\022node_stage_secrets\030\005 \003(\01324.csi." +
      "v0.NodeStageVolumeRequest.NodeStageSecre" +
      "tsEntry\022O\n\021volume_attributes\030\006 \003(\01324.csi" +
      ".v0.NodeStageVolumeRequest.VolumeAttribu" +
      "tesEntry\0322\n\020PublishInfoEntry\022\013\n\003key\030\001 \001(" +
      "\t\022\r\n\005value\030\002 \001(\t:\0028\001\0327\n\025NodeStageSecrets" +
      "Entry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\0327\n" +
      "\025VolumeAttributesEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005v" +
      "alue\030\002 \001(\t:\0028\001\"\031\n\027NodeStageVolumeRespons" +
      "e\"J\n\030NodeUnstageVolumeRequest\022\021\n\tvolume_" +
      "id\030\001 \001(\t\022\033\n\023staging_target_path\030\002 \001(\t\"\033\n" +
      "\031NodeUnstageVolumeResponse\"\302\004\n\030NodePubli" +
      "shVolumeRequest\022\021\n\tvolume_id\030\001 \001(\t\022G\n\014pu" +
      "blish_info\030\002 \003(\01321.csi.v0.NodePublishVol" +
      "umeRequest.PublishInfoEntry\022\033\n\023staging_t" +
      "arget_path\030\003 \001(\t\022\023\n\013target_path\030\004 \001(\t\0223\n" +
      "\021volume_capability\030\005 \001(\0132\030.csi.v0.Volume" +
      "Capability\022\020\n\010readonly\030\006 \001(\010\022V\n\024node_pub" +
      "lish_secrets\030\007 \003(\01328.csi.v0.NodePublishV" +
      "olumeRequest.NodePublishSecretsEntry\022Q\n\021" +
      "volume_attributes\030\010 \003(\01326.csi.v0.NodePub" +
      "lishVolumeRequest.VolumeAttributesEntry\032" +
      "2\n\020PublishInfoEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005valu" +
      "e\030\002 \001(\t:\0028\001\0329\n\027NodePublishSecretsEntry\022\013" +
      "\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\0327\n\025Volume" +
      "AttributesEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 " +
      "\001(\t:\0028\001\"\033\n\031NodePublishVolumeResponse\"D\n\032" +
      "NodeUnpublishVolumeRequest\022\021\n\tvolume_id\030" +
      "\001 \001(\t\022\023\n\013target_path\030\002 \001(\t\"\035\n\033NodeUnpubl" +
      "ishVolumeResponse\"\022\n\020NodeGetIdRequest\"$\n" +
      "\021NodeGetIdResponse\022\017\n\007node_id\030\001 \001(\t\"\034\n\032N" +
      "odeGetCapabilitiesRequest\"R\n\033NodeGetCapa" +
      "bilitiesResponse\0223\n\014capabilities\030\001 \003(\0132\035" +
      ".csi.v0.NodeServiceCapability\"\275\001\n\025NodeSe" +
      "rviceCapability\0220\n\003rpc\030\001 \001(\0132!.csi.v0.No" +
      "deServiceCapability.RPCH\000\032j\n\003RPC\0224\n\004type" +
      "\030\001 \001(\0162&.csi.v0.NodeServiceCapability.RP" +
      "C.Type\"-\n\004Type\022\013\n\007UNKNOWN\020\000\022\030\n\024STAGE_UNS" +
      "TAGE_VOLUME\020\001B\006\n\004type\"\024\n\022NodeGetInfoRequ" +
      "est\"s\n\023NodeGetInfoResponse\022\017\n\007node_id\030\001 " +
      "\001(\t\022\034\n\024max_volumes_per_node\030\002 \001(\003\022-\n\023acc" +
      "essible_topology\030\003 \001(\0132\020.csi.v0.Topology" +
      "2\372\001\n\010Identity\022N\n\rGetPluginInfo\022\034.csi.v0." +
      "GetPluginInfoRequest\032\035.csi.v0.GetPluginI" +
      "nfoResponse\"\000\022f\n\025GetPluginCapabilities\022$" +
      ".csi.v0.GetPluginCapabilitiesRequest\032%.c" +
      "si.v0.GetPluginCapabilitiesResponse\"\000\0226\n" +
      "\005Probe\022\024.csi.v0.ProbeRequest\032\025.csi.v0.Pr" +
      "obeResponse\"\0002\375\007\n\nController\022K\n\014CreateVo" +
      "lume\022\033.csi.v0.CreateVolumeRequest\032\034.csi." +
      "v0.CreateVolumeResponse\"\000\022K\n\014DeleteVolum" +
      "e\022\033.csi.v0.DeleteVolumeRequest\032\034.csi.v0." +
      "DeleteVolumeResponse\"\000\022l\n\027ControllerPubl" +
      "ishVolume\022&.csi.v0.ControllerPublishVolu" +
      "meRequest\032\'.csi.v0.ControllerPublishVolu" +
      "meResponse\"\000\022r\n\031ControllerUnpublishVolum" +
      "e\022(.csi.v0.ControllerUnpublishVolumeRequ" +
      "est\032).csi.v0.ControllerUnpublishVolumeRe" +
      "sponse\"\000\022u\n\032ValidateVolumeCapabilities\022)" +
      ".csi.v0.ValidateVolumeCapabilitiesReques" +
      "t\032*.csi.v0.ValidateVolumeCapabilitiesRes" +
      "ponse\"\000\022H\n\013ListVolumes\022\032.csi.v0.ListVolu" +
      "mesRequest\032\033.csi.v0.ListVolumesResponse\"" +
      "\000\022H\n\013GetCapacity\022\032.csi.v0.GetCapacityReq" +
      "uest\032\033.csi.v0.GetCapacityResponse\"\000\022r\n\031C" +
      "ontrollerGetCapabilities\022(.csi.v0.Contro" +
      "llerGetCapabilitiesRequest\032).csi.v0.Cont" +
      "rollerGetCapabilitiesResponse\"\000\022Q\n\016Creat" +
      "eSnapshot\022\035.csi.v0.CreateSnapshotRequest" +
      "\032\036.csi.v0.CreateSnapshotResponse\"\000\022Q\n\016De" +
      "leteSnapshot\022\035.csi.v0.DeleteSnapshotRequ" +
      "est\032\036.csi.v0.DeleteSnapshotResponse\"\000\022N\n" +
      "\rListSnapshots\022\034.csi.v0.ListSnapshotsReq" +
      "uest\032\035.csi.v0.ListSnapshotsResponse\"\0002\351\004" +
      "\n\004Node\022T\n\017NodeStageVolume\022\036.csi.v0.NodeS" +
      "tageVolumeRequest\032\037.csi.v0.NodeStageVolu" +
      "meResponse\"\000\022Z\n\021NodeUnstageVolume\022 .csi." +
      "v0.NodeUnstageVolumeRequest\032!.csi.v0.Nod" +
      "eUnstageVolumeResponse\"\000\022Z\n\021NodePublishV" +
      "olume\022 .csi.v0.NodePublishVolumeRequest\032" +
      "!.csi.v0.NodePublishVolumeResponse\"\000\022`\n\023" +
      "NodeUnpublishVolume\022\".csi.v0.NodeUnpubli" +
      "shVolumeRequest\032#.csi.v0.NodeUnpublishVo" +
      "lumeResponse\"\000\022E\n\tNodeGetId\022\030.csi.v0.Nod" +
      "eGetIdRequest\032\031.csi.v0.NodeGetIdResponse" +
      "\"\003\210\002\001\022`\n\023NodeGetCapabilities\022\".csi.v0.No" +
      "deGetCapabilitiesRequest\032#.csi.v0.NodeGe" +
      "tCapabilitiesResponse\"\000\022H\n\013NodeGetInfo\022\032" +
      ".csi.v0.NodeGetInfoRequest\032\033.csi.v0.Node" +
      "GetInfoResponse\"\000B\005Z\003csib\006proto3"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          com.google.protobuf.WrappersProto.getDescriptor(),
        }, assigner);
    internal_static_csi_v0_GetPluginInfoRequest_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_csi_v0_GetPluginInfoRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_GetPluginInfoRequest_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v0_GetPluginInfoResponse_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_csi_v0_GetPluginInfoResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_GetPluginInfoResponse_descriptor,
        new java.lang.String[] { "Name", "VendorVersion", "Manifest", });
    internal_static_csi_v0_GetPluginInfoResponse_ManifestEntry_descriptor =
      internal_static_csi_v0_GetPluginInfoResponse_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_GetPluginInfoResponse_ManifestEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_GetPluginInfoResponse_ManifestEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_GetPluginCapabilitiesRequest_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_csi_v0_GetPluginCapabilitiesRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_GetPluginCapabilitiesRequest_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v0_GetPluginCapabilitiesResponse_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_csi_v0_GetPluginCapabilitiesResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_GetPluginCapabilitiesResponse_descriptor,
        new java.lang.String[] { "Capabilities", });
    internal_static_csi_v0_PluginCapability_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_csi_v0_PluginCapability_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_PluginCapability_descriptor,
        new java.lang.String[] { "Service", "Type", });
    internal_static_csi_v0_PluginCapability_Service_descriptor =
      internal_static_csi_v0_PluginCapability_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_PluginCapability_Service_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_PluginCapability_Service_descriptor,
        new java.lang.String[] { "Type", });
    internal_static_csi_v0_ProbeRequest_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_csi_v0_ProbeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ProbeRequest_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v0_ProbeResponse_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_csi_v0_ProbeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ProbeResponse_descriptor,
        new java.lang.String[] { "Ready", });
    internal_static_csi_v0_CreateVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_csi_v0_CreateVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_CreateVolumeRequest_descriptor,
        new java.lang.String[] { "Name", "CapacityRange", "VolumeCapabilities", "Parameters", "ControllerCreateSecrets", "VolumeContentSource", "AccessibilityRequirements", });
    internal_static_csi_v0_CreateVolumeRequest_ParametersEntry_descriptor =
      internal_static_csi_v0_CreateVolumeRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_CreateVolumeRequest_ParametersEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_CreateVolumeRequest_ParametersEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_CreateVolumeRequest_ControllerCreateSecretsEntry_descriptor =
      internal_static_csi_v0_CreateVolumeRequest_descriptor.getNestedTypes().get(1);
    internal_static_csi_v0_CreateVolumeRequest_ControllerCreateSecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_CreateVolumeRequest_ControllerCreateSecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_VolumeContentSource_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_csi_v0_VolumeContentSource_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_VolumeContentSource_descriptor,
        new java.lang.String[] { "Snapshot", "Type", });
    internal_static_csi_v0_VolumeContentSource_SnapshotSource_descriptor =
      internal_static_csi_v0_VolumeContentSource_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_VolumeContentSource_SnapshotSource_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_VolumeContentSource_SnapshotSource_descriptor,
        new java.lang.String[] { "Id", });
    internal_static_csi_v0_CreateVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_csi_v0_CreateVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_CreateVolumeResponse_descriptor,
        new java.lang.String[] { "Volume", });
    internal_static_csi_v0_VolumeCapability_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_csi_v0_VolumeCapability_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_VolumeCapability_descriptor,
        new java.lang.String[] { "Block", "Mount", "AccessMode", "AccessType", });
    internal_static_csi_v0_VolumeCapability_BlockVolume_descriptor =
      internal_static_csi_v0_VolumeCapability_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_VolumeCapability_BlockVolume_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_VolumeCapability_BlockVolume_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v0_VolumeCapability_MountVolume_descriptor =
      internal_static_csi_v0_VolumeCapability_descriptor.getNestedTypes().get(1);
    internal_static_csi_v0_VolumeCapability_MountVolume_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_VolumeCapability_MountVolume_descriptor,
        new java.lang.String[] { "FsType", "MountFlags", });
    internal_static_csi_v0_VolumeCapability_AccessMode_descriptor =
      internal_static_csi_v0_VolumeCapability_descriptor.getNestedTypes().get(2);
    internal_static_csi_v0_VolumeCapability_AccessMode_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_VolumeCapability_AccessMode_descriptor,
        new java.lang.String[] { "Mode", });
    internal_static_csi_v0_CapacityRange_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_csi_v0_CapacityRange_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_CapacityRange_descriptor,
        new java.lang.String[] { "RequiredBytes", "LimitBytes", });
    internal_static_csi_v0_Volume_descriptor =
      getDescriptor().getMessageTypes().get(12);
    internal_static_csi_v0_Volume_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_Volume_descriptor,
        new java.lang.String[] { "CapacityBytes", "Id", "Attributes", "ContentSource", "AccessibleTopology", });
    internal_static_csi_v0_Volume_AttributesEntry_descriptor =
      internal_static_csi_v0_Volume_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_Volume_AttributesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_Volume_AttributesEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_TopologyRequirement_descriptor =
      getDescriptor().getMessageTypes().get(13);
    internal_static_csi_v0_TopologyRequirement_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_TopologyRequirement_descriptor,
        new java.lang.String[] { "Requisite", "Preferred", });
    internal_static_csi_v0_Topology_descriptor =
      getDescriptor().getMessageTypes().get(14);
    internal_static_csi_v0_Topology_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_Topology_descriptor,
        new java.lang.String[] { "Segments", });
    internal_static_csi_v0_Topology_SegmentsEntry_descriptor =
      internal_static_csi_v0_Topology_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_Topology_SegmentsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_Topology_SegmentsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_DeleteVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(15);
    internal_static_csi_v0_DeleteVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_DeleteVolumeRequest_descriptor,
        new java.lang.String[] { "VolumeId", "ControllerDeleteSecrets", });
    internal_static_csi_v0_DeleteVolumeRequest_ControllerDeleteSecretsEntry_descriptor =
      internal_static_csi_v0_DeleteVolumeRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_DeleteVolumeRequest_ControllerDeleteSecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_DeleteVolumeRequest_ControllerDeleteSecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_DeleteVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(16);
    internal_static_csi_v0_DeleteVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_DeleteVolumeResponse_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v0_ControllerPublishVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(17);
    internal_static_csi_v0_ControllerPublishVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ControllerPublishVolumeRequest_descriptor,
        new java.lang.String[] { "VolumeId", "NodeId", "VolumeCapability", "Readonly", "ControllerPublishSecrets", "VolumeAttributes", });
    internal_static_csi_v0_ControllerPublishVolumeRequest_ControllerPublishSecretsEntry_descriptor =
      internal_static_csi_v0_ControllerPublishVolumeRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_ControllerPublishVolumeRequest_ControllerPublishSecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ControllerPublishVolumeRequest_ControllerPublishSecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_ControllerPublishVolumeRequest_VolumeAttributesEntry_descriptor =
      internal_static_csi_v0_ControllerPublishVolumeRequest_descriptor.getNestedTypes().get(1);
    internal_static_csi_v0_ControllerPublishVolumeRequest_VolumeAttributesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ControllerPublishVolumeRequest_VolumeAttributesEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_ControllerPublishVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(18);
    internal_static_csi_v0_ControllerPublishVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ControllerPublishVolumeResponse_descriptor,
        new java.lang.String[] { "PublishInfo", });
    internal_static_csi_v0_ControllerPublishVolumeResponse_PublishInfoEntry_descriptor =
      internal_static_csi_v0_ControllerPublishVolumeResponse_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_ControllerPublishVolumeResponse_PublishInfoEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ControllerPublishVolumeResponse_PublishInfoEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_ControllerUnpublishVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(19);
    internal_static_csi_v0_ControllerUnpublishVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ControllerUnpublishVolumeRequest_descriptor,
        new java.lang.String[] { "VolumeId", "NodeId", "ControllerUnpublishSecrets", });
    internal_static_csi_v0_ControllerUnpublishVolumeRequest_ControllerUnpublishSecretsEntry_descriptor =
      internal_static_csi_v0_ControllerUnpublishVolumeRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_ControllerUnpublishVolumeRequest_ControllerUnpublishSecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ControllerUnpublishVolumeRequest_ControllerUnpublishSecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_ControllerUnpublishVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(20);
    internal_static_csi_v0_ControllerUnpublishVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ControllerUnpublishVolumeResponse_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_descriptor =
      getDescriptor().getMessageTypes().get(21);
    internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_descriptor,
        new java.lang.String[] { "VolumeId", "VolumeCapabilities", "VolumeAttributes", "AccessibleTopology", });
    internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_VolumeAttributesEntry_descriptor =
      internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_VolumeAttributesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ValidateVolumeCapabilitiesRequest_VolumeAttributesEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_ValidateVolumeCapabilitiesResponse_descriptor =
      getDescriptor().getMessageTypes().get(22);
    internal_static_csi_v0_ValidateVolumeCapabilitiesResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ValidateVolumeCapabilitiesResponse_descriptor,
        new java.lang.String[] { "Supported", "Message", });
    internal_static_csi_v0_ListVolumesRequest_descriptor =
      getDescriptor().getMessageTypes().get(23);
    internal_static_csi_v0_ListVolumesRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ListVolumesRequest_descriptor,
        new java.lang.String[] { "MaxEntries", "StartingToken", });
    internal_static_csi_v0_ListVolumesResponse_descriptor =
      getDescriptor().getMessageTypes().get(24);
    internal_static_csi_v0_ListVolumesResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ListVolumesResponse_descriptor,
        new java.lang.String[] { "Entries", "NextToken", });
    internal_static_csi_v0_ListVolumesResponse_Entry_descriptor =
      internal_static_csi_v0_ListVolumesResponse_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_ListVolumesResponse_Entry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ListVolumesResponse_Entry_descriptor,
        new java.lang.String[] { "Volume", });
    internal_static_csi_v0_GetCapacityRequest_descriptor =
      getDescriptor().getMessageTypes().get(25);
    internal_static_csi_v0_GetCapacityRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_GetCapacityRequest_descriptor,
        new java.lang.String[] { "VolumeCapabilities", "Parameters", "AccessibleTopology", });
    internal_static_csi_v0_GetCapacityRequest_ParametersEntry_descriptor =
      internal_static_csi_v0_GetCapacityRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_GetCapacityRequest_ParametersEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_GetCapacityRequest_ParametersEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_GetCapacityResponse_descriptor =
      getDescriptor().getMessageTypes().get(26);
    internal_static_csi_v0_GetCapacityResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_GetCapacityResponse_descriptor,
        new java.lang.String[] { "AvailableCapacity", });
    internal_static_csi_v0_ControllerGetCapabilitiesRequest_descriptor =
      getDescriptor().getMessageTypes().get(27);
    internal_static_csi_v0_ControllerGetCapabilitiesRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ControllerGetCapabilitiesRequest_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v0_ControllerGetCapabilitiesResponse_descriptor =
      getDescriptor().getMessageTypes().get(28);
    internal_static_csi_v0_ControllerGetCapabilitiesResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ControllerGetCapabilitiesResponse_descriptor,
        new java.lang.String[] { "Capabilities", });
    internal_static_csi_v0_ControllerServiceCapability_descriptor =
      getDescriptor().getMessageTypes().get(29);
    internal_static_csi_v0_ControllerServiceCapability_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ControllerServiceCapability_descriptor,
        new java.lang.String[] { "Rpc", "Type", });
    internal_static_csi_v0_ControllerServiceCapability_RPC_descriptor =
      internal_static_csi_v0_ControllerServiceCapability_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_ControllerServiceCapability_RPC_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ControllerServiceCapability_RPC_descriptor,
        new java.lang.String[] { "Type", });
    internal_static_csi_v0_CreateSnapshotRequest_descriptor =
      getDescriptor().getMessageTypes().get(30);
    internal_static_csi_v0_CreateSnapshotRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_CreateSnapshotRequest_descriptor,
        new java.lang.String[] { "SourceVolumeId", "Name", "CreateSnapshotSecrets", "Parameters", });
    internal_static_csi_v0_CreateSnapshotRequest_CreateSnapshotSecretsEntry_descriptor =
      internal_static_csi_v0_CreateSnapshotRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_CreateSnapshotRequest_CreateSnapshotSecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_CreateSnapshotRequest_CreateSnapshotSecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_CreateSnapshotRequest_ParametersEntry_descriptor =
      internal_static_csi_v0_CreateSnapshotRequest_descriptor.getNestedTypes().get(1);
    internal_static_csi_v0_CreateSnapshotRequest_ParametersEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_CreateSnapshotRequest_ParametersEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_CreateSnapshotResponse_descriptor =
      getDescriptor().getMessageTypes().get(31);
    internal_static_csi_v0_CreateSnapshotResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_CreateSnapshotResponse_descriptor,
        new java.lang.String[] { "Snapshot", });
    internal_static_csi_v0_Snapshot_descriptor =
      getDescriptor().getMessageTypes().get(32);
    internal_static_csi_v0_Snapshot_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_Snapshot_descriptor,
        new java.lang.String[] { "SizeBytes", "Id", "SourceVolumeId", "CreatedAt", "Status", });
    internal_static_csi_v0_SnapshotStatus_descriptor =
      getDescriptor().getMessageTypes().get(33);
    internal_static_csi_v0_SnapshotStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_SnapshotStatus_descriptor,
        new java.lang.String[] { "Type", "Details", });
    internal_static_csi_v0_DeleteSnapshotRequest_descriptor =
      getDescriptor().getMessageTypes().get(34);
    internal_static_csi_v0_DeleteSnapshotRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_DeleteSnapshotRequest_descriptor,
        new java.lang.String[] { "SnapshotId", "DeleteSnapshotSecrets", });
    internal_static_csi_v0_DeleteSnapshotRequest_DeleteSnapshotSecretsEntry_descriptor =
      internal_static_csi_v0_DeleteSnapshotRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_DeleteSnapshotRequest_DeleteSnapshotSecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_DeleteSnapshotRequest_DeleteSnapshotSecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_DeleteSnapshotResponse_descriptor =
      getDescriptor().getMessageTypes().get(35);
    internal_static_csi_v0_DeleteSnapshotResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_DeleteSnapshotResponse_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v0_ListSnapshotsRequest_descriptor =
      getDescriptor().getMessageTypes().get(36);
    internal_static_csi_v0_ListSnapshotsRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ListSnapshotsRequest_descriptor,
        new java.lang.String[] { "MaxEntries", "StartingToken", "SourceVolumeId", "SnapshotId", });
    internal_static_csi_v0_ListSnapshotsResponse_descriptor =
      getDescriptor().getMessageTypes().get(37);
    internal_static_csi_v0_ListSnapshotsResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ListSnapshotsResponse_descriptor,
        new java.lang.String[] { "Entries", "NextToken", });
    internal_static_csi_v0_ListSnapshotsResponse_Entry_descriptor =
      internal_static_csi_v0_ListSnapshotsResponse_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_ListSnapshotsResponse_Entry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_ListSnapshotsResponse_Entry_descriptor,
        new java.lang.String[] { "Snapshot", });
    internal_static_csi_v0_NodeStageVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(38);
    internal_static_csi_v0_NodeStageVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeStageVolumeRequest_descriptor,
        new java.lang.String[] { "VolumeId", "PublishInfo", "StagingTargetPath", "VolumeCapability", "NodeStageSecrets", "VolumeAttributes", });
    internal_static_csi_v0_NodeStageVolumeRequest_PublishInfoEntry_descriptor =
      internal_static_csi_v0_NodeStageVolumeRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_NodeStageVolumeRequest_PublishInfoEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeStageVolumeRequest_PublishInfoEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_NodeStageVolumeRequest_NodeStageSecretsEntry_descriptor =
      internal_static_csi_v0_NodeStageVolumeRequest_descriptor.getNestedTypes().get(1);
    internal_static_csi_v0_NodeStageVolumeRequest_NodeStageSecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeStageVolumeRequest_NodeStageSecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_NodeStageVolumeRequest_VolumeAttributesEntry_descriptor =
      internal_static_csi_v0_NodeStageVolumeRequest_descriptor.getNestedTypes().get(2);
    internal_static_csi_v0_NodeStageVolumeRequest_VolumeAttributesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeStageVolumeRequest_VolumeAttributesEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_NodeStageVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(39);
    internal_static_csi_v0_NodeStageVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeStageVolumeResponse_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v0_NodeUnstageVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(40);
    internal_static_csi_v0_NodeUnstageVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeUnstageVolumeRequest_descriptor,
        new java.lang.String[] { "VolumeId", "StagingTargetPath", });
    internal_static_csi_v0_NodeUnstageVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(41);
    internal_static_csi_v0_NodeUnstageVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeUnstageVolumeResponse_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v0_NodePublishVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(42);
    internal_static_csi_v0_NodePublishVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodePublishVolumeRequest_descriptor,
        new java.lang.String[] { "VolumeId", "PublishInfo", "StagingTargetPath", "TargetPath", "VolumeCapability", "Readonly", "NodePublishSecrets", "VolumeAttributes", });
    internal_static_csi_v0_NodePublishVolumeRequest_PublishInfoEntry_descriptor =
      internal_static_csi_v0_NodePublishVolumeRequest_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_NodePublishVolumeRequest_PublishInfoEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodePublishVolumeRequest_PublishInfoEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_NodePublishVolumeRequest_NodePublishSecretsEntry_descriptor =
      internal_static_csi_v0_NodePublishVolumeRequest_descriptor.getNestedTypes().get(1);
    internal_static_csi_v0_NodePublishVolumeRequest_NodePublishSecretsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodePublishVolumeRequest_NodePublishSecretsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_NodePublishVolumeRequest_VolumeAttributesEntry_descriptor =
      internal_static_csi_v0_NodePublishVolumeRequest_descriptor.getNestedTypes().get(2);
    internal_static_csi_v0_NodePublishVolumeRequest_VolumeAttributesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodePublishVolumeRequest_VolumeAttributesEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_csi_v0_NodePublishVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(43);
    internal_static_csi_v0_NodePublishVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodePublishVolumeResponse_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v0_NodeUnpublishVolumeRequest_descriptor =
      getDescriptor().getMessageTypes().get(44);
    internal_static_csi_v0_NodeUnpublishVolumeRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeUnpublishVolumeRequest_descriptor,
        new java.lang.String[] { "VolumeId", "TargetPath", });
    internal_static_csi_v0_NodeUnpublishVolumeResponse_descriptor =
      getDescriptor().getMessageTypes().get(45);
    internal_static_csi_v0_NodeUnpublishVolumeResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeUnpublishVolumeResponse_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v0_NodeGetIdRequest_descriptor =
      getDescriptor().getMessageTypes().get(46);
    internal_static_csi_v0_NodeGetIdRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeGetIdRequest_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v0_NodeGetIdResponse_descriptor =
      getDescriptor().getMessageTypes().get(47);
    internal_static_csi_v0_NodeGetIdResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeGetIdResponse_descriptor,
        new java.lang.String[] { "NodeId", });
    internal_static_csi_v0_NodeGetCapabilitiesRequest_descriptor =
      getDescriptor().getMessageTypes().get(48);
    internal_static_csi_v0_NodeGetCapabilitiesRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeGetCapabilitiesRequest_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v0_NodeGetCapabilitiesResponse_descriptor =
      getDescriptor().getMessageTypes().get(49);
    internal_static_csi_v0_NodeGetCapabilitiesResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeGetCapabilitiesResponse_descriptor,
        new java.lang.String[] { "Capabilities", });
    internal_static_csi_v0_NodeServiceCapability_descriptor =
      getDescriptor().getMessageTypes().get(50);
    internal_static_csi_v0_NodeServiceCapability_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeServiceCapability_descriptor,
        new java.lang.String[] { "Rpc", "Type", });
    internal_static_csi_v0_NodeServiceCapability_RPC_descriptor =
      internal_static_csi_v0_NodeServiceCapability_descriptor.getNestedTypes().get(0);
    internal_static_csi_v0_NodeServiceCapability_RPC_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeServiceCapability_RPC_descriptor,
        new java.lang.String[] { "Type", });
    internal_static_csi_v0_NodeGetInfoRequest_descriptor =
      getDescriptor().getMessageTypes().get(51);
    internal_static_csi_v0_NodeGetInfoRequest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeGetInfoRequest_descriptor,
        new java.lang.String[] { });
    internal_static_csi_v0_NodeGetInfoResponse_descriptor =
      getDescriptor().getMessageTypes().get(52);
    internal_static_csi_v0_NodeGetInfoResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_csi_v0_NodeGetInfoResponse_descriptor,
        new java.lang.String[] { "NodeId", "MaxVolumesPerNode", "AccessibleTopology", });
    com.google.protobuf.WrappersProto.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
